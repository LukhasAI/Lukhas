"""Security tests for OWASP A09: Security Logging and Monitoring Failures.

Tests audit logging, security event detection, log integrity, and monitoring
to ensure security events are properly logged and monitored.

OWASP A09 Reference: https://owasp.org/Top10/A09_2021-Security_Logging_and_Monitoring_Failures/
"""

import pytest
import time
from unittest.mock import MagicMock, patch, call
from datetime import datetime, timezone

from lukhas.governance.audit import (
    AuditLogger,
    AuditEvent,
    AuditEventType,
    AuditConfig,
    InMemoryAuditStorage,
    FileAuditStorage,
)
from lukhas.governance.audit.config import get_testing_config


class TestSecurityLoggingFailures:
    """Test suite for OWASP A09: Security Logging and Monitoring Failures."""

    def setup_method(self):
        """Set up test fixtures."""
        self.config = get_testing_config()
        self.logger = AuditLogger(config=self.config)

    # Test 1: Authentication Events Logged

    def test_successful_login_logged(self):
        """Test that successful logins are logged."""
        self.logger.log_authentication_event(
            user_id="user_abc",
            event_type=AuditEventType.LOGIN_SUCCESS,
            ip_address="203.0.113.1",
            user_agent="Mozilla/5.0",
            success=True,
        )

        events = self.logger.get_events(
            user_id="user_abc",
            event_types=[AuditEventType.LOGIN_SUCCESS]
        )

        assert len(events) == 1
        assert events[0].user_id == "user_abc"
        assert events[0].ip_address == "203.0.113.1"
        assert events[0].success is True

    def test_failed_login_logged(self):
        """Test that failed login attempts are logged."""
        self.logger.log_authentication_event(
            user_id="user_abc",
            event_type=AuditEventType.LOGIN_FAILURE,
            ip_address="203.0.113.1",
            success=False,
            error_message="Invalid password",
        )

        events = self.logger.get_events(
            user_id="user_abc",
            event_types=[AuditEventType.LOGIN_FAILURE]
        )

        assert len(events) == 1
        assert events[0].success is False
        assert events[0].error_message == "Invalid password"

    def test_logout_logged(self):
        """Test that logout events are logged."""
        self.logger.log_authentication_event(
            user_id="user_abc",
            event_type=AuditEventType.LOGOUT,
            ip_address="203.0.113.1",
        )

        events = self.logger.get_events(
            user_id="user_abc",
            event_types=[AuditEventType.LOGOUT]
        )

        assert len(events) == 1

    # Test 2: Data Access Logged

    def test_data_read_logged(self):
        """Test that data read operations are logged."""
        self.logger.log_data_access_event(
            user_id="user_abc",
            event_type=AuditEventType.DATA_READ,
            resource_type="feedback_card",
            resource_id="card_123",
            ip_address="203.0.113.1",
        )

        events = self.logger.get_events(
            resource_type="feedback_card",
            event_types=[AuditEventType.DATA_READ]
        )

        assert len(events) == 1
        assert events[0].resource_id == "card_123"

    def test_data_modification_logged(self):
        """Test that data modifications are logged."""
        # Test CREATE
        self.logger.log_data_access_event(
            user_id="user_abc",
            event_type=AuditEventType.DATA_CREATE,
            resource_type="feedback_card",
            resource_id="card_new",
        )

        # Test UPDATE
        self.logger.log_data_access_event(
            user_id="user_abc",
            event_type=AuditEventType.DATA_UPDATE,
            resource_type="feedback_card",
            resource_id="card_123",
        )

        # Test DELETE
        self.logger.log_data_access_event(
            user_id="user_abc",
            event_type=AuditEventType.DATA_DELETE,
            resource_type="feedback_card",
            resource_id="card_123",
        )

        events = self.logger.get_events(user_id="user_abc")

        # Should have all three events
        assert len(events) == 3
        event_types = [e.event_type for e in events]
        assert AuditEventType.DATA_CREATE in event_types
        assert AuditEventType.DATA_UPDATE in event_types
        assert AuditEventType.DATA_DELETE in event_types

    def test_bulk_export_logged(self):
        """Test that bulk data exports are logged."""
        self.logger.log_data_access_event(
            user_id="user_abc",
            event_type=AuditEventType.BULK_EXPORT,
            resource_type="user_data",
            resource_id="user_abc",
            metadata={"gdpr_request": True, "data_sources": ["profile", "feedback"]},
        )

        events = self.logger.get_events(
            event_types=[AuditEventType.BULK_EXPORT]
        )

        assert len(events) == 1
        assert events[0].metadata["gdpr_request"] is True

    # Test 3: Security Events Logged

    def test_unauthorized_access_logged(self):
        """Test that unauthorized access attempts are logged."""
        self.logger.log_security_event(
            event_type=AuditEventType.UNAUTHORIZED_ACCESS,
            user_id="user_abc",
            ip_address="203.0.113.1",
            resource_type="admin_panel",
            success=False,
            error_message="Insufficient privileges",
        )

        events = self.logger.get_events(
            event_types=[AuditEventType.UNAUTHORIZED_ACCESS]
        )

        assert len(events) == 1
        assert events[0].success is False

    def test_rate_limit_exceeded_logged(self):
        """Test that rate limit violations are logged."""
        self.logger.log_security_event(
            event_type=AuditEventType.RATE_LIMIT_EXCEEDED,
            user_id="user_abc",
            ip_address="203.0.113.1",
            metadata={"limit": 10, "requests": 15},
        )

        events = self.logger.get_events(
            event_types=[AuditEventType.RATE_LIMIT_EXCEEDED]
        )

        assert len(events) == 1
        assert events[0].metadata["requests"] == 15

    def test_invalid_token_logged(self):
        """Test that invalid token attempts are logged."""
        self.logger.log_security_event(
            event_type=AuditEventType.INVALID_TOKEN,
            ip_address="203.0.113.1",
            user_agent="curl/7.68.0",
            error_message="Token signature verification failed",
        )

        events = self.logger.get_events(
            event_types=[AuditEventType.INVALID_TOKEN]
        )

        assert len(events) == 1

    def test_suspicious_activity_logged(self):
        """Test that suspicious activity is logged."""
        self.logger.log_security_event(
            event_type=AuditEventType.SUSPICIOUS_ACTIVITY,
            user_id="user_abc",
            ip_address="203.0.113.1",
            metadata={
                "reason": "Rapid IP changes",
                "ips": ["203.0.113.1", "198.51.100.1", "192.0.2.1"],
            },
        )

        events = self.logger.get_events(
            event_types=[AuditEventType.SUSPICIOUS_ACTIVITY]
        )

        assert len(events) == 1
        assert len(events[0].metadata["ips"]) == 3

    # Test 4: Administrative Actions Logged

    def test_admin_actions_logged(self):
        """Test that administrative actions are logged."""
        self.logger.log_admin_action(
            user_id="admin_user",
            event_type=AuditEventType.ADMIN_ACTION,
            action="User password reset",
            resource_type="user",
            resource_id="user_abc",
            metadata={"reason": "User requested reset"},
        )

        events = self.logger.get_events(
            event_types=[AuditEventType.ADMIN_ACTION]
        )

        assert len(events) == 1
        assert events[0].action == "User password reset"

    def test_config_changes_logged(self):
        """Test that configuration changes are logged."""
        self.logger.log_admin_action(
            user_id="admin_user",
            event_type=AuditEventType.CONFIG_CHANGE,
            action="Updated rate limit configuration",
            metadata={
                "old_value": 10,
                "new_value": 20,
                "setting": "tier1_rate_limit",
            },
        )

        events = self.logger.get_events(
            event_types=[AuditEventType.CONFIG_CHANGE]
        )

        assert len(events) == 1
        assert events[0].metadata["new_value"] == 20

    # Test 5: Event Integrity

    def test_events_have_unique_ids(self):
        """Test that all events have unique IDs."""
        # Create multiple events
        for i in range(10):
            self.logger.log_authentication_event(
                user_id=f"user_{i}",
                event_type=AuditEventType.LOGIN_SUCCESS,
            )

        events = self.logger.get_events()

        # All event IDs should be unique
        event_ids = [e.event_id for e in events]
        assert len(event_ids) == len(set(event_ids)), "Duplicate event IDs found"

    def test_events_have_timestamps(self):
        """Test that all events have timestamps."""
        self.logger.log_authentication_event(
            user_id="user_abc",
            event_type=AuditEventType.LOGIN_SUCCESS,
        )

        events = self.logger.get_events()

        assert len(events) == 1
        assert events[0].timestamp > 0
        assert events[0].timestamp <= time.time()

    def test_events_immutable_after_creation(self):
        """Test that events cannot be modified after creation."""
        event = AuditEvent(
            event_type=AuditEventType.LOGIN_SUCCESS,
            user_id="user_abc",
        )

        original_id = event.event_id
        original_timestamp = event.timestamp

        # Events are dataclasses, but they should be treated as immutable
        # In production, storage should enforce immutability

        assert event.event_id == original_id
        assert event.timestamp == original_timestamp

    # Test 6: Log Querying

    def test_query_by_user_id(self):
        """Test querying events by user_id."""
        # Create events for different users
        self.logger.log_authentication_event(
            user_id="user_abc",
            event_type=AuditEventType.LOGIN_SUCCESS,
        )
        self.logger.log_authentication_event(
            user_id="user_xyz",
            event_type=AuditEventType.LOGIN_SUCCESS,
        )

        # Query for specific user
        events = self.logger.get_events(user_id="user_abc")

        assert len(events) == 1
        assert events[0].user_id == "user_abc"

    def test_query_by_time_range(self):
        """Test querying events by time range."""
        start_time = time.time()

        self.logger.log_authentication_event(
            user_id="user_abc",
            event_type=AuditEventType.LOGIN_SUCCESS,
        )

        time.sleep(0.1)
        end_time = time.time()

        # Query events in time range
        events = self.logger.get_events(
            start_time=start_time,
            end_time=end_time,
        )

        assert len(events) == 1

    def test_query_by_event_type(self):
        """Test querying events by event type."""
        self.logger.log_authentication_event(
            user_id="user_abc",
            event_type=AuditEventType.LOGIN_SUCCESS,
        )
        self.logger.log_authentication_event(
            user_id="user_abc",
            event_type=AuditEventType.LOGOUT,
        )

        # Query for specific event type
        events = self.logger.get_events(
            event_types=[AuditEventType.LOGIN_SUCCESS]
        )

        assert len(events) == 1
        assert events[0].event_type == AuditEventType.LOGIN_SUCCESS

    def test_query_by_resource(self):
        """Test querying events by resource type and ID."""
        self.logger.log_data_access_event(
            user_id="user_abc",
            event_type=AuditEventType.DATA_READ,
            resource_type="feedback_card",
            resource_id="card_123",
        )

        # Query for specific resource
        events = self.logger.get_events(
            resource_type="feedback_card",
            resource_id="card_123",
        )

        assert len(events) == 1
        assert events[0].resource_id == "card_123"

    # Test 7: Log Retention

    def test_old_logs_cleaned_up(self):
        """Test that old logs are cleaned up based on retention policy."""
        # This requires time manipulation or mocking
        # For now, test that cleanup function exists and works
        removed = self.logger.cleanup_old_logs(retention_days=0)

        # Should remove all events if retention is 0 days
        assert removed >= 0

        # Verify events are gone
        events = self.logger.get_events()
        assert len(events) == 0

    # Test 8: Statistics and Monitoring

    def test_get_statistics(self):
        """Test getting audit log statistics."""
        # Create various events
        self.logger.log_authentication_event(
            user_id="user_abc",
            event_type=AuditEventType.LOGIN_SUCCESS,
        )
        self.logger.log_authentication_event(
            user_id="user_abc",
            event_type=AuditEventType.LOGIN_FAILURE,
        )

        stats = self.logger.get_statistics()

        assert "total_events" in stats
        assert stats["total_events"] == 2

    # Test 9: High-Volume Logging

    def test_high_volume_logging_performance(self):
        """Test that logging handles high volume efficiently."""
        # Log 1000 events
        start_time = time.time()

        for i in range(1000):
            self.logger.log_authentication_event(
                user_id=f"user_{i % 100}",  # 100 unique users
                event_type=AuditEventType.LOGIN_SUCCESS,
            )

        elapsed = time.time() - start_time

        # Should complete in reasonable time (< 1 second for 1000 events)
        assert elapsed < 1.0, f"Logging too slow: {elapsed:.2f}s for 1000 events"

        # All events should be stored
        events = self.logger.get_events()
        assert len(events) == 1000

    # Test 10: Concurrent Access

    def test_concurrent_logging_safe(self):
        """Test that concurrent logging is thread-safe."""
        import threading

        def log_events():
            for i in range(100):
                self.logger.log_authentication_event(
                    user_id="user_abc",
                    event_type=AuditEventType.LOGIN_SUCCESS,
                )

        # Create multiple threads
        threads = [threading.Thread(target=log_events) for _ in range(10)]

        # Start all threads
        for t in threads:
            t.start()

        # Wait for completion
        for t in threads:
            t.join()

        # Should have all 1000 events (10 threads * 100 events)
        events = self.logger.get_events()
        assert len(events) == 1000

    # Test 11: File Storage Integrity

    def test_file_storage_append_only(self):
        """Test that file storage is append-only (tamper-evident)."""
        import tempfile
        import os

        # Create temp file for testing
        with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.jsonl') as f:
            log_file = f.name

        try:
            config = AuditConfig(log_file_path=log_file)
            logger = AuditLogger(config=config)

            # Log some events
            logger.log_authentication_event(
                user_id="user_abc",
                event_type=AuditEventType.LOGIN_SUCCESS,
            )

            # File should exist and have content
            assert os.path.exists(log_file)
            file_size_1 = os.path.getsize(log_file)
            assert file_size_1 > 0

            # Log another event
            logger.log_authentication_event(
                user_id="user_xyz",
                event_type=AuditEventType.LOGIN_SUCCESS,
            )

            # File should grow (append-only)
            file_size_2 = os.path.getsize(log_file)
            assert file_size_2 > file_size_1

        finally:
            # Cleanup
            if os.path.exists(log_file):
                os.unlink(log_file)

    # Test 12: Alerting on Security Events

    def test_security_events_can_trigger_alerts(self):
        """Test that security events can trigger alerting."""
        # This would typically integrate with monitoring system
        # For now, test that events are queryable for alerting

        # Create multiple failed login attempts
        for i in range(10):
            self.logger.log_authentication_event(
                user_id="user_abc",
                event_type=AuditEventType.LOGIN_FAILURE,
                ip_address="203.0.113.1",
            )

        # Query recent failures for user
        recent_failures = self.logger.get_events(
            user_id="user_abc",
            event_types=[AuditEventType.LOGIN_FAILURE],
            start_time=time.time() - 3600,  # Last hour
        )

        # Alert should trigger if > 5 failures
        assert len(recent_failures) >= 5

    # Test 13: Sensitive Data Not Logged

    def test_passwords_not_logged(self):
        """Test that passwords are never logged."""
        # Log authentication event
        self.logger.log_authentication_event(
            user_id="user_abc",
            event_type=AuditEventType.LOGIN_FAILURE,
            metadata={"reason": "Invalid credentials"},  # NO password here
        )

        events = self.logger.get_events()

        # Verify no password in event
        for event in events:
            event_str = str(event.to_dict()).lower()
            assert "password" not in event_str
            assert "secret" not in event_str


if __name__ == "__main__":
    pytest.main([__file__, "-v", "--tb=short"])
