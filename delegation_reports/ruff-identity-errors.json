E501 Line too long (135 > 120)
  --> candidate/governance/identity/api/controllers/lambd_id_controller.py:37:121
   |
35 | â€¦
36 | â€¦
37 | â€¦services for LambdaIDController: {e}. Controller will be non-functional.",
   |                                                             ^^^^^^^^^^^^^^^
38 | â€¦
39 | â€¦
   |

E501 Line too long (124 > 120)
   --> candidate/governance/identity/api/controllers/lambd_id_controller.py:173:121
    |
171 |             else:
172 |                 self.logger.warning(
173 |                     f"Î›TRACE: Tier permissions configuration file not found at {config_path}. Using default configuration.")
    |                                                                                                                         ^^^^
174 |                 self.tier_config = {  # Default configuration
175 |                     "tier_permissions": {
    |

E501 Line too long (180 > 120)
   --> candidate/governance/identity/api/controllers/lambd_id_controller.py:200:121
    |
198 | â€¦
199 | â€¦
200 | â€¦tier}, Symbolic Prefs: {bool(symbolic_preferences)}, Entropy Req: {bool(entropy_requirements)}")
    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
201 | â€¦
202 | â€¦
    |

E501 Line too long (126 > 120)
   --> candidate/governance/identity/api/controllers/lambd_id_controller.py:252:121
    |
250 |                 symbolic_input=sym_prefs, tier=user_tier)
251 |             self.logger.debug(
252 |                 f"Î›TRACE ({req_id}): Entropy calculated: {entropy_score_val} for {len(sym_prefs)} symbols, tier {user_tier}.")
    |                                                                                                                         ^^^^^^
253 |
254 |             tier_info_data = self.tier_manager.get_tier_info(
    |

E501 Line too long (147 > 120)
   --> candidate/governance/identity/api/controllers/lambd_id_controller.py:314:121
    |
312 | â€¦
313 | â€¦
314 | â€¦{lambda_id}', Level: '{validation_level}', Check Collision: {check_collision}")
    |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^
315 | â€¦
    |

E501 Line too long (137 > 120)
   --> candidate/governance/identity/api/controllers/lambd_id_controller.py:336:121
    |
334 | â€¦
335 | â€¦
336 | â€¦n failed for '{lambda_id}'. Reason: {basic_validation_res.get('reason')}")
    |                                                           ^^^^^^^^^^^^^^^^^
337 | â€¦
338 | â€¦
    |

E501 Line too long (225 > 120)
   --> candidate/governance/identity/api/controllers/lambd_id_controller.py:368:121
    |
366 | â€¦
367 | â€¦
368 | â€¦ Entropy {id_entropy_score} <= Limit {max_entropy_for_tier} -> {current_validation_details['tier_compliance_check']}")
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
369 | â€¦
370 | â€¦
    |

E501 Line too long (143 > 120)
   --> candidate/governance/identity/api/controllers/lambd_id_controller.py:406:121
    |
404 | â€¦
405 | â€¦
406 | â€¦d}' completed. Overall Valid: {is_overall_valid}. Response: {response_data}")
    |                                                        ^^^^^^^^^^^^^^^^^^^^^^^
407 | â€¦
    |

E501 Line too long (148 > 120)
   --> candidate/governance/identity/api/controllers/lambd_id_controller.py:432:121
    |
430 | â€¦
431 | â€¦
432 | â€¦py. Symbols: {len(symbolic_input)}, Tier: {tier}, Method: {calculation_method}")
    |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
433 | â€¦
434 | â€¦
    |

E501 Line too long (124 > 120)
   --> candidate/governance/identity/api/controllers/lambd_id_controller.py:472:121
    |
470 |                     'timestamp': datetime.now().isoformat()}}
471 |             self.logger.info(
472 |                 f"Î›TRACE ({req_id}): Entropy calculation successful. Score: {entropy_score_val}. Response: {response_data}")
    |                                                                                                                         ^^^^
473 |             return response_data
    |

E501 Line too long (148 > 120)
   --> candidate/governance/identity/api/controllers/lambd_id_controller.py:497:121
    |
495 | â€¦
496 | â€¦
497 | â€¦on. Specific Tier: {specific_tier}, Include Progression: {include_progression}")
    |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
498 | â€¦
499 | â€¦
    |

E501 Line too long (132 > 120)
   --> candidate/governance/identity/api/controllers/lambd_id_controller.py:555:121
    |
553 |         req_id = f"tierup_{int(time.time()*1000)}"
554 |         self.logger.info(
555 |             f"Î›TRACE ({req_id}): Received request for tier upgrade. Current Î›iD: '{current_lambda_id}', Target Tier: {target_tier}")
    |                                                                                                                         ^^^^^^^^^^^^
556 |         req_meta = request_metadata or {}
557 |         val_data = validation_data or {}
    |

E501 Line too long (134 > 120)
   --> candidate/governance/identity/api/controllers/lambd_id_controller.py:637:121
    |
635 | â€¦     if not new_id_generation_result.get('success'):
636 | â€¦         self.logger.error(
637 | â€¦             f"Î›TRACE ({req_id}): Failed to generate new Î›iD for tier upgrade. Error: {new_id_generation_result.get('error')}")
    |                                                                                                                   ^^^^^^^^^^^^^^
638 | â€¦         return {
639 | â€¦             'success': False,
    |

E501 Line too long (131 > 120)
   --> candidate/governance/identity/api/controllers/lambd_id_controller.py:666:121
    |
664 |                     'entropy_score_new_id': new_id_generation_result.get('entropy_score'),
665 |                     # Simplified
666 |                     'new_tier_permissions_summary': self._identity_core.resolve_access_tier(target_tier).get('description', 'N/A'),
    |                                                                                                                         ^^^^^^^^^^^
667 |                     'new_symbolic_representation': new_id_generation_result.get('symbolic_representation')
668 |                 }
    |

E501 Line too long (121 > 120)
   --> candidate/governance/identity/api/controllers/lambd_id_controller.py:736:121
    |
734 |                 except Exception as e_service_health:
735 |                     self.logger.error(
736 |                         f"Î›TRACE ({req_id}): Error during health check for service '{service_name}': {e_service_health}",
    |                                                                                                                         ^
737 |                         exc_info=True)
738 |                     service_status = {
    |

E501 Line too long (162 > 120)
   --> candidate/governance/identity/api/controllers/lambd_id_controller.py:752:121
    |
750 | â€¦
751 | â€¦
752 | â€¦Overall: {final_status['overall_status']}. Details: {final_status['service_details']}")
    |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
753 | â€¦
    |

invalid-syntax: Expected '(', found '.'
   --> candidate/governance/identity/api/controllers/lambd_id_controller.py:775:23
    |
773 |     # Human-readable comment: Retrieves permissions for a specific tier from
774 |     # configuration.
775 |     def _identity_core.resolve_access_tier(self, tier_level: int) -> Dict[str, Any]:
    |                       ^
776 |         """Retrieves permissions and limits for a specific tier from the loaded configuration."""
777 |         self.logger.debug(f"Î›TRACE: Getting permissions for tier {tier_level}.")
    |

invalid-syntax: Expected ')', found '('
   --> candidate/governance/identity/api/controllers/lambd_id_controller.py:775:43
    |
773 |     # Human-readable comment: Retrieves permissions for a specific tier from
774 |     # configuration.
775 |     def _identity_core.resolve_access_tier(self, tier_level: int) -> Dict[str, Any]:
    |                                           ^
776 |         """Retrieves permissions and limits for a specific tier from the loaded configuration."""
777 |         self.logger.debug(f"Î›TRACE: Getting permissions for tier {tier_level}.")
    |

invalid-syntax: Expected ',', found ':'
   --> candidate/governance/identity/api/controllers/lambd_id_controller.py:775:60
    |
773 |     # Human-readable comment: Retrieves permissions for a specific tier from
774 |     # configuration.
775 |     def _identity_core.resolve_access_tier(self, tier_level: int) -> Dict[str, Any]:
    |                                                            ^
776 |         """Retrieves permissions and limits for a specific tier from the loaded configuration."""
777 |         self.logger.debug(f"Î›TRACE: Getting permissions for tier {tier_level}.")
    |

invalid-syntax: Expected newline, found '->'
   --> candidate/governance/identity/api/controllers/lambd_id_controller.py:775:67
    |
773 |     # Human-readable comment: Retrieves permissions for a specific tier from
774 |     # configuration.
775 |     def _identity_core.resolve_access_tier(self, tier_level: int) -> Dict[str, Any]:
    |                                                                   ^^
776 |         """Retrieves permissions and limits for a specific tier from the loaded configuration."""
777 |         self.logger.debug(f"Î›TRACE: Getting permissions for tier {tier_level}.")
    |

invalid-syntax: Expected an expression
   --> candidate/governance/identity/api/controllers/lambd_id_controller.py:775:85
    |
773 |     # Human-readable comment: Retrieves permissions for a specific tier from
774 |     # configuration.
775 |     def _identity_core.resolve_access_tier(self, tier_level: int) -> Dict[str, Any]:
    |                                                                                     ^
776 |         """Retrieves permissions and limits for a specific tier from the loaded configuration."""
777 |         self.logger.debug(f"Î›TRACE: Getting permissions for tier {tier_level}.")
    |

invalid-syntax: Unexpected indentation
   --> candidate/governance/identity/api/controllers/lambd_id_controller.py:776:1
    |
774 |     # configuration.
775 |     def _identity_core.resolve_access_tier(self, tier_level: int) -> Dict[str, Any]:
776 |         """Retrieves permissions and limits for a specific tier from the loaded configuration."""
    | ^^^^^^^^
777 |         self.logger.debug(f"Î›TRACE: Getting permissions for tier {tier_level}.")
778 |         # Default permissions if specific tier not found or config missing parts
    |

E501 Line too long (127 > 120)
   --> candidate/governance/identity/api/controllers/lambd_id_controller.py:875:121
    |
873 | â€¦         self, current_entropy_score: float, user_tier: int,
874 | â€¦         current_symbols: List[str]) -> List[str]:
875 | â€¦     """Generates actionable recommendations for improving symbolic input entropy based on current score and tier limits."""
    |                                                                                                                       ^^^^^^^
876 | â€¦     self.logger.debug(
877 | â€¦         f"Î›TRACE: Generating entropy recommendations. Score: {current_entropy_score}, Tier: {user_tier}, Symbols: {len(current_symbâ€¦
    |

E501 Line too long (142 > 120)
   --> candidate/governance/identity/api/controllers/lambd_id_controller.py:877:121
    |
875 | â€¦bolic input entropy based on current score and tier limits."""
876 | â€¦
877 | â€¦{current_entropy_score}, Tier: {user_tier}, Symbols: {len(current_symbols)}")
    |                                                         ^^^^^^^^^^^^^^^^^^^^^^
878 | â€¦
879 | â€¦
    |

E501 Line too long (122 > 120)
   --> candidate/governance/identity/api/controllers/lambd_id_controller.py:887:121
    |
885 |         if current_entropy_score < max_entropy_for_tier * 0.5:  # Significantly below max
886 |             recommendations_list.append(
887 |                 "Your current symbolic set has low entropy. Consider adding more diverse or less common symbols/phrases.")
    |                                                                                                                         ^^
888 |         elif current_entropy_score < max_entropy_for_tier * 0.8:
889 |             recommendations_list.append(
    |

E501 Line too long (155 > 120)
   --> candidate/governance/identity/api/controllers/lambd_id_controller.py:894:121
    |
892 | â€¦
893 | â€¦
894 | â€¦ent_symbols)} more symbols for your current tier to potentially increase entropy.")
    |                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
895 | â€¦t_entropy_score < max_entropy_for_tier:
896 | â€¦
    |

E501 Line too long (146 > 120)
   --> candidate/governance/identity/api/controllers/lambd_id_controller.py:897:121
    |
895 | â€¦urrent_entropy_score < max_entropy_for_tier:
896 | â€¦
897 | â€¦further increase entropy, try replacing common symbols with more unique ones.")
    |                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^
898 | â€¦
899 | â€¦se should ideally be prevented by generation logic
    |

E501 Line too long (217 > 120)
   --> candidate/governance/identity/api/controllers/lambd_id_controller.py:901:121
    |
899 | â€¦neration logic
900 | â€¦
901 | â€¦r Tier {user_tier} ({max_entropy_for_tier:.2f}). This might indicate an issue or an opportunity for tier review.")
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
902 | â€¦
903 | â€¦
    |

invalid-syntax: Expected a statement
   --> candidate/governance/identity/api/controllers/lambd_id_controller.py:942:1
    |
940 | # LICENSE: PROPRIETARY - LUKHAS AI SYSTEMS - UNAUTHORIZED ACCESS PROHIBITED
941 | # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    |                                                                              ^
    |

DTZ003 `datetime.datetime.utcnow()` used
  --> candidate/governance/identity/audit/glyph_timeline_generator.py:75:21
   |
73 |         """Generate mock authentication events for testing"""
74 |         events = []
75 |         base_time = datetime.utcnow() - timedelta(hours=24)
   |                     ^^^^^^^^^^^^^^^^^
76 |
77 |         users = [
   |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth/adaptive_ui_controller.py:143:23
    |
141 |             stress_indicators=stress_indicators,
142 |             fatigue_level=fatigue_level,
143 |             timestamp=datetime.now(),
    |                       ^^^^^^^^^^^^^^
144 |         )
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth/adaptive_ui_controller.py:177:29
    |
176 |         # Session duration factor
177 |         session_duration = (datetime.now() - self.cognitive_history[0].timestamp).total_seconds() / 3600.0  # hours
    |                             ^^^^^^^^^^^^^^
178 |         # Fatigue increases over 2 hours
179 |         duration_fatigue = min(1.0, session_duration / 2.0)
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

PERF203 `try`-`except` within a loop incurs performance overhead
   --> candidate/governance/identity/auth/adaptive_ui_controller.py:276:17
    |
274 |                   try:
275 |                       callback(new_config, adaptation_reasons)
276 | /                 except Exception as e:
277 | |                     ui_logger.error(f"Error in adaptation callback: {e}")
    | |_________________________________________________________________________^
278 |           else:
279 |               ui_logger.warning(f"UI adaptation blocked by constitutional violations: {violations}")
    |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
  --> candidate/governance/identity/auth/constitutional_gatekeeper.py:67:29
   |
65 |         self.thresholds = ConstitutionalThresholds()
66 |         self.violation_history: list[dict] = []
67 |         self.startup_time = datetime.now()
   |                             ^^^^^^^^^^^^^^
68 |
69 |         constitutional_logger.info(f"Constitutional Gatekeeper initialized with {enforcement_level.value} enforcement")
   |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth/constitutional_gatekeeper.py:378:26
    |
376 |         """
377 |         log_entry = {
378 |             "timestamp": datetime.now().isoformat(),
    |                          ^^^^^^^^^^^^^^
379 |             "action_type": action_type,
380 |             "enforcement_level": self.enforcement_level.value,
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth/constitutional_gatekeeper.py:406:30
    |
404 |             "total_actions": len(self.violation_history),
405 |             "action_history": self.violation_history[-50:],  # Last 50 actions
406 |             "uptime_hours": (datetime.now() - self.startup_time).total_seconds() / 3600,
    |                              ^^^^^^^^^^^^^^
407 |         }
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth/constitutional_gatekeeper.py:433:32
    |
431 |         emergency_report = {
432 |             "emergency_activated": True,
433 |             "activation_time": datetime.now().isoformat(),
    |                                ^^^^^^^^^^^^^^
434 |             "reason": reason,
435 |             "new_thresholds": asdict(self.thresholds),
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth/cultural_profile_manager.py:289:24
    |
287 |             custom_exclusions=kwargs.get("custom_exclusions", []),
288 |             custom_inclusions=kwargs.get("custom_inclusions", []),
289 |             created_at=datetime.now(),
    |                        ^^^^^^^^^^^^^^
290 |             last_updated=datetime.now(),
291 |         )
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth/cultural_profile_manager.py:290:26
    |
288 |             custom_inclusions=kwargs.get("custom_inclusions", []),
289 |             created_at=datetime.now(),
290 |             last_updated=datetime.now(),
    |                          ^^^^^^^^^^^^^^
291 |         )
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

ARG002 Unused method argument: `context`
   --> candidate/governance/identity/auth/cultural_profile_manager.py:353:53
    |
352 |     def _should_exclude_emoji(
353 |         self, emoji: str, profile: CulturalProfile, context: Optional[str]
    |                                                     ^^^^^^^
354 |     ) -> tuple[bool, dict[str, str]]:
355 |         """
    |

ARG002 Unused method argument: `category_hint`
   --> candidate/governance/identity/auth/cultural_profile_manager.py:412:50
    |
411 |     def suggest_alternative_emojis(
412 |         self, excluded_emoji: str, user_id: str, category_hint: Optional[str] = None
    |                                                  ^^^^^^^^^^^^^
413 |     ) -> list[str]:
414 |         """
    |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth/cultural_profile_manager.py:507:32
    |
505 |                 setattr(profile, key, value)
506 |
507 |         profile.last_updated = datetime.now()
    |                                ^^^^^^^^^^^^^^
508 |
509 |         cultural_logger.info(f"Updated cultural profile for user {user_id}")
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

ARG002 Unused method argument: `path`
   --> candidate/governance/identity/auth/entropy_synchronizer.py:109:58
    |
107 |             return False
108 |
109 |     async def _handle_device_connection(self, websocket, path):
    |                                                          ^^^^
110 |         """Handle incoming device connections"""
111 |         device_id = None
    |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth/entropy_synchronizer.py:174:27
    |
172 |                 device_type=device_type,
173 |                 entropy_data=entropy_data,
174 |                 timestamp=datetime.now(),
    |                           ^^^^^^^^^^^^^^
175 |                 quality_score=quality_score,
176 |                 constitutional_validation=constitutional_valid,
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth/entropy_synchronizer.py:226:28
    |
224 |         # Check temporal freshness
225 |         if "timestamp" in entropy_data:
226 |             age_seconds = (datetime.now() - datetime.fromisoformat(entropy_data["timestamp"])).total_seconds()
    |                            ^^^^^^^^^^^^^^
227 |             freshness_score = max(0.0, 1.0 - (age_seconds / 60.0))  # Decay over 1 minute
228 |             quality_factors.append(freshness_score)
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth/entropy_synchronizer.py:280:26
    |
278 |             "total_entropy_bits": self._calculate_total_entropy_bits(),
279 |             "device_count": len(self.connected_devices),
280 |             "timestamp": datetime.now().isoformat(),
    |                          ^^^^^^^^^^^^^^
281 |         }
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

PERF203 `try`-`except` within a loop incurs performance overhead
   --> candidate/governance/identity/auth/entropy_synchronizer.py:287:13
    |
285 |               try:
286 |                   await callback(completion_message)
287 | /             except Exception as e:
288 | |                 entropy_logger.error(f"Error in sync callback: {e}")
    | |____________________________________________________________________^
289 |
290 |       def add_sync_callback(self, callback):
    |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
  --> candidate/governance/identity/auth/qi_consciousness_visualizer.py:67:26
   |
65 |             "neural_field": f"NeRF visualization for: {seed_phrase}",
66 |             "consciousness_level": consciousness_level,
67 |             "timestamp": datetime.now().isoformat(),
   |                          ^^^^^^^^^^^^^^
68 |         }
   |
help: Pass a `datetime.timezone` object to the `tz` parameter

ARG002 Unused method argument: `data`
   --> candidate/governance/identity/auth/qrg_generators.py:321:41
    |
319 |         }
320 |
321 |     def _validate_cultural_safety(self, data: str, theme: CulturalQRTheme) -> dict[str, Any]:
    |                                         ^^^^
322 |         """Validate cultural safety of QR code content."""
323 |         # Placeholder for cultural safety validation
    |

ARG002 Unused method argument: `theme`
   --> candidate/governance/identity/auth/qrg_generators.py:321:52
    |
319 |         }
320 |
321 |     def _validate_cultural_safety(self, data: str, theme: CulturalQRTheme) -> dict[str, Any]:
    |                                                    ^^^^^
322 |         """Validate cultural safety of QR code content."""
323 |         # Placeholder for cultural safety validation
    |

ARG002 Unused method argument: `theme`
   --> candidate/governance/identity/auth/qrg_generators.py:375:56
    |
373 |         return Image.alpha_composite(img, overlay)
374 |
375 |     def _apply_organic_pattern(self, img: Image.Image, theme: CulturalQRTheme) -> Image.Image:
    |                                                        ^^^^^
376 |         """Apply organic cultural patterns."""
377 |         # Add organic flowing patterns
    |

ARG002 Unused method argument: `theme`
   --> candidate/governance/identity/auth/qrg_generators.py:380:55
    |
378 |         return img  # Placeholder implementation
379 |
380 |     def _apply_ornate_pattern(self, img: Image.Image, theme: CulturalQRTheme) -> Image.Image:
    |                                                       ^^^^^
381 |         """Apply ornate decorative patterns."""
382 |         # Add ornate decorative elements
    |

ARG002 Unused method argument: `package`
   --> candidate/governance/identity/auth/qrg_generators.py:639:42
    |
637 |         return level_map.get(security_level, 5)
638 |
639 |     def _constitutional_validation(self, package: dict) -> bool:
    |                                          ^^^^^^^
640 |         """Validate quantum package against constitutional principles."""
641 |         # Placeholder for constitutional validation
    |

RUF006 Store a reference to the return value of `asyncio.create_task`
   --> candidate/governance/identity/auth_backend/audit_logger.py:167:13
    |
165 |         # Start background tasks
166 |         if self.config.get("auto_flush_enabled", True):
167 |             asyncio.create_task(self._auto_flush_loop())
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
168 |
169 |     def _get_default_config(self) -> dict[str, Any]:
    |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/audit_logger.py:209:38
    |
207 |             "enforcement_type": enforcement_type,
208 |             "constitutional_authority": "LUKHAS_CONSTITUTIONAL_GATEKEEPER",
209 |             "enforcement_timestamp": datetime.now().isoformat(),
    |                                      ^^^^^^^^^^^^^^
210 |             "transparency_required": True,
211 |             "immutable_decision": True,
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/audit_logger.py:216:23
    |
214 |         event = AuditEvent(
215 |             event_id=self._generate_event_id(),
216 |             timestamp=datetime.now(),
    |                       ^^^^^^^^^^^^^^
217 |             event_type=AuditEventType.CONSTITUTIONAL_ENFORCEMENT,
218 |             severity=AuditSeverity.CONSTITUTIONAL,
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/audit_logger.py:272:23
    |
270 |         event = AuditEvent(
271 |             event_id=self._generate_event_id(),
272 |             timestamp=datetime.now(),
    |                       ^^^^^^^^^^^^^^
273 |             event_type=AuditEventType.AUTHENTICATION_ATTEMPT,
274 |             severity=severity,
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/audit_logger.py:312:23
    |
310 |         event = AuditEvent(
311 |             event_id=self._generate_event_id(),
312 |             timestamp=datetime.now(),
    |                       ^^^^^^^^^^^^^^
313 |             event_type=AuditEventType.POLICY_VIOLATION,
314 |             severity=AuditSeverity.WARNING,
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/audit_logger.py:376:23
    |
374 |         event = AuditEvent(
375 |             event_id=self._generate_event_id(),
376 |             timestamp=datetime.now(),
    |                       ^^^^^^^^^^^^^^
377 |             event_type=AuditEventType.SYSTEM_OVERRIDE,
378 |             severity=AuditSeverity.CRITICAL,
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/audit_logger.py:431:23
    |
429 |         event = AuditEvent(
430 |             event_id=self._generate_event_id(),
431 |             timestamp=datetime.now(),
    |                       ^^^^^^^^^^^^^^
432 |             event_type=AuditEventType.PERFORMANCE_METRIC,
433 |             severity=AuditSeverity.INFO,
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/audit_logger.py:443:41
    |
441 |                 "metric_unit": metric_unit,
442 |                 "context": context,
443 |                 "collection_timestamp": datetime.now().isoformat(),
    |                                         ^^^^^^^^^^^^^^
444 |             },
445 |             constitutional_context=None,
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/audit_logger.py:517:24
    |
515 |     def _get_current_log_file(self) -> Path:
516 |         """Get current audit log file path."""
517 |         current_date = datetime.now().strftime("%Y-%m-%d")
    |                        ^^^^^^^^^^^^^^
518 |         return self.log_file_path / f"audit_log_{current_date}.jsonl"
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/audit_logger.py:527:29
    |
525 |             if log_file.exists() and log_file.stat().st_size > max_size_bytes:
526 |                 # Rotate file
527 |                 timestamp = datetime.now().strftime("%H%M%S")
    |                             ^^^^^^^^^^^^^^
528 |                 rotated_name = f"{log_file.stem}_{timestamp}{log_file.suffix}"
529 |                 rotated_path = log_file.parent / rotated_name
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

PERF203 `try`-`except` within a loop incurs performance overhead
   --> candidate/governance/identity/auth_backend/audit_logger.py:584:13
    |
582 |                       await self._flush_buffer()
583 |
584 | /             except Exception as e:
585 | |                 logger.error(f"Auto-flush loop error: {e}")
586 | |                 await asyncio.sleep(flush_interval * 2)  # Back off on error
    | |_______________________________________________________^
587 |
588 |       async def query_audit_logs(self, query: AuditQuery) -> list[dict[str, Any]]:
    |

PERF203 `try`-`except` within a loop incurs performance overhead
   --> candidate/governance/identity/auth_backend/audit_logger.py:616:25
    |
614 |                                       return matching_events
615 |
616 | /                         except json.JSONDecodeError:
617 | |                             continue  # Skip malformed lines
    | |____________________________________^
618 |
619 |               except Exception as e:
    |

DTZ007 Naive datetime constructed using `datetime.datetime.strptime()` without %z
   --> candidate/governance/identity/auth_backend/audit_logger.py:643:33
    |
641 |                 date_str = log_file.stem.split("_")[-1]
642 |                 if len(date_str) == 10:  # YYYY-MM-DD format
643 |                     file_date = datetime.strptime(date_str, "%Y-%m-%d").date()
    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
644 |
645 |                     include_file = True
    |
help: Call `.replace(tzinfo=<timezone>)` or `.astimezone()` to convert to an aware datetime

PERF203 `try`-`except` within a loop incurs performance overhead
   --> candidate/governance/identity/auth_backend/audit_logger.py:654:13
    |
652 |                           filtered_files.append(log_file)
653 |
654 | /             except (ValueError, IndexError):
655 | |                 # Include files with non-standard names
656 | |                 filtered_files.append(log_file)
    | |_______________________________________________^
657 |
658 |           return sorted(filtered_files)
    |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/audit_logger.py:870:27
    |
868 |         """
869 |         try:
870 |             cutoff_time = datetime.now() - timedelta(hours=hours)
    |                           ^^^^^^^^^^^^^^
871 |
872 |             # Search through buffered events first
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/audit_logger.py:905:27
    |
903 |         """
904 |         try:
905 |             cutoff_time = datetime.now() - timedelta(hours=hours)
    |                           ^^^^^^^^^^^^^^
906 |
907 |             # Search through buffered events
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/auth_integration_system.py:105:29
    |
103 |         self.config = config or self._get_default_config()
104 |         self.system_id = str(uuid.uuid4())
105 |         self.startup_time = datetime.now()
    |                             ^^^^^^^^^^^^^^
106 |
107 |         # Integration components
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/auth_integration_system.py:141:26
    |
139 |             compliance_rate=1.0,
140 |             integration_uptime=0.0,
141 |             last_updated=datetime.now(),
    |                          ^^^^^^^^^^^^^^
142 |         )
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/auth_integration_system.py:153:26
    |
151 |             compliance_score=0.0,
152 |             active_alerts=[],
153 |             last_checked=datetime.now(),
    |                          ^^^^^^^^^^^^^^
154 |         )
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

RUF006 Store a reference to the return value of `asyncio.create_task`
   --> candidate/governance/identity/auth_backend/auth_integration_system.py:217:13
    |
216 |             # Start background monitoring
217 |             asyncio.create_task(self._background_monitoring())
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
218 |
219 |             self.health_status.overall_status = "healthy"
    |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/auth_integration_system.py:252:33
    |
250 |         """
251 |         try:
252 |             integration_start = datetime.now()
    |                                 ^^^^^^^^^^^^^^
253 |             result = {
254 |                 "user_id": user_id,
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/auth_integration_system.py:450:37
    |
449 |             # Phase 6: Final Integration Assessment
450 |             integration_duration = (datetime.now() - integration_start).total_seconds()
    |                                     ^^^^^^^^^^^^^^
451 |
452 |             # Calculate overall status
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/auth_integration_system.py:488:30
    |
486 |                 "event_type": event_type,
487 |                 "overall_status": "error",
488 |                 "timestamp": datetime.now().isoformat(),
    |                              ^^^^^^^^^^^^^^
489 |             }
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

SIM102 Use a single `if` statement instead of nested `if` statements
   --> candidate/governance/identity/auth_backend/auth_integration_system.py:535:9
    |
534 |           # Include Guardian for security events
535 | /         if event_type in [
536 | |             "constitutional_violation",
537 | |             "bias_detection",
538 | |             "login_failure",
539 | |         ]:
540 | |             if ModuleType.GUARDIAN not in target_modules:
    | |_________________________________________________________^
541 |                   target_modules.append(ModuleType.GUARDIAN)
    |
help: Combine `if` statements using `and`

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/auth_integration_system.py:568:27
    |
567 |         # Update uptime
568 |         uptime_seconds = (datetime.now() - self.startup_time).total_seconds()
    |                           ^^^^^^^^^^^^^^
569 |         self.integration_metrics.integration_uptime = uptime_seconds / 3600  # Convert to hours
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/auth_integration_system.py:571:49
    |
569 |         self.integration_metrics.integration_uptime = uptime_seconds / 3600  # Convert to hours
570 |
571 |         self.integration_metrics.last_updated = datetime.now()
    |                                                 ^^^^^^^^^^^^^^
572 |
573 |     async def _handle_cross_module_message(self, message: Any) -> None:
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/auth_integration_system.py:656:47
    |
654 |                 self.health_status.overall_status = "healthy"
655 |
656 |             self.health_status.last_checked = datetime.now()
    |                                               ^^^^^^^^^^^^^^
657 |
658 |         except Exception as e:
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/auth_integration_system.py:713:29
    |
711 |             "phase": "Phase 7 - Registry Updates and Policy Integration",
712 |             "trinity_framework": "âš›ï¸ðŸ§ ðŸ›¡ï¸",
713 |             "last_updated": datetime.now().isoformat(),
    |                             ^^^^^^^^^^^^^^
714 |         }
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/auth_integration_system.py:722:29
    |
720 |         report = {
721 |             "report_id": str(uuid.uuid4()),
722 |             "generated_at": datetime.now().isoformat(),
    |                             ^^^^^^^^^^^^^^
723 |             "system_status": await self.get_integration_status(),
724 |             "summary": {
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

F821 Undefined name `logger`
   --> candidate/governance/identity/auth_backend/authentication_server.py:137:9
    |
136 |     async def start_server(self):
137 |         logger.info(f"Starting LUKHAS Authentication Server on {self.host}:{self.port}")
    |         ^^^^^^
138 |
139 |         async def server_handler(websocket, path):
    |

F821 Undefined name `logger`
   --> candidate/governance/identity/auth_backend/authentication_server.py:143:9
    |
142 |         self.server = await websockets.serve(server_handler, self.host, self.port)
143 |         logger.info("Server started and listening for connections.")
    |         ^^^^^^
144 |
145 |     async def handle_client_connection(self, websocket, path):
    |

ARG002 Unused method argument: `path`
   --> candidate/governance/identity/auth_backend/authentication_server.py:145:57
    |
143 |         logger.info("Server started and listening for connections.")
144 |
145 |     async def handle_client_connection(self, websocket, path):
    |                                                         ^^^^
146 |         try:
147 |             client_data = await websocket.recv()
    |

F821 Undefined name `logger`
   --> candidate/governance/identity/auth_backend/authentication_server.py:168:21
    |
166 |                     verify_key = nacl.signing.VerifyKey(device_public_key, encoder=nacl.encoding.HexEncoder)
167 |                     self.device_verify_keys[user_id] = verify_key
168 |                     logger.info(f"Device public key stored for user {user_id}")
    |                     ^^^^^^
169 |                 except Exception as e:
170 |                     logger.error(f"Failed to parse device public key: {e}")
    |

F821 Undefined name `logger`
   --> candidate/governance/identity/auth_backend/authentication_server.py:170:21
    |
168 |                     logger.info(f"Device public key stored for user {user_id}")
169 |                 except Exception as e:
170 |                     logger.error(f"Failed to parse device public key: {e}")
    |                     ^^^^^^
171 |                     await websocket.send(json.dumps({"error": "Invalid device public key"}))
172 |                     return
    |

F821 Undefined name `logger`
   --> candidate/governance/identity/auth_backend/authentication_server.py:225:25
    |
223 |                     if not device_id or not isinstance(device_id, str) or len(device_id) > 128:
224 |                         await websocket.send(json.dumps({"error": "Invalid device ID"}))
225 |                         logger.warning(f"Rejected entropy update: invalid device_id {device_id}")
    |                         ^^^^^^
226 |                         self.audit_logger.log_event(
227 |                             f"Rejected entropy update: invalid device_id {device_id}",
    |

F821 Undefined name `logger`
   --> candidate/governance/identity/auth_backend/authentication_server.py:233:25
    |
231 |                     if not self.replay_protection.add_nonce(nonce, device_id=device_id):
232 |                         await websocket.send(json.dumps({"error": "Replay detected for nonce"}))
233 |                         logger.warning(f"Replay detected for nonce {nonce} from device {device_id}")
    |                         ^^^^^^
234 |                         self.audit_logger.log_event(
235 |                             f"Replay detected for nonce {nonce} from device {device_id}",
    |

F821 Undefined name `logger`
   --> candidate/governance/identity/auth_backend/authentication_server.py:244:25
    |
242 |                     if len(timestamps) >= self.entropy_rate_limit:
243 |                         await websocket.send(json.dumps({"error": "Rate limit exceeded for device"}))
244 |                         logger.warning(f"Rate limit exceeded for device {device_id}")
    |                         ^^^^^^
245 |                         self.audit_logger.log_event(
246 |                             f"Rate limit exceeded for device {device_id}",
    |

F821 Undefined name `logger`
   --> candidate/governance/identity/auth_backend/authentication_server.py:360:25
    |
359 |                     except Exception as trust_error:
360 |                         logger.warning(f"Trust scoring failed for session {session_id}: {trust_error}")
    |                         ^^^^^^
361 |                         # Continue with authentication even if trust scoring fails
362 |                         # Trust scoring is enhancement, not critical path
    |

F821 Undefined name `logger`
   --> candidate/governance/identity/auth_backend/authentication_server.py:385:13
    |
383 |                     )
384 |         except Exception as e:
385 |             logger.error(f"Error handling client connection: {e}\n{traceback.format_exc()}")
    |             ^^^^^^
386 |             self.audit_logger.log_event(f"Exception in client connection: {e}", constitutional_tag=True)
    |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/authentication_server.py:389:49
    |
388 |     def create_authentication_session(self, user_id: str) -> str:
389 |         session_id = hashlib.sha256(f"{user_id}{datetime.now()}".encode()).hexdigest()
    |                                                 ^^^^^^^^^^^^^^
390 |         entropy_sync = EntropySynchronizer()
391 |         entropy_sync.last_active = time.time()
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

F821 Undefined name `logger`
   --> candidate/governance/identity/auth_backend/authentication_server.py:401:13
    |
399 |         pqc_signature = session_data.get("pqc_signature")
400 |         if session_id not in self.active_sessions:
401 |             logger.warning("Invalid session ID")
    |             ^^^^^^
402 |             return False
403 |         if not self.constitutional_gatekeeper.validate(entropy_level):
    |

F821 Undefined name `logger`
   --> candidate/governance/identity/auth_backend/authentication_server.py:404:13
    |
402 |             return False
403 |         if not self.constitutional_gatekeeper.validate(entropy_level):
404 |             logger.warning("Entropy level validation failed")
    |             ^^^^^^
405 |             return False
406 |         if not self.crypto_engine.verify_signature(pqc_signature):
    |

F821 Undefined name `logger`
   --> candidate/governance/identity/auth_backend/authentication_server.py:407:13
    |
405 |             return False
406 |         if not self.crypto_engine.verify_signature(pqc_signature):
407 |             logger.warning("PQC signature validation failed")
    |             ^^^^^^
408 |             return False
409 |         self.audit_logger.log_event(f"Authentication request validated for session {session_id}")
    |

F821 Undefined name `logger`
   --> candidate/governance/identity/auth_backend/authentication_server.py:420:17
    |
418 |                     break
419 |             if not verify_key:
420 |                 logger.warning(f"No verify key found for device {device_id}")
    |                 ^^^^^^
421 |                 return False
422 |             signature_bytes = bytes.fromhex(signature_hex)
    |

F821 Undefined name `logger`
   --> candidate/governance/identity/auth_backend/authentication_server.py:426:13
    |
424 |             return True
425 |         except (nacl.exceptions.BadSignatureError, ValueError) as e:
426 |             logger.warning(f"Signature verification failed for device {device_id}: {e}")
    |             ^^^^^^
427 |             return False
    |

F821 Undefined name `logger`
   --> candidate/governance/identity/auth_backend/authentication_server.py:442:17
    |
440 |                 self.audit_logger.log_event(f"Session expired: {session_id}", constitutional_tag=True)
441 |             except Exception as e:
442 |                 logger.error(f"Error expiring session {session_id}: {e}")
    |                 ^^^^^^
443 |                 self.audit_logger.log_event(f"Session expiry error: {e}", constitutional_tag=True)
    |

F821 Undefined name `logger`
   --> candidate/governance/identity/auth_backend/authentication_server.py:457:17
    |
455 |             recent = self.device_reliability[device_id][-5:]
456 |             if all(val < 0.5 for val in recent):
457 |                 logger.critical(f"Device {device_id} reliability degraded: last 5 entropy values < 0.5")
    |                 ^^^^^^
458 |                 self.audit_logger.log_event(
459 |                     f"Device {device_id} reliability degraded: last 5 entropy values < 0.5",
    |

F821 Undefined name `logger`
   --> candidate/governance/identity/auth_backend/authentication_server.py:496:13
    |
494 |             }
495 |         except Exception as e:
496 |             logger.warning(f"Failed to get session info for {user_id}: {e}")
    |             ^^^^^^
497 |             return None
    |

F821 Undefined name `logger`
   --> candidate/governance/identity/auth_backend/authentication_server.py:570:9
    |
568 |         )
569 |
570 |         logger.info(f"Updated consent for user {user_id}: {consent_type} = {granted}")
    |         ^^^^^^
571 |         return True
    |

F821 Undefined name `logger`
   --> candidate/governance/identity/auth_backend/authentication_server.py:621:13
    |
620 |         except Exception as e:
621 |             logger.error(f"Error handling data subject request {request_type.value} for user {user_id}: {e}")
    |             ^^^^^^
622 |             return {"success": False, "error": str(e), "request_id": request_id}
    |

F821 Undefined name `logger`
   --> candidate/governance/identity/auth_backend/authentication_server.py:736:13
    |
735 |         except Exception as e:
736 |             logger.error(f"Error during data erasure for user {user_id}: {e}")
    |             ^^^^^^
737 |             return {"success": False, "error": str(e), "request_id": request_id}
    |

ARG002 Unused method argument: `request_data`
   --> candidate/governance/identity/auth_backend/authentication_server.py:769:48
    |
768 |     async def handle_ccpa_consumer_request(
769 |         self, user_id: str, request_type: str, request_data: dict[str, Any]
    |                                                ^^^^^^^^^^^^
770 |     ) -> dict[str, Any]:
771 |         """Handle CCPA/CPRA consumer privacy requests"""
    |

F821 Undefined name `logger`
   --> candidate/governance/identity/auth_backend/authentication_server.py:807:13
    |
806 |         except Exception as e:
807 |             logger.error(f"Error handling CCPA request {request_type} for user {user_id}: {e}")
    |             ^^^^^^
808 |             return {"success": False, "error": str(e), "request_id": request_id}
    |

PERF203 `try`-`except` within a loop incurs performance overhead
   --> candidate/governance/identity/auth_backend/authentication_server.py:864:17
    |
862 |                       await self._cleanup_expired_privacy_data()
863 |                       await asyncio.sleep(3600)  # Cleanup every hour
864 | /                 except Exception as e:
865 | |                     logger.error(f"Trust scorer cleanup failed: {e}")
866 | |                     await asyncio.sleep(300)  # Retry in 5 minutes on error
    | |____________________________________________^
867 |
868 |           asyncio.create_task(cleanup_task())
    |

F821 Undefined name `logger`
   --> candidate/governance/identity/auth_backend/authentication_server.py:865:21
    |
863 |                     await asyncio.sleep(3600)  # Cleanup every hour
864 |                 except Exception as e:
865 |                     logger.error(f"Trust scorer cleanup failed: {e}")
    |                     ^^^^^^
866 |                     await asyncio.sleep(300)  # Retry in 5 minutes on error
    |

RUF006 Store a reference to the return value of `asyncio.create_task`
   --> candidate/governance/identity/auth_backend/authentication_server.py:868:9
    |
866 |                     await asyncio.sleep(300)  # Retry in 5 minutes on error
867 |
868 |         asyncio.create_task(cleanup_task())
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
869 |
870 |     async def _cleanup_expired_privacy_data(self):
    |

F821 Undefined name `logger`
   --> candidate/governance/identity/auth_backend/authentication_server.py:880:25
    |
878 |                     retention_end = profile.last_consent_update + timedelta(days=retention_days)
879 |                     if current_time > retention_end:
880 |                         logger.info(f"Auto-deleting expired data for user {user_id}, type {data_type}")
    |                         ^^^^^^
881 |                         await self._handle_erasure_request(user_id, f"auto_cleanup_{int(time.time())}")
882 |                         break
    |

F821 Undefined name `logger`
  --> candidate/governance/identity/auth_backend/cross_device_handshake.py:92:13
   |
90 |     def resolve_conflict(self, session_token, conflicting_devices):
91 |         if not conflicting_devices or not isinstance(conflicting_devices, list):
92 |             logger.error(f"Invalid conflict device list for session: {session_token}")
   |             ^^^^^^
93 |             self.audit_logger.log_event(
94 |                 f"Invalid conflict device list for session: {session_token}",
   |

F821 Undefined name `logger`
   --> candidate/governance/identity/auth_backend/cross_device_handshake.py:101:13
    |
 99 |         winner = max(trust_scores, key=trust_scores.get)
100 |         if trust_scores[winner] < 0.5:
101 |             logger.critical(f"Conflict unresolved for session: {session_token} (all trust scores: {trust_scores})")
    |             ^^^^^^
102 |             self.audit_logger.log_event(
103 |                 f"Conflict unresolved for session: {session_token}",
    |

F821 Undefined name `logger`
   --> candidate/governance/identity/auth_backend/cross_device_handshake.py:108:13
    |
106 |             raise ValueError("Conflict could not be resolved. Escalating to constitutional override.")
107 |         if trust_scores[winner] < 0.6:
108 |             logger.warning(
    |             ^^^^^^
109 |                 f"Conflict resolved near threshold for session: {session_token} (winner: {winner}, trust: {trust_scores[winner]})"
110 |             )
    |

E501 Line too long (130 > 120)
   --> candidate/governance/identity/auth_backend/cross_device_handshake.py:109:121
    |
107 |         if trust_scores[winner] < 0.6:
108 |             logger.warning(
109 |                 f"Conflict resolved near threshold for session: {session_token} (winner: {winner}, trust: {trust_scores[winner]})"
    |                                                                                                                         ^^^^^^^^^^
110 |             )
111 |         self.audit_logger.log_event(
    |

F821 Undefined name `logger`
   --> candidate/governance/identity/auth_backend/cross_device_handshake.py:170:13
    |
168 |         token2 = self.link_session(device_a, device_b)
169 |         if token1 == token2:
170 |             logger.warning(f"Session token collision detected for devices: {device_a}, {device_b}")
    |             ^^^^^^
171 |             self.audit_logger.log_event(
172 |                 f"Session token collision detected for devices: {device_a}, {device_b}",
    |

F821 Undefined name `logger`
   --> candidate/governance/identity/auth_backend/cross_device_handshake.py:176:13
    |
174 |             )
175 |         else:
176 |             logger.info(f"No session token collision for devices: {device_a}, {device_b}")
    |             ^^^^^^
    |

F821 Undefined name `logger`
  --> candidate/governance/identity/auth_backend/multi_user_sync.py:16:13
   |
14 |     def add_user(self, user_id):
15 |         if not user_id or not isinstance(user_id, str):
16 |             logger.error(f"Invalid user_id for add_user: {user_id}")
   |             ^^^^^^
17 |             self.audit_logger.log_event(f"Invalid user_id for add_user: {user_id}", constitutional_tag=True)
18 |             raise ValueError("Invalid user_id for add_user.")
   |

DTZ003 `datetime.datetime.utcnow()` used
  --> candidate/governance/identity/auth_backend/qr_entropy_generator.py:86:30
   |
84 |             base_qr_data = {
85 |                 "session_id": session_id,
86 |                 "timestamp": datetime.utcnow().isoformat(),
   |                              ^^^^^^^^^^^^^^^^^
87 |                 "expires_at": (datetime.utcnow() + timedelta(seconds=self.max_code_lifetime)).isoformat(),
88 |                 "challenge": secrets.token_urlsafe(32),
   |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
  --> candidate/governance/identity/auth_backend/qr_entropy_generator.py:87:32
   |
85 |                 "session_id": session_id,
86 |                 "timestamp": datetime.utcnow().isoformat(),
87 |                 "expires_at": (datetime.utcnow() + timedelta(seconds=self.max_code_lifetime)).isoformat(),
   |                                ^^^^^^^^^^^^^^^^^
88 |                 "challenge": secrets.token_urlsafe(32),
89 |             }
   |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/auth_backend/qr_entropy_generator.py:115:31
    |
113 |                 "entropy_hash": hashlib.sha256(entropy_data).hexdigest()[:16],
114 |                 "refresh_token": refresh_token,
115 |                 "created_at": datetime.utcnow().isoformat(),
    |                               ^^^^^^^^^^^^^^^^^
116 |                 "scan_count": 0,
117 |                 "max_scans": user_context.get("max_scans", 5) if user_context else 5,
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/auth_backend/qr_entropy_generator.py:223:16
    |
221 |             # Validate timing constraints
222 |             expires_at = datetime.fromisoformat(code_data["base_data"]["expires_at"])
223 |             if datetime.utcnow() > expires_at:
    |                ^^^^^^^^^^^^^^^^^
224 |                 self._invalidate_session(session_id, "expired")
225 |                 return False
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/auth_backend/qr_entropy_generator.py:257:38
    |
255 |             # Update scan count
256 |             code_data["scan_count"] += 1
257 |             code_data["last_scan"] = datetime.utcnow().isoformat()
    |                                      ^^^^^^^^^^^^^^^^^
258 |
259 |             # Performance tracking
    |
help: Use `datetime.datetime.now(tz=...)` instead

PERF401 Use `list.extend` to create a transformed list
   --> candidate/governance/identity/auth_backend/qr_entropy_generator.py:296:17
    |
294 |         for byte in entropy_data:
295 |             for i in range(8):
296 |                 bits.append((byte >> (7 - i)) & 1)
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
297 |         return bits
    |
help: Replace for loop with list.extend

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/auth_backend/qr_entropy_generator.py:345:38
    |
343 |     def _generate_refresh_token(self, session_id: str) -> str:
344 |         """Generate refresh token for dynamic QR updates"""
345 |         token_data = f"{session_id}:{datetime.utcnow().isoformat()}:{secrets.token_hex(16)}"
    |                                      ^^^^^^^^^^^^^^^^^
346 |         return hashlib.sha256(token_data.encode()).hexdigest()[:32]
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/auth_backend/qr_entropy_generator.py:371:28
    |
369 |                 try:
370 |                     timestamp = datetime.fromisoformat(qr_data["timestamp"])
371 |                     age = (datetime.utcnow() - timestamp).total_seconds()
    |                            ^^^^^^^^^^^^^^^^^
372 |                     if age > 300:  # 5 minute max age
373 |                         return False
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/auth_backend/qr_entropy_generator.py:393:24
    |
391 |     def _cleanup_expired_codes(self):
392 |         """Remove expired QR codes from active sessions"""
393 |         current_time = datetime.utcnow()
    |                        ^^^^^^^^^^^^^^^^^
394 |         expired_sessions = []
    |
help: Use `datetime.datetime.now(tz=...)` instead

PERF203 `try`-`except` within a loop incurs performance overhead
   --> candidate/governance/identity/auth_backend/qr_entropy_generator.py:401:13
    |
399 |                   if current_time > expires_at:
400 |                       expired_sessions.append(session_id)
401 | /             except (KeyError, ValueError):
402 | |                 expired_sessions.append(session_id)
    | |___________________________________________________^
403 |
404 |           for session_id in expired_sessions:
    |

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/auth_backend/qr_entropy_generator.py:412:63
    |
410 |             self.active_codes[session_id]["invalidated"] = True
411 |             self.active_codes[session_id]["invalidation_reason"] = reason
412 |             self.active_codes[session_id]["invalidated_at"] = datetime.utcnow().isoformat()
    |                                                               ^^^^^^^^^^^^^^^^^
413 |
414 |             # Remove expired sessions immediately, but keep scan limit exceeded for audit
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/auth_backend/qr_entropy_generator.py:448:26
    |
447 |         # Extend expiration time
448 |         new_expires_at = datetime.utcnow() + timedelta(seconds=self.max_code_lifetime)
    |                          ^^^^^^^^^^^^^^^^^
449 |         code_data["base_data"]["expires_at"] = new_expires_at.isoformat()
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/trust_scorer.py:168:31
    |
166 |                 "session_durations": [],
167 |                 "anomaly_count": 0,
168 |                 "first_seen": datetime.now(),
    |                               ^^^^^^^^^^^^^^
169 |                 "last_update": datetime.now(),
170 |             }
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/trust_scorer.py:169:32
    |
167 |                 "anomaly_count": 0,
168 |                 "first_seen": datetime.now(),
169 |                 "last_update": datetime.now(),
    |                                ^^^^^^^^^^^^^^
170 |             }
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/trust_scorer.py:173:35
    |
172 |         patterns = self.behavioral_patterns[user_id]
173 |         patterns["last_update"] = datetime.now()
    |                                   ^^^^^^^^^^^^^^
174 |
175 |         score = 25.0  # Base behavioral score
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/trust_scorer.py:176:24
    |
175 |         score = 25.0  # Base behavioral score
176 |         current_time = datetime.now()
    |                        ^^^^^^^^^^^^^^
177 |
178 |         # 1. Temporal pattern analysis
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/trust_scorer.py:410:24
    |
408 |         """
409 |         score = 15.0  # Base contextual score
410 |         current_time = datetime.now()
    |                        ^^^^^^^^^^^^^^
411 |
412 |         # Time-based risk assessment
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/trust_scorer.py:576:30
    |
574 |                 "thresholds": self.thresholds,
575 |                 "calculation_time_ms": round(calculation_time * 1000, 2),
576 |                 "timestamp": datetime.now().isoformat(),
    |                              ^^^^^^^^^^^^^^
577 |             }
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/trust_scorer.py:599:30
    |
597 |                 },
598 |                 "error": str(e),
599 |                 "timestamp": datetime.now().isoformat(),
    |                              ^^^^^^^^^^^^^^
600 |             }
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/trust_scorer.py:612:23
    |
610 |             expiry_hours: Hours until risk factor expires
611 |         """
612 |         expiry_time = datetime.now() + timedelta(hours=expiry_hours)
    |                       ^^^^^^^^^^^^^^
613 |
614 |         self.risk_factors[user_id] = {
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/trust_scorer.py:617:24
    |
615 |             "level": risk_level,
616 |             "reason": reason,
617 |             "created": datetime.now(),
    |                        ^^^^^^^^^^^^^^
618 |             "expires": expiry_time,
619 |         }
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/trust_scorer.py:654:24
    |
652 |     def cleanup_expired_data(self):
653 |         """Remove expired risk factors and old behavioral data."""
654 |         current_time = datetime.now()
    |                        ^^^^^^^^^^^^^^
655 |
656 |         # Clean expired risk factors
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

B007 Loop control variable `user_id` not used within loop body
   --> candidate/governance/identity/auth_backend/trust_scorer.py:667:13
    |
666 |         # Clean old behavioral patterns (keep only recent data)
667 |         for user_id, patterns in self.behavioral_patterns.items():
    |             ^^^^^^^
668 |             if current_time - patterns.get("last_update", current_time) > timedelta(days=30):
669 |                 # Keep only essential data for inactive users
    |
help: Rename unused `user_id` to `_user_id`

F821 Undefined name `logger`
  --> candidate/governance/identity/auth_backend/webrtc_peer_sync.py:25:13
   |
23 |             or not isinstance(signaling_server_url, str)
24 |         ):
25 |             logger.error(
   |             ^^^^^^
26 |                 f"Invalid peer_id or signaling_server_url for connect_to_peer: {peer_id}, {signaling_server_url}"
27 |             )
   |

F821 Undefined name `logger`
  --> candidate/governance/identity/auth_backend/webrtc_peer_sync.py:39:21
   |
37 |             if peer_public_key:
38 |                 if not self.crypto_engine.verify_peer_key(peer_public_key):
39 |                     logger.critical(f"Peer verification failed for {peer_id}")
   |                     ^^^^^^
40 |                     self.audit_logger.log_event(
41 |                         f"Peer verification failed for {peer_id}",
   |

F821 Undefined name `logger`
  --> candidate/governance/identity/auth_backend/webrtc_peer_sync.py:48:13
   |
46 |             return signaling_data
47 |         except Exception as e:
48 |             logger.error(f"connect_to_peer failed for {peer_id}: {e}")
   |             ^^^^^^
49 |             self.audit_logger.log_event(f"connect_to_peer failed for {peer_id}: {e}", constitutional_tag=True)
50 |             raise
   |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/websocket_server.py:126:46
    |
124 |         self.host = host
125 |         self.port = port
126 |         self.server_id = f"dashboard_ws_{int(datetime.now().timestamp())}"
    |                                              ^^^^^^^^^^^^^^
127 |         self.logger = logger.bind(server_id=self.server_id)
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/websocket_server.py:187:29
    |
185 |                 "server_id": self.server_id,
186 |                 "connected_clients": len(self.clients),
187 |                 "uptime": ((datetime.now() - self.start_time).total_seconds() if hasattr(self, "start_time") else 0),
    |                             ^^^^^^^^^^^^^^
188 |             }
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/websocket_server.py:202:27
    |
200 |     async def initialize(self):
201 |         """Initialize the WebSocket server and dashboard components."""
202 |         self.start_time = datetime.now()
    |                           ^^^^^^^^^^^^^^
203 |         self.logger.info("Initializing Dashboard WebSocket Server")
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/websocket_server.py:321:30
    |
319 |                     {requested_stream} if requested_stream != StreamType.ALL_STREAMS else set(StreamType)
320 |                 ),
321 |                 connected_at=datetime.now(),
    |                              ^^^^^^^^^^^^^^
322 |                 last_activity=datetime.now(),
323 |             )
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/websocket_server.py:322:31
    |
320 |                 ),
321 |                 connected_at=datetime.now(),
322 |                 last_activity=datetime.now(),
    |                               ^^^^^^^^^^^^^^
323 |             )
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/websocket_server.py:345:44
    |
343 |                     message = await websocket.receive_text()
344 |                     await self._handle_client_message(client, message)
345 |                     client.last_activity = datetime.now()
    |                                            ^^^^^^^^^^^^^^
346 |
347 |             except WebSocketDisconnect:
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/websocket_server.py:375:26
    |
373 |             "subscribed_streams": [stream.value for stream in client.subscribed_streams],
374 |             "server_capabilities": [stream.value for stream in StreamType],
375 |             "timestamp": datetime.now().isoformat(),
    |                          ^^^^^^^^^^^^^^
376 |         }
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

PERF203 `try`-`except` within a loop incurs performance overhead
   --> candidate/governance/identity/auth_backend/websocket_server.py:394:21
    |
392 |                           stream_type = StreamType(stream_type_str)
393 |                           client.subscribed_streams.add(stream_type)
394 | /                     except ValueError:
395 | |                         pass
    | |____________________________^
396 |
397 |                   response = {
    |

PERF203 `try`-`except` within a loop incurs performance overhead
   --> candidate/governance/identity/auth_backend/websocket_server.py:410:21
    |
408 |                           stream_type = StreamType(stream_type_str)
409 |                           client.subscribed_streams.discard(stream_type)
410 | /                     except ValueError:
411 | |                         pass
    | |____________________________^
412 |
413 |                   response = {
    |

ARG002 Unused method argument: `client`
   --> candidate/governance/identity/auth_backend/websocket_server.py:432:51
    |
430 |             )
431 |
432 |     async def _handle_dashboard_interaction(self, client: StreamClient, data: dict[str, Any]):
    |                                                   ^^^^^^
433 |         """Handle dashboard interaction events from clients."""
    |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/websocket_server.py:460:23
    |
458 |             stream_type=stream_type,
459 |             data=data,
460 |             timestamp=datetime.now(),
    |                       ^^^^^^^^^^^^^^
461 |             priority=priority,
462 |             target_clients=target_clients,
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

SIM102 Use a single `if` statement instead of nested `if` statements
   --> candidate/governance/identity/auth_backend/websocket_server.py:481:25
    |
479 |                       for client in self.clients.values():
480 |                           # Check if client is subscribed to this stream type
481 | /                         if (
482 | |                             message.stream_type in client.subscribed_streams
483 | |                             or StreamType.ALL_STREAMS in client.subscribed_streams
484 | |                         ):
485 | |                             # Check if message is targeted to specific clients
486 | |                             if message.target_clients is None or client.client_id in message.target_clients:
    | |____________________________________________________________________________________________________________^
487 |                                   target_clients.append(client)
    |
help: Combine `if` statements using `and`

PERF203 `try`-`except` within a loop incurs performance overhead
   --> candidate/governance/identity/auth_backend/websocket_server.py:504:21
    |
502 |                           await client.websocket.send_text(broadcast_json)
503 |                           self.performance_metrics["messages_sent"] += 1
504 | /                     except Exception as e:
505 | |                         self.logger.error(
506 | |                             "Failed to send message to client",
507 | |                             client_id=client.client_id,
508 | |                             error=str(e),
509 | |                         )
    | |_________________________^
510 |                           # Client will be cleaned up by cleanup task
    |

PERF203 `try`-`except` within a loop incurs performance overhead
   --> candidate/governance/identity/auth_backend/websocket_server.py:512:13
    |
510 |                           # Client will be cleaned up by cleanup task
511 |
512 | /             except Exception as e:
513 | |                 self.logger.error("Message broadcaster error", error=str(e))
514 | |                 await asyncio.sleep(1)
    | |______________________________________^
515 |
516 |       async def _data_collector(self, stream_type: StreamType):
    |

PERF203 `try`-`except` within a loop incurs performance overhead
   --> candidate/governance/identity/auth_backend/websocket_server.py:547:13
    |
545 |                   await asyncio.sleep(interval)
546 |
547 | /             except Exception as e:
548 | |                 self.logger.error(
549 | |                     f"Data collector error for {stream_type.value}",
550 | |                     error=str(e),
551 | |                 )
552 | |                 await asyncio.sleep(interval * 2)
    | |_________________________________________________^
553 |
554 |       async def _client_cleanup_task(self):
    |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/websocket_server.py:558:32
    |
556 |         while True:
557 |             try:
558 |                 current_time = datetime.now()
    |                                ^^^^^^^^^^^^^^
559 |                 cleanup_threshold = timedelta(minutes=5)
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

PERF203 `try`-`except` within a loop incurs performance overhead
   --> candidate/governance/identity/auth_backend/websocket_server.py:578:13
    |
576 |                   await asyncio.sleep(60)  # Run cleanup every minute
577 |
578 | /             except Exception as e:
579 | |                 self.logger.error("Client cleanup error", error=str(e))
580 | |                 await asyncio.sleep(60)
    | |_______________________________________^
581 |
582 |       async def _performance_monitor(self):
    |

PERF203 `try`-`except` within a loop incurs performance overhead
   --> candidate/governance/identity/auth_backend/websocket_server.py:598:13
    |
596 |                   await asyncio.sleep(300)  # Every 5 minutes
597 |
598 | /             except Exception as e:
599 | |                 self.logger.error("Performance monitoring error", error=str(e))
600 | |                 await asyncio.sleep(300)
    | |________________________________________^
601 |
602 |       # Stream handler methods
    |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/websocket_server.py:613:30
    |
611 |             return {
612 |                 "oracle_status": status,
613 |                 "timestamp": datetime.now().isoformat(),
    |                              ^^^^^^^^^^^^^^
614 |             }
615 |         except Exception as e:
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/websocket_server.py:628:30
    |
626 |             return {
627 |                 "ethics_status": status,
628 |                 "timestamp": datetime.now().isoformat(),
    |                              ^^^^^^^^^^^^^^
629 |             }
630 |         except Exception as e:
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/websocket_server.py:643:30
    |
641 |             return {
642 |                 "system_health": health_status,
643 |                 "timestamp": datetime.now().isoformat(),
    |                              ^^^^^^^^^^^^^^
644 |             }
645 |         except Exception as e:
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/websocket_server.py:677:30
    |
675 |                     for agent in self.colony_agents
676 |                 ],
677 |                 "timestamp": datetime.now().isoformat(),
    |                              ^^^^^^^^^^^^^^
678 |             }
679 |             return coordination_data
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/websocket_server.py:690:26
    |
688 |         return {
689 |             "server_metrics": self.performance_metrics.copy(),
690 |             "timestamp": datetime.now().isoformat(),
    |                          ^^^^^^^^^^^^^^
691 |         }
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_backend/websocket_server.py:705:30
    |
703 |                 "tab_predictions": tab_predictions,
704 |                 "morph_predictions": morph_predictions,
705 |                 "timestamp": datetime.now().isoformat(),
    |                              ^^^^^^^^^^^^^^
706 |             }
707 |         except Exception as e:
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

ARG002 Unused method argument: `user_id`
  --> candidate/governance/identity/auth_integrations/qrg_bridge.py:91:15
   |
90 |     async def generate_auth_qr(
91 |         self, user_id: str, auth_data: dict[str, Any], mode: QRAuthMode = None
   |               ^^^^^^^
92 |     ) -> dict[str, Any]:
93 |         """Generate authentication QR code with specified mode"""
   |

ARG002 Unused method argument: `auth_data`
  --> candidate/governance/identity/auth_integrations/qrg_bridge.py:91:29
   |
90 |     async def generate_auth_qr(
91 |         self, user_id: str, auth_data: dict[str, Any], mode: QRAuthMode = None
   |                             ^^^^^^^^^
92 |     ) -> dict[str, Any]:
93 |         """Generate authentication QR code with specified mode"""
   |

ARG002 Unused method argument: `qr_data`
   --> candidate/governance/identity/auth_integrations/qrg_bridge.py:105:38
    |
103 |         }
104 |
105 |     async def validate_auth_qr(self, qr_data: str, user_context: dict[str, Any]) -> dict[str, Any]:
    |                                      ^^^^^^^
106 |         """Validate authentication QR code"""
107 |         # TODO: Implement when QRG is integrated
    |

ARG002 Unused method argument: `user_context`
   --> candidate/governance/identity/auth_integrations/qrg_bridge.py:105:52
    |
103 |         }
104 |
105 |     async def validate_auth_qr(self, qr_data: str, user_context: dict[str, Any]) -> dict[str, Any]:
    |                                                    ^^^^^^^^^^^^
106 |         """Validate authentication QR code"""
107 |         # TODO: Implement when QRG is integrated
    |

ARG002 Unused method argument: `consciousness_data`
   --> candidate/governance/identity/auth_integrations/qrg_bridge.py:115:64
    |
113 |         }
114 |
115 |     async def create_animated_auth_flow(self, session_id: str, consciousness_data: dict[str, Any]) -> dict[str, Any]:
    |                                                                ^^^^^^^^^^^^^^^^^^
116 |         """Create animated QR authentication flow"""
117 |         # TODO: Implement when QRG animation engine is integrated
    |

ARG002 Unused method argument: `hidden_auth_data`
   --> candidate/governance/identity/auth_integrations/qrg_bridge.py:126:29
    |
125 |     async def embed_steganographic_auth(
126 |         self, base_qr: str, hidden_auth_data: dict[str, Any]
    |                             ^^^^^^^^^^^^^^^^
127 |     ) -> tuple[str, dict[str, Any]]:
128 |         """Embed hidden authentication data in QR code"""
    |

ARG002 Unused method argument: `user_id`
  --> candidate/governance/identity/auth_integrations/wallet_bridge.py:78:46
   |
76 |             }
77 |
78 |     async def authenticate_with_wallet(self, user_id: str, symbolic_credentials: dict[str, Any]) -> dict[str, Any]:
   |                                              ^^^^^^^
79 |         """Authenticate using WALLET symbolic vault"""
80 |         # TODO: Implement when WALLET is integrated
   |

ARG002 Unused method argument: `symbolic_credentials`
  --> candidate/governance/identity/auth_integrations/wallet_bridge.py:78:60
   |
76 |             }
77 |
78 |     async def authenticate_with_wallet(self, user_id: str, symbolic_credentials: dict[str, Any]) -> dict[str, Any]:
   |                                                            ^^^^^^^^^^^^^^^^^^^^
79 |         """Authenticate using WALLET symbolic vault"""
80 |         # TODO: Implement when WALLET is integrated
   |

ARG002 Unused method argument: `user_id`
  --> candidate/governance/identity/auth_integrations/wallet_bridge.py:87:40
   |
85 |         }
86 |
87 |     async def store_auth_symbols(self, user_id: str, auth_symbols: list[str]) -> dict[str, Any]:
   |                                        ^^^^^^^
88 |         """Store authentication symbols in WALLET symbolic vault"""
89 |         # TODO: Implement when WALLET is integrated
   |

ARG002 Unused method argument: `auth_symbols`
  --> candidate/governance/identity/auth_integrations/wallet_bridge.py:87:54
   |
85 |         }
86 |
87 |     async def store_auth_symbols(self, user_id: str, auth_symbols: list[str]) -> dict[str, Any]:
   |                                                      ^^^^^^^^^^^^
88 |         """Store authentication symbols in WALLET symbolic vault"""
89 |         # TODO: Implement when WALLET is integrated
   |

ARG002 Unused method argument: `identity_data`
  --> candidate/governance/identity/auth_integrations/wallet_bridge.py:96:40
   |
94 |         }
95 |
96 |     async def verify_qi_identity(self, identity_data: dict[str, Any]) -> dict[str, Any]:
   |                                        ^^^^^^^^^^^^^
97 |         """Verify identity using QI-enhanced algorithms"""
98 |         # TODO: Implement when WALLET QI core is integrated
   |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_utils/cognitive_load_estimator.py:271:23
    |
269 |             confidence=confidence,
270 |             recommendations=recommendations,
271 |             timestamp=datetime.now(),
    |                       ^^^^^^^^^^^^^^
272 |         )
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

ARG002 Unused method argument: `context`
   --> candidate/governance/identity/auth_utils/cognitive_load_estimator.py:533:9
    |
531 |         load_level: CognitiveLoadLevel,
532 |         indicators: CognitiveIndicators,
533 |         context: Optional[dict[str, Any]],
    |         ^^^^^^^
534 |     ) -> list[str]:
535 |         """Generate UI adaptation recommendations based on cognitive load."""
    |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_utils/cultural_safety_checker.py:525:23
    |
523 |             safety_score=safety_score,
524 |             recommendations=recommendations,
525 |             timestamp=datetime.now(),
    |                       ^^^^^^^^^^^^^^
526 |         )
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

ARG002 Unused method argument: `emoji`
   --> candidate/governance/identity/auth_utils/cultural_safety_checker.py:600:9
    |
598 |     def _should_approve_context_dependent(
599 |         self,
600 |         emoji: str,
    |         ^^^^^
601 |         contexts: list[CulturalContext],
602 |         sensitivity_level: SensitivityLevel,
    |

RUF003 Comment contains ambiguous `Ã—` (MULTIPLICATION SIGN). Did you mean `x` (LATIN SMALL LETTER X)?
  --> candidate/governance/identity/auth_utils/grid_size_calculator.py:25:27
   |
23 |     """Grid layout patterns"""
24 |
25 |     SQUARE = "square"  # nÃ—n square grid
   |                           ^
26 |     RECTANGLE = "rectangle"  # mÃ—n rectangular grid
27 |     CIRCULAR = "circular"  # Circular arrangement
   |

RUF003 Comment contains ambiguous `Ã—` (MULTIPLICATION SIGN). Did you mean `x` (LATIN SMALL LETTER X)?
  --> candidate/governance/identity/auth_utils/grid_size_calculator.py:26:33
   |
25 |     SQUARE = "square"  # nÃ—n square grid
26 |     RECTANGLE = "rectangle"  # mÃ—n rectangular grid
   |                                 ^
27 |     CIRCULAR = "circular"  # Circular arrangement
28 |     ADAPTIVE = "adaptive"  # Adaptive based on content
   |

RUF046 Value being cast to `int` is already an integer
   --> candidate/governance/identity/auth_utils/grid_size_calculator.py:209:32
    |
207 |             else:
208 |                 # Round up to next perfect square or reasonable rectangle
209 |                 return min(16, int(math.ceil(sqrt_count)) ** 2)
    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^
210 |
211 |     def _apply_cognitive_load_adjustment(self, base_size: int, load_level: str) -> int:
    |
help: Remove unnecessary `int` call

RUF001 String contains ambiguous `Ã—` (MULTIPLICATION SIGN). Did you mean `x` (LATIN SMALL LETTER X)?
   --> candidate/governance/identity/auth_utils/grid_size_calculator.py:319:51
    |
317 |             cells_per_row, cells_per_column = self._calculate_rectangular_layout(grid_size, screen)
318 |
319 |         reasoning.append(f"Layout: {cells_per_row}Ã—{cells_per_column}")
    |                                                   ^
320 |
321 |         # Calculate available space
    |

PERF401 Use a list comprehension to create a transformed list
   --> candidate/governance/identity/auth_utils/grid_size_calculator.py:400:17
    |
398 |         for i in range(1, int(math.sqrt(grid_size)) + 1):
399 |             if grid_size % i == 0:
400 |                 factors.append((i, grid_size // i))
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
401 |
402 |         if not factors:
    |
help: Replace for loop with list comprehension

ARG002 Unused method argument: `spacing`
   --> candidate/governance/identity/auth_utils/grid_size_calculator.py:451:9
    |
449 |         self,
450 |         cell_size: float,
451 |         spacing: float,
    |         ^^^^^^^
452 |         total_width: float,
453 |         total_height: float,
    |

F821 Undefined name `logger`
  --> candidate/governance/identity/auth_utils/replay_protection.py:52:13
   |
50 |             if old_device_id and old_device_id in self.device_nonces:
51 |                 self.device_nonces[old_device_id].discard(old_nonce)
52 |             logger.info(f"Nonce expired: {old_nonce} (device: {old_device_id}, time: {old_time})")
   |             ^^^^^^
   |

F706 `return` statement outside of a function/method
  --> candidate/governance/identity/auth_utils/shared_logging.py:12:1
   |
11 | """Get a logger with a unified format and level."""
12 | return logging.getLogger(name)
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |

F821 Undefined name `name`
  --> candidate/governance/identity/auth_utils/shared_logging.py:12:26
   |
11 | """Get a logger with a unified format and level."""
12 | return logging.getLogger(name)
   |                          ^^^^
   |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_web/adaptive_ui_controller.py:143:23
    |
141 |             stress_indicators=stress_indicators,
142 |             fatigue_level=fatigue_level,
143 |             timestamp=datetime.now(),
    |                       ^^^^^^^^^^^^^^
144 |         )
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_web/adaptive_ui_controller.py:177:29
    |
176 |         # Session duration factor
177 |         session_duration = (datetime.now() - self.cognitive_history[0].timestamp).total_seconds() / 3600.0  # hours
    |                             ^^^^^^^^^^^^^^
178 |         # Fatigue increases over 2 hours
179 |         duration_fatigue = min(1.0, session_duration / 2.0)
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

PERF203 `try`-`except` within a loop incurs performance overhead
   --> candidate/governance/identity/auth_web/adaptive_ui_controller.py:276:17
    |
274 |                   try:
275 |                       callback(new_config, adaptation_reasons)
276 | /                 except Exception as e:
277 | |                     ui_logger.error(f"Error in adaptation callback: {e}")
    | |_________________________________________________________________________^
278 |           else:
279 |               ui_logger.warning(f"UI adaptation blocked by constitutional violations: {violations}")
    |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_web/websocket_server.py:126:46
    |
124 |         self.host = host
125 |         self.port = port
126 |         self.server_id = f"dashboard_ws_{int(datetime.now().timestamp())}"
    |                                              ^^^^^^^^^^^^^^
127 |         self.logger = logger.bind(server_id=self.server_id)
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_web/websocket_server.py:187:29
    |
185 |                 "server_id": self.server_id,
186 |                 "connected_clients": len(self.clients),
187 |                 "uptime": ((datetime.now() - self.start_time).total_seconds() if hasattr(self, "start_time") else 0),
    |                             ^^^^^^^^^^^^^^
188 |             }
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_web/websocket_server.py:202:27
    |
200 |     async def initialize(self):
201 |         """Initialize the WebSocket server and dashboard components."""
202 |         self.start_time = datetime.now()
    |                           ^^^^^^^^^^^^^^
203 |         self.logger.info("Initializing Dashboard WebSocket Server")
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_web/websocket_server.py:321:30
    |
319 |                     {requested_stream} if requested_stream != StreamType.ALL_STREAMS else set(StreamType)
320 |                 ),
321 |                 connected_at=datetime.now(),
    |                              ^^^^^^^^^^^^^^
322 |                 last_activity=datetime.now(),
323 |             )
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_web/websocket_server.py:322:31
    |
320 |                 ),
321 |                 connected_at=datetime.now(),
322 |                 last_activity=datetime.now(),
    |                               ^^^^^^^^^^^^^^
323 |             )
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_web/websocket_server.py:345:44
    |
343 |                     message = await websocket.receive_text()
344 |                     await self._handle_client_message(client, message)
345 |                     client.last_activity = datetime.now()
    |                                            ^^^^^^^^^^^^^^
346 |
347 |             except WebSocketDisconnect:
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_web/websocket_server.py:375:26
    |
373 |             "subscribed_streams": [stream.value for stream in client.subscribed_streams],
374 |             "server_capabilities": [stream.value for stream in StreamType],
375 |             "timestamp": datetime.now().isoformat(),
    |                          ^^^^^^^^^^^^^^
376 |         }
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

PERF203 `try`-`except` within a loop incurs performance overhead
   --> candidate/governance/identity/auth_web/websocket_server.py:394:21
    |
392 |                           stream_type = StreamType(stream_type_str)
393 |                           client.subscribed_streams.add(stream_type)
394 | /                     except ValueError:
395 | |                         pass
    | |____________________________^
396 |
397 |                   response = {
    |

PERF203 `try`-`except` within a loop incurs performance overhead
   --> candidate/governance/identity/auth_web/websocket_server.py:410:21
    |
408 |                           stream_type = StreamType(stream_type_str)
409 |                           client.subscribed_streams.discard(stream_type)
410 | /                     except ValueError:
411 | |                         pass
    | |____________________________^
412 |
413 |                   response = {
    |

ARG002 Unused method argument: `client`
   --> candidate/governance/identity/auth_web/websocket_server.py:432:51
    |
430 |             )
431 |
432 |     async def _handle_dashboard_interaction(self, client: StreamClient, data: dict[str, Any]):
    |                                                   ^^^^^^
433 |         """Handle dashboard interaction events from clients."""
    |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_web/websocket_server.py:460:23
    |
458 |             stream_type=stream_type,
459 |             data=data,
460 |             timestamp=datetime.now(),
    |                       ^^^^^^^^^^^^^^
461 |             priority=priority,
462 |             target_clients=target_clients,
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

SIM102 Use a single `if` statement instead of nested `if` statements
   --> candidate/governance/identity/auth_web/websocket_server.py:481:25
    |
479 |                       for client in self.clients.values():
480 |                           # Check if client is subscribed to this stream type
481 | /                         if (
482 | |                             message.stream_type in client.subscribed_streams
483 | |                             or StreamType.ALL_STREAMS in client.subscribed_streams
484 | |                         ):
485 | |                             # Check if message is targeted to specific clients
486 | |                             if message.target_clients is None or client.client_id in message.target_clients:
    | |____________________________________________________________________________________________________________^
487 |                                   target_clients.append(client)
    |
help: Combine `if` statements using `and`

PERF203 `try`-`except` within a loop incurs performance overhead
   --> candidate/governance/identity/auth_web/websocket_server.py:504:21
    |
502 |                           await client.websocket.send_text(broadcast_json)
503 |                           self.performance_metrics["messages_sent"] += 1
504 | /                     except Exception as e:
505 | |                         self.logger.error(
506 | |                             "Failed to send message to client",
507 | |                             client_id=client.client_id,
508 | |                             error=str(e),
509 | |                         )
    | |_________________________^
510 |                           # Client will be cleaned up by cleanup task
    |

PERF203 `try`-`except` within a loop incurs performance overhead
   --> candidate/governance/identity/auth_web/websocket_server.py:512:13
    |
510 |                           # Client will be cleaned up by cleanup task
511 |
512 | /             except Exception as e:
513 | |                 self.logger.error("Message broadcaster error", error=str(e))
514 | |                 await asyncio.sleep(1)
    | |______________________________________^
515 |
516 |       async def _data_collector(self, stream_type: StreamType):
    |

PERF203 `try`-`except` within a loop incurs performance overhead
   --> candidate/governance/identity/auth_web/websocket_server.py:547:13
    |
545 |                   await asyncio.sleep(interval)
546 |
547 | /             except Exception as e:
548 | |                 self.logger.error(
549 | |                     f"Data collector error for {stream_type.value}",
550 | |                     error=str(e),
551 | |                 )
552 | |                 await asyncio.sleep(interval * 2)
    | |_________________________________________________^
553 |
554 |       async def _client_cleanup_task(self):
    |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_web/websocket_server.py:558:32
    |
556 |         while True:
557 |             try:
558 |                 current_time = datetime.now()
    |                                ^^^^^^^^^^^^^^
559 |                 cleanup_threshold = timedelta(minutes=5)
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

PERF203 `try`-`except` within a loop incurs performance overhead
   --> candidate/governance/identity/auth_web/websocket_server.py:578:13
    |
576 |                   await asyncio.sleep(60)  # Run cleanup every minute
577 |
578 | /             except Exception as e:
579 | |                 self.logger.error("Client cleanup error", error=str(e))
580 | |                 await asyncio.sleep(60)
    | |_______________________________________^
581 |
582 |       async def _performance_monitor(self):
    |

PERF203 `try`-`except` within a loop incurs performance overhead
   --> candidate/governance/identity/auth_web/websocket_server.py:598:13
    |
596 |                   await asyncio.sleep(300)  # Every 5 minutes
597 |
598 | /             except Exception as e:
599 | |                 self.logger.error("Performance monitoring error", error=str(e))
600 | |                 await asyncio.sleep(300)
    | |________________________________________^
601 |
602 |       # Stream handler methods
    |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_web/websocket_server.py:613:30
    |
611 |             return {
612 |                 "oracle_status": status,
613 |                 "timestamp": datetime.now().isoformat(),
    |                              ^^^^^^^^^^^^^^
614 |             }
615 |         except Exception as e:
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_web/websocket_server.py:628:30
    |
626 |             return {
627 |                 "ethics_status": status,
628 |                 "timestamp": datetime.now().isoformat(),
    |                              ^^^^^^^^^^^^^^
629 |             }
630 |         except Exception as e:
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_web/websocket_server.py:643:30
    |
641 |             return {
642 |                 "system_health": health_status,
643 |                 "timestamp": datetime.now().isoformat(),
    |                              ^^^^^^^^^^^^^^
644 |             }
645 |         except Exception as e:
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_web/websocket_server.py:677:30
    |
675 |                     for agent in self.colony_agents
676 |                 ],
677 |                 "timestamp": datetime.now().isoformat(),
    |                              ^^^^^^^^^^^^^^
678 |             }
679 |             return coordination_data
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_web/websocket_server.py:690:26
    |
688 |         return {
689 |             "server_metrics": self.performance_metrics.copy(),
690 |             "timestamp": datetime.now().isoformat(),
    |                          ^^^^^^^^^^^^^^
691 |         }
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/auth_web/websocket_server.py:705:30
    |
703 |                 "tab_predictions": tab_predictions,
704 |                 "morph_predictions": morph_predictions,
705 |                 "timestamp": datetime.now().isoformat(),
    |                              ^^^^^^^^^^^^^^
706 |             }
707 |         except Exception as e:
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/biometric/biometric_fusion_engine.py:251:37
    |
249 |             session_vector=session_vector,
250 |             metadata={
251 |                 "fusion_timestamp": datetime.utcnow().isoformat(),
    |                                     ^^^^^^^^^^^^^^^^^
252 |                 "sample_count": len(samples),
253 |                 "consciousness_state": consciousness_state,
    |
help: Use `datetime.datetime.now(tz=...)` instead

PERF401 Use a list comprehension to create a transformed list
   --> candidate/governance/identity/biometric/biometric_fusion_engine.py:629:13
    |
628 |         for sample in samples:
629 |             vector_components.append(sample.compute_hash()[:16])
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
630 |
631 |         vector_components.append(consciousness_state)
    |
help: Replace for loop with list comprehension

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/biometric/biometric_fusion_engine.py:632:34
    |
631 |         vector_components.append(consciousness_state)
632 |         vector_components.append(datetime.utcnow().isoformat())
    |                                  ^^^^^^^^^^^^^^^^^
633 |
634 |         vector_string = "|".join(vector_components)
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/biometric/biometric_fusion_engine.py:639:64
    |
637 |     def _generate_fallback_session_vector(self, fallback_type: str, consciousness_state: str) -> str:
638 |         """Generate session vector for fallback authentication"""
639 |         vector_data = f"{fallback_type}|{consciousness_state}|{datetime.utcnow().isoformat()}"
    |                                                                ^^^^^^^^^^^^^^^^^
640 |         return hashlib.blake2b(vector_data.encode(), digest_size=32).hexdigest()
    |
help: Use `datetime.datetime.now(tz=...)` instead

SIM102 Use a single `if` statement instead of nested `if` statements
   --> candidate/governance/identity/biometric/biometric_fusion_engine.py:671:9
    |
670 |           # Cultural adaptation
671 | /         if cultural_context.get("cultural_type") == "high_context":
672 | |             # High-context cultures may use meaningful phrases
673 | |             if len(keyword.split()) > 1:
    | |________________________________________^
674 |                   strength += 0.15
    |
help: Combine `if` statements using `and`

SIM102 Use a single `if` statement instead of nested `if` statements
   --> candidate/governance/identity/biometric/biometric_fusion_engine.py:715:9
    |
714 |           # Cultural dream interpretation bonus
715 | /         if cultural_context.get("region") == "asia":
716 | |             if any(s in ["dragon", "lotus", "mountain"] for s in symbols):
    | |__________________________________________________________________________^
717 |                   base_score *= 1.2
    |
help: Combine `if` statements using `and`

SIM102 Use a single `if` statement instead of nested `if` statements
   --> candidate/governance/identity/biometric/biometric_fusion_engine.py:733:9
    |
731 |               if dream_recall.get("symbolic_depth", 0) > 0.7:
732 |                   cultural_factor = 1.3
733 | /         elif cultural_type == "individual":
734 | |             # Individual cultures focus on personal dream meaning
735 | |             if dream_recall.get("personal_significance", 0) > 0.6:
    | |__________________________________________________________________^
736 |                   cultural_factor = 1.2
    |
help: Combine `if` statements using `and`

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/biometric/iris_lock_finalizer.py:199:26
    |
197 |             "quality_assessment": quality_level.value,
198 |             "symbolic_warnings": symbolic_warnings,
199 |             "timestamp": datetime.utcnow().isoformat(),
    |                          ^^^^^^^^^^^^^^^^^
200 |         }
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/biometric/iris_lock_finalizer.py:334:24
    |
333 |         # Time-based warning (late night/early morning)
334 |         current_hour = datetime.now().hour
    |                        ^^^^^^^^^^^^^^
335 |         if current_hour < 6 or current_hour > 22:
336 |             warnings.append("ðŸŒ™ Off-peak scan - additional verification may be required")
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/biometric/iris_lock_finalizer.py:386:26
    |
384 |         audit_record = {
385 |             "audit_id": audit_id,
386 |             "timestamp": datetime.utcnow().isoformat(),
    |                          ^^^^^^^^^^^^^^^^^
387 |             "success": result.success,
388 |             "match_score": result.match_score,
    |
help: Use `datetime.datetime.now(tz=...)` instead

ARG002 Unused method argument: `user_id`
   --> candidate/governance/identity/biometric/iris_lock_finalizer.py:405:40
    |
403 |         return hashlib.blake2b(iris_input, digest_size=64).hexdigest()
404 |
405 |     async def simulate_iris_scan(self, user_id: str, base64_iris_data: str) -> IrisScanData:
    |                                        ^^^^^^^
406 |         """Simulate iris scanning process"""
407 |         # Decode base64 (in production, this would be actual biometric data)
    |

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/biometric/iris_lock_finalizer.py:432:28
    |
430 |             quality_score=quality_score,
431 |             eye_openness=eye_openness,
432 |             scan_timestamp=datetime.utcnow(),
    |                            ^^^^^^^^^^^^^^^^^
433 |             consciousness_state="focused",  # Default state
434 |             emotional_markers=emotional_markers,
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/consent/consent_chain_validator.py:108:16
    |
106 |         if not self.expiry:
107 |             return False
108 |         return datetime.utcnow() > self.expiry
    |                ^^^^^^^^^^^^^^^^^
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/consent/consent_chain_validator.py:419:28
    |
417 |                 chain_id=f"CHAIN_{secrets.token_hex(8)}",
418 |                 user_id=user_id,
419 |                 created_at=datetime.utcnow(),
    |                            ^^^^^^^^^^^^^^^^^
420 |             )
421 |             self.consent_chains[user_id] = chain
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/consent/consent_chain_validator.py:455:20
    |
453 |         try:
454 |             expiry = datetime.fromisoformat(expiry_str)
455 |             return datetime.utcnow() > expiry
    |                    ^^^^^^^^^^^^^^^^^
456 |         except BaseException:
457 |             return False
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/consent/consent_chain_validator.py:477:18
    |
475 |             expiry_hours = 24 * 30  # 30 days for biometric consent
476 |
477 |         expiry = datetime.utcnow() + timedelta(hours=expiry_hours)
    |                  ^^^^^^^^^^^^^^^^^
478 |
479 |         # Create consent data
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/consent/consent_chain_validator.py:486:27
    |
484 |             "consciousness_coherence": 0.85,  # Would be calculated
485 |             "cultural_alignment": cultural_context.get("cultural_type", "unknown"),
486 |             "granted_at": datetime.utcnow().isoformat(),
    |                           ^^^^^^^^^^^^^^^^^
487 |         }
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/consent/consent_chain_validator.py:498:23
    |
496 |             consent_type=consent_type,
497 |             user_id=user_id,
498 |             timestamp=datetime.utcnow(),
    |                       ^^^^^^^^^^^^^^^^^
499 |             expiry=expiry,
500 |             consent_data=consent_data,
    |
help: Use `datetime.datetime.now(tz=...)` instead

PERF401 Use a list comprehension to create a transformed list
   --> candidate/governance/identity/consent/consent_chain_validator.py:525:17
    |
523 |         for principle in relevant_principles:
524 |             if not self._check_principle_compliance(node, principle):
525 |                 violations.append(principle)
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
526 |
527 |         # Calculate compliance score
    |
help: Replace for loop with list comprehension

ARG005 Unused lambda argument: `n`
   --> candidate/governance/identity/consent/consent_chain_validator.py:550:62
    |
548 |         }
549 |
550 |         check_func = compliance_checks.get(principle, lambda n: True)
    |                                                              ^
551 |         return check_func(node)
    |

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/consent/consent_chain_validator.py:673:26
    |
671 |         """Store audit record of consent validation"""
672 |         audit_record = {
673 |             "timestamp": datetime.utcnow().isoformat(),
    |                          ^^^^^^^^^^^^^^^^^
674 |             "decision_id": decision.decision_id,
675 |             "valid": decision.valid,
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/consent/consent_chain_validator.py:697:31
    |
695 |             if node.consent_type in consent_types and not node.is_expired():
696 |                 # Mark as expired
697 |                 node.expiry = datetime.utcnow()
    |                               ^^^^^^^^^^^^^^^^^
698 |                 revoked_count += 1
    |
help: Use `datetime.datetime.now(tz=...)` instead

PERF401 Use a list comprehension to create a transformed list
   --> candidate/governance/identity/consent/consent_chain_validator.py:717:13
    |
715 |           history = []
716 |           for node in chain.nodes:
717 | /             history.append(
718 | |                 {
719 | |                     "node_id": node.node_id,
720 | |                     "consent_type": node.consent_type.value,
721 | |                     "granted_at": node.timestamp.isoformat(),
722 | |                     "expires_at": node.expiry.isoformat() if node.expiry else None,
723 | |                     "is_expired": node.is_expired(),
724 | |                     "consciousness_state": node.consciousness_state,
725 | |                     "signature": (node.signature[:16] + "..." if node.signature else None),
726 | |                 }
727 | |             )
    | |_____________^
728 |
729 |           return {
    |
help: Replace for loop with list comprehension

E501 Line too long (139 > 120)
   --> candidate/governance/identity/consent/consent_receipt_generator.py:221:121
    |
219 | â€¦
220 | â€¦
221 | â€¦middle" font-family="monospace" font-size="8" fill="#00ff00" opacity="0.7">
    |                                                          ^^^^^^^^^^^^^^^^^^^
222 | â€¦
223 | â€¦
    |

E501 Line too long (124 > 120)
   --> candidate/governance/identity/consent/consent_receipt_generator.py:226:121
    |
224 |         <!-- Placeholder for actual QR code -->
225 |         <rect x="10" y="10" width="{qr_size - 20}" height="{qr_size - 20}" fill="#333" opacity="0.5"/>
226 |         <text x="{qr_size / 2}" y="{qr_size / 2}" text-anchor="middle" font-family="monospace" font-size="8" fill="#00ff00">
    |                                                                                                                         ^^^^
227 |             [QR Code]
228 |         </text>
    |

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/consent/consent_receipt_generator.py:243:21
    |
242 |         # Aggregate data
243 |         timestamp = datetime.utcnow()
    |                     ^^^^^^^^^^^^^^^^^
244 |         glyph_trail = []
245 |         tiers = set()
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/consent/consent_receipt_generator.py:318:19
    |
316 |         user_id="t5_user_000",
317 |         consent_hash=f"trusthelix:{hashlib.sha256(b'demo_consent').hexdigest()[:24]}",
318 |         timestamp=datetime.utcnow(),
    |                   ^^^^^^^^^^^^^^^^^
319 |         tier="T5",
320 |         consciousness_state="flow_state",
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/consent/consent_receipt_generator.py:336:26
    |
334 |             "consciousness_state": "meditative",
335 |             "glyphs": ["ðŸ§˜", "ðŸŒ¸", "â˜®ï¸"],
336 |             "timestamp": datetime.utcnow().isoformat(),
    |                          ^^^^^^^^^^^^^^^^^
337 |         },
338 |         {
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/consent/consent_receipt_generator.py:342:26
    |
340 |             "consciousness_state": "analytical",
341 |             "glyphs": ["ðŸ“Š", "ðŸ”¬", "ðŸ§®"],
342 |             "timestamp": datetime.utcnow().isoformat(),
    |                          ^^^^^^^^^^^^^^^^^
343 |         },
344 |         {
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/consent/consent_receipt_generator.py:349:26
    |
347 |             "glyphs": ["ðŸŒŠ", "ðŸ„", "ðŸš€"],
348 |             "cultural_region": "americas",
349 |             "timestamp": datetime.utcnow().isoformat(),
    |                          ^^^^^^^^^^^^^^^^^
350 |         },
351 |     ]
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
  --> candidate/governance/identity/constellation_glyph_integration.py:81:56
   |
79 |         self.payload = message_data.get("payload", {})
80 |         self.constellation_context = message_data.get("constellation_context", {})
81 |         self.timestamp = message_data.get("timestamp", datetime.utcnow().isoformat())
   |                                                        ^^^^^^^^^^^^^^^^^
82 |         self.priority = message_data.get("priority", "normal")  # low, normal, high, critical
83 |         self.ttl_seconds = message_data.get("ttl_seconds", 3600)
   |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/constellation_glyph_integration.py:112:20
    |
110 |             message_time = datetime.fromisoformat(self.timestamp.replace("Z", "+00:00"))
111 |             expiry_time = message_time + timedelta(seconds=self.ttl_seconds)
112 |             return datetime.utcnow() > expiry_time.replace(tzinfo=None)
    |                    ^^^^^^^^^^^^^^^^^
113 |         except Exception:
114 |             return True  # Consider expired if we can't parse timestamp
    |
help: Use `datetime.datetime.now(tz=...)` instead

ARG002 Unused method argument: `context`
   --> candidate/governance/identity/constellation_glyph_integration.py:363:65
    |
362 |     def _validate_performance(
363 |         self, component_instance: Any, targets: dict[str, Any], context: dict[str, Any]
    |                                                                 ^^^^^^^
364 |     ) -> dict[str, Any]:
365 |         """Validate performance targets"""
    |

ARG002 Unused method argument: `context`
   --> candidate/governance/identity/constellation_glyph_integration.py:398:65
    |
397 |     def _validate_security_requirements(
398 |         self, component_instance: Any, requirements: list[str], context: dict[str, Any]
    |                                                                 ^^^^^^^
399 |     ) -> dict[str, Any]:
400 |         """Validate security requirements"""
    |

ARG002 Unused method argument: `context`
   --> candidate/governance/identity/constellation_glyph_integration.py:432:73
    |
430 |         return security_compliance
431 |
432 |     def _validate_consciousness_specific(self, component_instance: Any, context: dict[str, Any]) -> dict[str, Any]:
    |                                                                         ^^^^^^^
433 |         """ðŸ§  Validate consciousness-specific requirements"""
434 |         validation = {
    |

ARG002 Unused method argument: `context`
   --> candidate/governance/identity/constellation_glyph_integration.py:470:68
    |
468 |     pass
469 |
470 |     def _validate_guardian_specific(self, component_instance: Any, context: dict[str, Any]) -> dict[str, Any]:
    |                                                                    ^^^^^^^
471 |         """ðŸ›¡ï¸ Validate guardian-specific requirements"""
472 |         validation = {
    |

ARG002 Unused method argument: `context`
   --> candidate/governance/identity/constellation_glyph_integration.py:499:68
    |
497 |         return validation
498 |
499 |     def _validate_identity_specific(self, component_instance: Any, context: dict[str, Any]) -> dict[str, Any]:
    |                                                                    ^^^^^^^
500 |         """âš›ï¸ Validate identity-specific requirements"""
501 |         validation = {
    |

B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   --> candidate/governance/identity/constellation_glyph_integration.py:604:13
    |
602 |         except Exception as e:
603 |             self.message_stats["processing_errors"] += 1
604 |             raise Exception(f"Failed to publish GLYPH message: {e!s}")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
605 |
606 |     def subscribe_to_glyph_type(self, glyph_type: GLYPHType, handler_function: callable, module_name: str) -> bool:
    |

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/constellation_glyph_integration.py:616:38
    |
614 |                     "handler": handler_function,
615 |                     "module": module_name,
616 |                     "subscribed_at": datetime.utcnow().isoformat(),
    |                                      ^^^^^^^^^^^^^^^^^
617 |                 }
618 |             )
    |
help: Use `datetime.datetime.now(tz=...)` instead

PERF203 `try`-`except` within a loop incurs performance overhead
   --> candidate/governance/identity/constellation_glyph_integration.py:658:17
    |
656 |                           processing_results["skipped_count"] += 1
657 |
658 | /                 except Exception as e:
659 | |                     processing_results["error_count"] += 1
660 | |                     print(f"Error processing message {message.message_id}: {e}")
    | |________________________________________________________________________________^
661 |
662 |               # Remove processed messages from queue
    |

PERF203 `try`-`except` within a loop incurs performance overhead
   --> candidate/governance/identity/constellation_glyph_integration.py:698:17
    |
696 |                           subscriber["handler"](message)
697 |
698 | /                 except Exception as e:
699 | |                     print(f"Error delivering message to {subscriber['module']}: {e}")
    | |_____________________________________________________________________________________^
700 |
701 |               return True
    |

ARG001 Unused function argument: `config`
   --> candidate/governance/identity/constellation_glyph_integration.py:849:5
    |
847 | # Factory function to create Trinity-compliant identity components
848 | def create_trinity_compliant_identity_system(
849 |     config: Optional[dict] = None,
    |     ^^^^^^
850 | ) -> tuple[Any, TrinityValidator, GLYPHIntegrator]:
851 |     """Create Trinity-compliant identity system with GLYPH integration"""
    |

PERF203 `try`-`except` within a loop incurs performance overhead
   --> candidate/governance/identity/constellation_glyph_integration.py:884:13
    |
882 |                   )
883 |
884 | /             except Exception as e:
885 | |                 print(f"Trinity compliance validation failed for {component.value}: {e}")
    | |_________________________________________________________________________________________^
886 |
887 |           return identity_system, trinity_validator, glyph_integrator
    |

ARG005 Unused lambda argument: `args`
   --> candidate/governance/identity/constellation_glyph_integration.py:894:50
    |
892 |             def __init__(self):
893 |                 self.trinity_compliant = True
894 |                 self.authenticate_user = lambda *args, **kwargs: {"success": True}
    |                                                  ^^^^
895 |
896 |         return MockIdentitySystem(), TrinityValidator(), GLYPHIntegrator()
    |

ARG005 Unused lambda argument: `kwargs`
   --> candidate/governance/identity/constellation_glyph_integration.py:894:58
    |
892 |             def __init__(self):
893 |                 self.trinity_compliant = True
894 |                 self.authenticate_user = lambda *args, **kwargs: {"success": True}
    |                                                          ^^^^^^
895 |
896 |         return MockIdentitySystem(), TrinityValidator(), GLYPHIntegrator()
    |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
  --> candidate/governance/identity/core/auth/bio_symbolic_fusion.py:72:31
   |
70 |     def __post_init__(self):
71 |         if self.created_at is None:
72 |             self.created_at = datetime.now()
   |                               ^^^^^^^^^^^^^^
   |
help: Pass a `datetime.timezone` object to the `tz` parameter

RUF001 String contains ambiguous `âˆ¼` (TILDE OPERATOR). Did you mean `~` (TILDE)?
   --> candidate/governance/identity/core/auth/bio_symbolic_fusion.py:451:21
    |
449 |             return "âˆ¿"  # Low coherence
450 |         elif synchrony < 0.7:
451 |             return "âˆ¼"  # Moderate coherence
    |                     ^
452 |         else:
453 |             return "â‰‹"  # High coherence
    |

ARG002 Unused method argument: `biometric_data`
   --> candidate/governance/identity/core/auth/bio_symbolic_fusion.py:501:43
    |
499 |         return matches / len(pattern1)
500 |
501 |     def _apply_cultural_adaptations(self, biometric_data: dict[str, Any], emotional_state: str) -> dict[str, Any]:
    |                                           ^^^^^^^^^^^^^^
502 |         """Apply cultural adaptations to biometric patterns"""
503 |         # This would integrate with cultural context detection
    |

ARG002 Unused method argument: `emotional_state`
   --> candidate/governance/identity/core/auth/bio_symbolic_fusion.py:501:75
    |
499 |         return matches / len(pattern1)
500 |
501 |     def _apply_cultural_adaptations(self, biometric_data: dict[str, Any], emotional_state: str) -> dict[str, Any]:
    |                                                                           ^^^^^^^^^^^^^^^
502 |         """Apply cultural adaptations to biometric patterns"""
503 |         # This would integrate with cultural context detection
    |

ARG002 Unused method argument: `lambda_id`
   --> candidate/governance/identity/core/auth/bio_symbolic_fusion.py:636:45
    |
634 |         return total_score / total_weight if total_weight > 0 else 0.0
635 |
636 |     def _check_cultural_compatibility(self, lambda_id: str, consciousness_state: ConsciousnessState) -> bool:
    |                                             ^^^^^^^^^
637 |         """Check cultural compatibility of authentication patterns"""
638 |         # This would check against user's cultural profile
    |

ARG002 Unused method argument: `consciousness_state`
   --> candidate/governance/identity/core/auth/bio_symbolic_fusion.py:636:61
    |
634 |         return total_score / total_weight if total_weight > 0 else 0.0
635 |
636 |     def _check_cultural_compatibility(self, lambda_id: str, consciousness_state: ConsciousnessState) -> bool:
    |                                                             ^^^^^^^^^^^^^^^^^^^
637 |         """Check cultural compatibility of authentication patterns"""
638 |         # This would check against user's cultural profile
    |

ARG002 Unused method argument: `lambda_id`
   --> candidate/governance/identity/core/auth/bio_symbolic_fusion.py:642:42
    |
640 |         return True
641 |
642 |     def _verify_quantum_signatures(self, lambda_id: str, auth_data: dict[str, Any]) -> bool:
    |                                          ^^^^^^^^^
643 |         """Verify quantum signatures for pattern integrity"""
644 |         # This would verify PQC signatures on stored patterns
    |

ARG002 Unused method argument: `auth_data`
   --> candidate/governance/identity/core/auth/bio_symbolic_fusion.py:642:58
    |
640 |         return True
641 |
642 |     def _verify_quantum_signatures(self, lambda_id: str, auth_data: dict[str, Any]) -> bool:
    |                                                          ^^^^^^^^^
643 |         """Verify quantum signatures for pattern integrity"""
644 |         # This would verify PQC signatures on stored patterns
    |

PERF401 Use a list comprehension to create a transformed list
   --> candidate/governance/identity/core/auth/biometric_integration.py:432:13
    |
430 |           enrolled_biometrics = []
431 |           for template in user_templates:
432 | /             enrolled_biometrics.append(
433 | |                 {
434 | |                     "type": template.biometric_type.value,
435 | |                     "quality_level": template.quality_level.value,
436 | |                     "enrollment_date": template.enrollment_timestamp,
437 | |                     "usage_count": template.usage_count,
438 | |                     "cultural_adaptation": template.cultural_adaptation,
439 | |                     "consciousness_integration": template.consciousness_markers is not None,
440 | |                 }
441 | |             )
    | |_____________^
442 |
443 |           return {
    |
help: Replace for loop with list comprehension

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/auth/dream_auth.py:231:29
    |
229 |             personal_significance=personal_significance,
230 |             archetypal_content=archetypal_content,
231 |             dream_timestamp=datetime.now(),
    |                             ^^^^^^^^^^^^^^
232 |             verification_hash=verification_hash,
233 |         )
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/auth/dream_auth.py:307:24
    |
305 |             difficulty_level=difficulty_level,
306 |             cultural_context=None,  # Auto-detect from user profile
307 |             created_at=datetime.now(),
    |                        ^^^^^^^^^^^^^^
308 |             expires_at=datetime.now() + timedelta(hours=24),  # 24-hour expiry
309 |         )
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/auth/dream_auth.py:308:24
    |
306 |             cultural_context=None,  # Auto-detect from user profile
307 |             created_at=datetime.now(),
308 |             expires_at=datetime.now() + timedelta(hours=24),  # 24-hour expiry
    |                        ^^^^^^^^^^^^^^
309 |         )
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/auth/dream_auth.py:358:16
    |
357 |             # Check seed expiry
358 |             if datetime.now() > seed.expires_at:
    |                ^^^^^^^^^^^^^^
359 |                 return DreamAuthenticationResult(
360 |                     success=False,
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

PERF401 Use a list comprehension to create a transformed list
   --> candidate/governance/identity/core/auth/dream_auth.py:520:17
    |
518 |         for symbol in dream_symbols:
519 |             if symbol in narrative_lower:
520 |                 found_symbols.append(symbol)
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
521 |
522 |         return found_symbols
    |
help: Replace for loop with list comprehension

E501 Line too long (154 > 120)
   --> candidate/governance/identity/core/auth/dream_auth.py:576:121
    |
574 | â€¦
575 | â€¦elements[0]}",
576 | â€¦lements[0]} and {expected_elements[1] if len(expected_elements) > 1 else 'light'}",
    |                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
577 | â€¦d_elements)}",
578 | â€¦
    |

E501 Line too long (200 > 120)
   --> candidate/governance/identity/core/auth/dream_auth.py:581:121
    |
580 | â€¦
581 | â€¦rnal symbols: {', '.join(expected_elements)}. Let your lucid awareness dance with these archetypal forms."
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
582 | â€¦
583 | â€¦ou are dreaming and interact consciously with these symbols."
    |

E501 Line too long (155 > 120)
   --> candidate/governance/identity/core/auth/dream_auth.py:583:121
    |
581 | â€¦ciousness with the eternal symbols: {', '.join(expected_elements)}. Let your lucid awareness dance with these archetypal forms."
582 | â€¦
583 | â€¦nts)}. Be aware that you are dreaming and interact consciously with these symbols."
    |                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
584 | â€¦
585 | â€¦
    |

DTZ003 `datetime.datetime.utcnow()` used
  --> candidate/governance/identity/core/auth/oauth2_oidc_provider.py:48:57
   |
46 |         self.response_types = set(client_data.get("response_types", ["code"]))
47 |         self.tier_level = client_data.get("tier_level", 0)
48 |         self.created_at = client_data.get("created_at", datetime.utcnow().isoformat())
   |                                                         ^^^^^^^^^^^^^^^^^
49 |         self.trusted = client_data.get("trusted", False)
   |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/auth/oauth2_oidc_provider.py:388:20
    |
386 |                 # Check expiration
387 |                 expires_at = datetime.fromisoformat(token_data["expires_at"])
388 |                 if datetime.utcnow() > expires_at:
    |                    ^^^^^^^^^^^^^^^^^
389 |                     return {"active": False}
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/auth/oauth2_oidc_provider.py:428:16
    |
426 |             # Check expiration
427 |             expires_at = datetime.fromisoformat(token_data["expires_at"])
428 |             if datetime.utcnow() > expires_at:
    |                ^^^^^^^^^^^^^^^^^
429 |                 return self._error_response("invalid_token", "Token expired")
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/auth/oauth2_oidc_provider.py:452:43
    |
450 |                         "picture": f"{self.issuer}/avatar/{user_id}",
451 |                         "profile": f"{self.issuer}/profile/{user_id}",
452 |                         "updated_at": int(datetime.utcnow().timestamp()),
    |                                           ^^^^^^^^^^^^^^^^^
453 |                     }
454 |                 )
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/auth/oauth2_oidc_provider.py:494:64
    |
492 |         try:
493 |             # Check cache
494 |             if self.jwks_cache and self.jwks_cache_expires and datetime.utcnow() < self.jwks_cache_expires:
    |                                                                ^^^^^^^^^^^^^^^^^
495 |                 return self.jwks_cache
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/auth/oauth2_oidc_provider.py:528:39
    |
526 |             # Cache for 1 hour
527 |             self.jwks_cache = jwks
528 |             self.jwks_cache_expires = datetime.utcnow() + timedelta(hours=1)
    |                                       ^^^^^^^^^^^^^^^^^
529 |
530 |             return jwks
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/auth/oauth2_oidc_provider.py:573:44
    |
571 |                 "client_id": client_id,
572 |                 "client_secret": client_secret,
573 |                 "client_id_issued_at": int(datetime.utcnow().timestamp()),
    |                                            ^^^^^^^^^^^^^^^^^
574 |                 "client_secret_expires_at": 0,  # Never expires
575 |                 "redirect_uris": redirect_uris,
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/auth/oauth2_oidc_provider.py:701:26
    |
699 |             "code_challenge": code_challenge,
700 |             "code_challenge_method": code_challenge_method,
701 |             "issued_at": datetime.utcnow().isoformat(),
    |                          ^^^^^^^^^^^^^^^^^
702 |             "expires_at": (datetime.utcnow() + timedelta(minutes=10)).isoformat(),
703 |         }
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/auth/oauth2_oidc_provider.py:702:28
    |
700 |             "code_challenge_method": code_challenge_method,
701 |             "issued_at": datetime.utcnow().isoformat(),
702 |             "expires_at": (datetime.utcnow() + timedelta(minutes=10)).isoformat(),
    |                            ^^^^^^^^^^^^^^^^^
703 |         }
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/auth/oauth2_oidc_provider.py:743:26
    |
741 |             "user_tier": code_data["user_tier"],
742 |             "scope": code_data["scope"],
743 |             "issued_at": datetime.utcnow().isoformat(),
    |                          ^^^^^^^^^^^^^^^^^
744 |             "expires_at": (datetime.utcnow() + timedelta(hours=1)).isoformat(),
745 |             "lambda_id": f"LUKHAS{code_data['user_tier']}-DEMO-â—‹-ABCD",
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/auth/oauth2_oidc_provider.py:744:28
    |
742 |             "scope": code_data["scope"],
743 |             "issued_at": datetime.utcnow().isoformat(),
744 |             "expires_at": (datetime.utcnow() + timedelta(hours=1)).isoformat(),
    |                            ^^^^^^^^^^^^^^^^^
745 |             "lambda_id": f"LUKHAS{code_data['user_tier']}-DEMO-â—‹-ABCD",
746 |         }
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/auth/oauth2_oidc_provider.py:788:15
    |
786 |             return None
787 |
788 |         now = datetime.utcnow()
    |               ^^^^^^^^^^^^^^^^^
789 |         payload = {
790 |             "iss": self.issuer,
    |
help: Use `datetime.datetime.now(tz=...)` instead

ARG002 Unused method argument: `redirect_uri`
   --> candidate/governance/identity/core/auth/oauth2_oidc_provider.py:812:9
    |
810 |         user_tier,
811 |         scopes,
812 |         redirect_uri,
    |         ^^^^^^^^^^^^
813 |         state,
814 |         token_type,
    |

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/auth/oauth2_oidc_provider.py:827:30
    |
825 |                 "user_tier": user_tier,
826 |                 "scope": list(scopes),
827 |                 "issued_at": datetime.utcnow().isoformat(),
    |                              ^^^^^^^^^^^^^^^^^
828 |                 "expires_at": (datetime.utcnow() + timedelta(hours=1)).isoformat(),
829 |             }
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/auth/oauth2_oidc_provider.py:828:32
    |
826 |                 "scope": list(scopes),
827 |                 "issued_at": datetime.utcnow().isoformat(),
828 |                 "expires_at": (datetime.utcnow() + timedelta(hours=1)).isoformat(),
    |                                ^^^^^^^^^^^^^^^^^
829 |             }
    |
help: Use `datetime.datetime.now(tz=...)` instead

ARG002 Unused method argument: `response_type`
   --> candidate/governance/identity/core/auth/oauth2_oidc_provider.py:862:9
    |
860 |         state,
861 |         nonce,
862 |         response_type,
    |         ^^^^^^^^^^^^^
863 |         code_challenge,
864 |         code_challenge_method,
    |

ARG002 Unused method argument: `client`
   --> candidate/governance/identity/core/auth/oauth2_oidc_provider.py:880:45
    |
878 |         )
879 |
880 |     def _handle_refresh_token_request(self, client, request_params):
    |                                             ^^^^^^
881 |         """Handle refresh token request"""
882 |         refresh_token = request_params.get("refresh_token", "")
    |

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/auth/oauth2_oidc_provider.py:894:30
    |
892 |         new_token_data.update(
893 |             {
894 |                 "issued_at": datetime.utcnow().isoformat(),
    |                              ^^^^^^^^^^^^^^^^^
895 |                 "expires_at": (datetime.utcnow() + timedelta(hours=1)).isoformat(),
896 |             }
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/auth/oauth2_oidc_provider.py:895:32
    |
893 |             {
894 |                 "issued_at": datetime.utcnow().isoformat(),
895 |                 "expires_at": (datetime.utcnow() + timedelta(hours=1)).isoformat(),
    |                                ^^^^^^^^^^^^^^^^^
896 |             }
897 |         )
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/auth/oauth2_oidc_provider.py:923:26
    |
921 |             "user_tier": client.tier_level,
922 |             "scope": final_scopes,
923 |             "issued_at": datetime.utcnow().isoformat(),
    |                          ^^^^^^^^^^^^^^^^^
924 |             "expires_at": (datetime.utcnow() + timedelta(hours=24)).isoformat(),
925 |         }
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/auth/oauth2_oidc_provider.py:924:28
    |
922 |             "scope": final_scopes,
923 |             "issued_at": datetime.utcnow().isoformat(),
924 |             "expires_at": (datetime.utcnow() + timedelta(hours=24)).isoformat(),
    |                            ^^^^^^^^^^^^^^^^^
925 |         }
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
  --> candidate/governance/identity/core/auth/webauthn_manager.py:49:61
   |
47 |         self.user_id = credential_data.get("user_id", "")
48 |         self.authenticator_data = credential_data.get("authenticator_data", {})
49 |         self.created_at = credential_data.get("created_at", datetime.utcnow().isoformat())
   |                                                             ^^^^^^^^^^^^^^^^^
50 |         self.last_used = credential_data.get("last_used")
51 |         self.tier_level = credential_data.get("tier_level", 0)
   |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/auth/webauthn_manager.py:164:31
    |
162 |                 "user_id": user_id,
163 |                 "user_tier": user_tier,
164 |                 "created_at": datetime.utcnow().isoformat(),
    |                               ^^^^^^^^^^^^^^^^^
165 |                 "expires_at": (datetime.utcnow() + timedelta(minutes=5)).isoformat(),
166 |             }
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/auth/webauthn_manager.py:165:32
    |
163 |                 "user_tier": user_tier,
164 |                 "created_at": datetime.utcnow().isoformat(),
165 |                 "expires_at": (datetime.utcnow() + timedelta(minutes=5)).isoformat(),
    |                                ^^^^^^^^^^^^^^^^^
166 |             }
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/auth/webauthn_manager.py:204:16
    |
202 |             # Check expiration
203 |             expires_at = datetime.fromisoformat(pending_reg["expires_at"])
204 |             if datetime.utcnow() > expires_at:
    |                ^^^^^^^^^^^^^^^^^
205 |                 del self.pending_registrations[registration_id]
206 |                 return {"success": False, "error": "Registration expired"}
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/auth/webauthn_manager.py:328:31
    |
326 |                 "user_id": user_id,
327 |                 "tier_level": tier_level,
328 |                 "created_at": datetime.utcnow().isoformat(),
    |                               ^^^^^^^^^^^^^^^^^
329 |                 "expires_at": (datetime.utcnow() + timedelta(minutes=5)).isoformat(),
330 |             }
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/auth/webauthn_manager.py:329:32
    |
327 |                 "tier_level": tier_level,
328 |                 "created_at": datetime.utcnow().isoformat(),
329 |                 "expires_at": (datetime.utcnow() + timedelta(minutes=5)).isoformat(),
    |                                ^^^^^^^^^^^^^^^^^
330 |             }
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/auth/webauthn_manager.py:369:16
    |
367 |             # Check expiration
368 |             expires_at = datetime.fromisoformat(pending_auth["expires_at"])
369 |             if datetime.utcnow() > expires_at:
    |                ^^^^^^^^^^^^^^^^^
370 |                 del self.pending_authentications[authentication_id]
371 |                 return {"success": False, "error": "Authentication expired"}
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/auth/webauthn_manager.py:419:40
    |
418 |                 # Update credential usage
419 |                 credential.last_used = datetime.utcnow().isoformat()
    |                                        ^^^^^^^^^^^^^^^^^
420 |                 credential.sign_count += 1
    |
help: Use `datetime.datetime.now(tz=...)` instead

PERF401 Use a list comprehension to create a transformed list
   --> candidate/governance/identity/core/auth/webauthn_manager.py:469:17
    |
468 |               for cred in user_creds:
469 | /                 credentials_info.append(
470 | |                     {
471 | |                         "credential_id": cred.credential_id[:16] + "...",  # Truncate for security
472 | |                         "created_at": cred.created_at,
473 | |                         "last_used": cred.last_used,
474 | |                         "tier_level": cred.tier_level,
475 | |                         "device_type": cred.device_type,
476 | |                         "sign_count": cred.sign_count,
477 | |                     }
478 | |                 )
    | |_________________^
479 |
480 |               return {
    |
help: Replace for loop with list comprehension

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/auth/webauthn_manager.py:519:31
    |
517 |                 "user_id": user_id,
518 |                 "credential_id": credential_id[:16] + "...",
519 |                 "revoked_at": datetime.utcnow().isoformat(),
    |                               ^^^^^^^^^^^^^^^^^
520 |             }
    |
help: Use `datetime.datetime.now(tz=...)` instead

SIM103 Return the negated condition directly
   --> candidate/governance/identity/core/auth/webauthn_manager.py:566:13
    |
565 |               # âš›ï¸ Identity integrity check
566 | /             if len(user_id) > 100:  # Prevent oversized IDs
567 | |                 return False
568 | |
569 | |             return True
    | |_______________________^
570 |
571 |           except Exception:
    |
help: Inline condition

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/auth/webauthn_manager.py:577:21
    |
575 |         """ðŸ§  Update consciousness patterns for security analysis"""
576 |         # This would integrate with the consciousness tracking system
577 |         timestamp = datetime.utcnow().isoformat()
    |                     ^^^^^^^^^^^^^^^^^
578 |         print(f"Consciousness update: {user_id} | {action} | {timestamp}")
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/auth/webauthn_manager.py:588:28
    |
587 |             # Clean expired pending operations
588 |             current_time = datetime.utcnow()
    |                            ^^^^^^^^^^^^^^^^^
589 |             expired_regs = 0
590 |             expired_auths = 0
    |
help: Use `datetime.datetime.now(tz=...)` instead

PERF203 `try`-`except` within a loop incurs performance overhead
   --> candidate/governance/identity/core/auth/webauthn_manager.py:598:17
    |
596 |                           del self.pending_registrations[reg_id]
597 |                           expired_regs += 1
598 | /                 except Exception:
599 | |                     del self.pending_registrations[reg_id]
600 | |                     expired_regs += 1
    | |_____________________________________^
601 |
602 |               for auth_id, auth_data in list(self.pending_authentications.items()):
    |

PERF203 `try`-`except` within a loop incurs performance overhead
   --> candidate/governance/identity/core/auth/webauthn_manager.py:608:17
    |
606 |                           del self.pending_authentications[auth_id]
607 |                           expired_auths += 1
608 | /                 except Exception:
609 | |                     del self.pending_authentications[auth_id]
610 | |                     expired_auths += 1
    | |______________________________________^
611 |
612 |               return {
    |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/brain_identity_connector.py:373:26
    |
371 |         """
372 |         log_entry = {
373 |             "timestamp": datetime.now().isoformat(),
    |                          ^^^^^^^^^^^^^^
374 |             "user_id": user_id,
375 |             "operation": str(operation),
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

ARG002 Unused method argument: `key`
   --> candidate/governance/identity/core/brain_identity_connector.py:442:38
    |
440 |         logger.info("Memory Identity Integration initialized")
441 |
442 |     def encrypt_memory_content(self, key: str, content: dict[str, Any]) -> dict[str, Any]:
    |                                      ^^^
443 |         """
444 |         Encrypt memory content for secure storage.
    |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/brain_identity_connector.py:459:37
    |
457 |         content["_meta"] = {
458 |             "encrypted": True,
459 |             "encryption_timestamp": datetime.now().isoformat(),
    |                                     ^^^^^^^^^^^^^^
460 |             "encryption_version": "1.0",
461 |         }
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

ARG002 Unused method argument: `key`
   --> candidate/governance/identity/core/brain_identity_connector.py:465:38
    |
463 |         return content
464 |
465 |     def decrypt_memory_content(self, key: str, content: dict[str, Any]) -> dict[str, Any]:
    |                                      ^^^
466 |         """
467 |         Decrypt memory content for access.
    |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/brain_identity_connector.py:482:44
    |
480 |             meta = content["_meta"].copy()
481 |             meta["encrypted"] = False
482 |             meta["decryption_timestamp"] = datetime.now().isoformat()
    |                                            ^^^^^^^^^^^^^^
483 |             content["_meta"] = meta
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

ARG002 Unused method argument: `args`
  --> candidate/governance/identity/core/brain_identity_integration.py:29:29
   |
27 |     # Create fallback mock classes
28 |     class BrainIdentityConnector:
29 |         def __init__(self, *args, **kwargs):
   |                             ^^^^
30 |             self.initialized = False
   |

ARG002 Unused method argument: `kwargs`
  --> candidate/governance/identity/core/brain_identity_integration.py:29:37
   |
27 |     # Create fallback mock classes
28 |     class BrainIdentityConnector:
29 |         def __init__(self, *args, **kwargs):
   |                                     ^^^^^^
30 |             self.initialized = False
   |

ARG002 Unused method argument: `args`
  --> candidate/governance/identity/core/brain_identity_integration.py:33:29
   |
32 |     class MemoryIdentityIntegration:
33 |         def __init__(self, *args, **kwargs):
   |                             ^^^^
34 |             self.initialized = False
   |

ARG002 Unused method argument: `kwargs`
  --> candidate/governance/identity/core/brain_identity_integration.py:33:37
   |
32 |     class MemoryIdentityIntegration:
33 |         def __init__(self, *args, **kwargs):
   |                                     ^^^^^^
34 |             self.initialized = False
   |

ARG002 Unused method argument: `kwargs`
   --> candidate/governance/identity/core/brain_identity_integration.py:136:44
    |
134 |                 self.memories = {}
135 |
136 |             def retrieve(self, key: str, **kwargs):
    |                                            ^^^^^^
137 |                 return self.memories.get(key)
    |

ARG002 Unused method argument: `kwargs`
   --> candidate/governance/identity/core/brain_identity_integration.py:139:52
    |
137 |                 return self.memories.get(key)
138 |
139 |             def store(self, key: str, data: Any, **kwargs):
    |                                                    ^^^^^^
140 |                 self.memories[key] = data
141 |                 return True
    |

ARG002 Unused method argument: `kwargs`
   --> candidate/governance/identity/core/brain_identity_integration.py:143:53
    |
141 |                 return True
142 |
143 |             def update(self, key: str, data: Any, **kwargs):
    |                                                     ^^^^^^
144 |                 if key in self.memories:
145 |                     self.memories[key] = data
    |

ARG002 Unused method argument: `kwargs`
   --> candidate/governance/identity/core/brain_identity_integration.py:149:42
    |
147 |                 return False
148 |
149 |             def delete(self, key: str, **kwargs):
    |                                          ^^^^^^
150 |                 if key in self.memories:
151 |                     del self.memories[key]
    |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/brain_identity_integration.py:319:30
    |
317 |                 "memory_key": memory_key,
318 |                 "memory_type": memory_type,
319 |                 "timestamp": datetime.now().isoformat(),
    |                              ^^^^^^^^^^^^^^
320 |                 "session_id": self._get_user_session(user_id),
321 |             }
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/brain_identity_integration.py:334:30
    |
332 |                 "authorized": False,
333 |                 "error": str(e),
334 |                 "timestamp": datetime.now().isoformat(),
    |                              ^^^^^^^^^^^^^^
335 |             }
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

ARG002 Unused method argument: `memory_key`
   --> candidate/governance/identity/core/brain_identity_integration.py:379:9
    |
377 |         user_id: str,
378 |         operation: str,
379 |         memory_key: str,
    |         ^^^^^^^^^^
380 |         memory_type: Optional[str],
381 |         memory_owner: Optional[str],
    |

ARG002 Unused method argument: `memory_type`
   --> candidate/governance/identity/core/brain_identity_integration.py:380:9
    |
378 |         operation: str,
379 |         memory_key: str,
380 |         memory_type: Optional[str],
    |         ^^^^^^^^^^^
381 |         memory_owner: Optional[str],
382 |     ) -> bool:
    |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/brain_identity_integration.py:453:34
    |
451 |                 "access_policy": access_policy,
452 |                 "min_tier": min_tier,
453 |                 "registered_at": datetime.now().isoformat(),
    |                                  ^^^^^^^^^^^^^^
454 |             }
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/brain_identity_integration.py:460:34
    |
458 |                 "success": success,
459 |                 "memory_key": memory_key,
460 |                 "registered_at": datetime.now().isoformat(),
    |                                  ^^^^^^^^^^^^^^
461 |             }
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/brain_identity_integration.py:468:30
    |
466 |                 "success": False,
467 |                 "error": str(e),
468 |                 "timestamp": datetime.now().isoformat(),
    |                              ^^^^^^^^^^^^^^
469 |             }
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

ARG002 Unused method argument: `memory_owner`
   --> candidate/governance/identity/core/brain_identity_integration.py:474:9
    |
472 |         self,
473 |         memory_key: str,
474 |         memory_owner: str,
    |         ^^^^^^^^^^^^
475 |         memory_type: str,
476 |         access_policy: str,
    |

ARG002 Unused method argument: `memory_type`
   --> candidate/governance/identity/core/brain_identity_integration.py:475:9
    |
473 |         memory_key: str,
474 |         memory_owner: str,
475 |         memory_type: str,
    |         ^^^^^^^^^^^
476 |         access_policy: str,
477 |         min_tier: int,
    |

ARG002 Unused method argument: `access_policy`
   --> candidate/governance/identity/core/brain_identity_integration.py:476:9
    |
474 |         memory_owner: str,
475 |         memory_type: str,
476 |         access_policy: str,
    |         ^^^^^^^^^^^^^
477 |         min_tier: int,
478 |     ) -> bool:
    |

ARG002 Unused method argument: `min_tier`
   --> candidate/governance/identity/core/brain_identity_integration.py:477:9
    |
475 |         memory_type: str,
476 |         access_policy: str,
477 |         min_tier: int,
    |         ^^^^^^^^
478 |     ) -> bool:
479 |         """Fallback memory registration"""
    |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/brain_identity_integration.py:514:30
    |
512 |         return [
513 |             {
514 |                 "timestamp": datetime.now().isoformat(),
    |                              ^^^^^^^^^^^^^^
515 |                 "user_id": "mock_user",
516 |                 "operation": "read",
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/brain_identity_integration.py:547:37
    |
545 |                     "memory_registry_size": len(self.memory_registry),
546 |                     "active_sessions": len(self.user_sessions),
547 |                     "last_updated": datetime.now().isoformat(),
    |                                     ^^^^^^^^^^^^^^
548 |                 }
549 |             )
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/brain_identity_integration.py:555:51
    |
553 |         except Exception as e:
554 |             logger.error(f"Error getting access metrics: {e}")
555 |             return {"error": str(e), "timestamp": datetime.now().isoformat()}
    |                                                   ^^^^^^^^^^^^^^
556 |
557 |     def _get_fallback_metrics(self) -> dict[str, Any]:
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/brain_identity_integration.py:598:49
    |
596 |         content_copy = content.copy()
597 |         content_copy["_encrypted"] = True
598 |         content_copy["_encryption_timestamp"] = datetime.now().isoformat()
    |                                                 ^^^^^^^^^^^^^^
599 |         content_copy["_encryption_key"] = memory_key
600 |         return content_copy
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

ARG002 Unused method argument: `memory_key`
   --> candidate/governance/identity/core/brain_identity_integration.py:630:33
    |
628 |             return content  # Return original content on error
629 |
630 |     def _fallback_decrypt(self, memory_key: str, content: dict[str, Any]) -> dict[str, Any]:
    |                                 ^^^^^^^^^^
631 |         """Fallback decryption (mock implementation)"""
632 |         content_copy = content.copy()
    |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/brain_identity_integration.py:635:53
    |
633 |         if "_encrypted" in content_copy:
634 |             content_copy["_encrypted"] = False
635 |             content_copy["_decryption_timestamp"] = datetime.now().isoformat()
    |                                                     ^^^^^^^^^^^^^^
636 |         return content_copy
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

ARG002 Unused method argument: `session_id`
   --> candidate/governance/identity/core/colonies/biometric_verification_colony.py:309:9
    |
307 |         reference_template: bytes,
308 |         tier_level: int,
309 |         session_id: Optional[str] = None,
    |         ^^^^^^^^^^
310 |     ) -> VerificationResult:
311 |         """
    |

ARG002 Unused method argument: `task`
   --> candidate/governance/identity/core/colonies/biometric_verification_colony.py:434:9
    |
432 |     async def _verify_biometric_type(
433 |         self,
434 |         task: BiometricVerificationTask,
    |         ^^^^
435 |         biometric_type: BiometricType,
436 |         samples: list[BiometricSample],
    |

SIM102 Use a single `if` statement instead of nested `if` statements
   --> candidate/governance/identity/core/colonies/biometric_verification_colony.py:615:9
    |
614 |           # Adjust weight based on tier level
615 | /         if tier_level >= 4:
616 | |             # Higher tiers emphasize advanced biometrics
617 | |             if biometric_type in [
618 | |                 BiometricType.BRAINWAVE.value,
619 | |                 BiometricType.IRIS.value,
620 | |             ]:
    | |______________^
621 |                   base_weight *= 1.2
    |
help: Combine `if` statements using `and`

RUF006 Store a reference to the return value of `asyncio.create_task`
   --> candidate/governance/identity/core/colonies/biometric_verification_colony.py:673:9
    |
672 |         # Schedule performance recovery
673 |         asyncio.create_task(self._gradual_performance_recovery(agent_id))
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
674 |
675 |     async def _gradual_performance_recovery(self, agent_id: str):
    |

RUF006 Store a reference to the return value of `asyncio.create_task`
   --> candidate/governance/identity/core/colonies/consciousness_verification_colony.py:584:9
    |
583 |         # Start background pattern learning
584 |         asyncio.create_task(self._pattern_learning_loop())
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
585 |
586 |     async def verify_consciousness_state(
    |

ARG002 Unused method argument: `session_id`
   --> candidate/governance/identity/core/colonies/consciousness_verification_colony.py:593:9
    |
591 |         cognitive_metrics: Optional[CognitiveMetrics],
592 |         tier_level: int,
593 |         session_id: Optional[str] = None,
    |         ^^^^^^^^^^
594 |     ) -> VerificationResult:
595 |         """
    |

ARG002 Unused method argument: `task`
   --> candidate/governance/identity/core/colonies/consciousness_verification_colony.py:792:9
    |
790 |         self,
791 |         agent_results: list[dict[str, Any]],
792 |         task: ConsciousnessVerificationTask,
    |         ^^^^
793 |         lambda_id: str,
794 |     ) -> dict[str, Any]:
    |

B007 Loop control variable `agent_id` not used within loop body
   --> candidate/governance/identity/core/colonies/consciousness_verification_colony.py:996:13
    |
994 |             dissent_reasons.append("Consciousness spoofing detected")
995 |
996 |         for agent_id, vote_data in votes.items():
    |             ^^^^^^^^
997 |             if not vote_data["vote"]:
998 |                 dissent_reasons.append(f"{vote_data['method']}: Low confidence ({vote_data['confidence']:.2f})")
    |
help: Rename unused `agent_id` to `_agent_id`

ARG002 Unused method argument: `agent_results`
    --> candidate/governance/identity/core/colonies/consciousness_verification_colony.py:1012:9
     |
1010 |         self,
1011 |         lambda_id: str,
1012 |         agent_results: list[dict[str, Any]],
     |         ^^^^^^^^^^^^^
1013 |         emergent_insights: dict[str, Any],
1014 |     ):
     |

PERF203 `try`-`except` within a loop incurs performance overhead
    --> candidate/governance/identity/core/colonies/consciousness_verification_colony.py:1076:13
     |
1074 |                       logger.info(f"Updated emergent patterns: {len(universal_patterns)} universal patterns identified")
1075 |
1076 | /             except Exception as e:
1077 | |                 logger.error(f"Pattern learning error: {e}")
1078 | |                 await asyncio.sleep(60)
     | |_______________________________________^
     |

F821 Undefined name `EventBus`
   --> candidate/governance/identity/core/colonies/dream_verification_colony.py:523:34
    |
521 |         self.verification_agents: dict[str, DreamAnalysisAgent] = {}
522 |         self.event_publisher: Optional[IdentityEventPublisher] = None
523 |         self.event_bus: Optional[EventBus] = None
    |                                  ^^^^^^^^
524 |         self.dream_authenticator: Optional[DreamAuthenticator] = None
    |

RUF006 Store a reference to the return value of `asyncio.create_task`
   --> candidate/governance/identity/core/colonies/dream_verification_colony.py:573:9
    |
572 |         # Start collective dreaming space
573 |         asyncio.create_task(self._maintain_collective_dream_space())
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
574 |
575 |     async def verify_dream_authentication(
    |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/colonies/dream_verification_colony.py:657:42
    |
655 |                 temporal_consistency=collective_insights["temporal_alignment"],
656 |                 consciousness_signature=self._generate_consciousness_signature(analysis_results),
657 |                 authentication_timestamp=datetime.now(),
    |                                          ^^^^^^^^^^^^^^
658 |                 multiverse_correlation=qi_result["multiverse_correlation"],
659 |                 verification_method="multiverse_dream_colony",
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/colonies/dream_verification_colony.py:708:42
    |
706 |                 temporal_consistency=0.0,
707 |                 consciousness_signature="",
708 |                 authentication_timestamp=datetime.now(),
    |                                          ^^^^^^^^^^^^^^
709 |                 error_message=str(e),
710 |             )
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

ARG002 Unused method argument: `dream_branches`
   --> candidate/governance/identity/core/colonies/dream_verification_colony.py:807:9
    |
805 |         self,
806 |         analysis_results: list[dict[str, Any]],
807 |         dream_branches: list[MultiverseDreamBranch],
    |         ^^^^^^^^^^^^^^
808 |         lambda_id: str,
809 |     ) -> dict[str, Any]:
    |

B007 Loop control variable `vote_id` not used within loop body
   --> candidate/governance/identity/core/colonies/dream_verification_colony.py:984:13
    |
982 |         # Identify dissent reasons
983 |         dissent_reasons = []
984 |         for vote_id, vote_data in votes.items():
    |             ^^^^^^^
985 |             if not vote_data["vote"]:
986 |                 dissent_reasons.append(f"{vote_data['method']}: Low confidence ({vote_data['confidence']:.2f})")
    |
help: Rename unused `vote_id` to `_vote_id`

PERF203 `try`-`except` within a loop incurs performance overhead
    --> candidate/governance/identity/core/colonies/dream_verification_colony.py:1016:13
     |
1014 |                       logger.info(f"Collective dream space updated: {len(universal_themes)} themes")
1015 |
1016 | /             except Exception as e:
1017 | |                 logger.error(f"Collective dream space maintenance error: {e}")
1018 | |                 await asyncio.sleep(60)
     | |_______________________________________^
1019 |
1020 |       # Helper methods for dream analysis
     |

ARG002 Unused method argument: `dream_seed`
    --> candidate/governance/identity/core/colonies/dream_verification_colony.py:1023:46
     |
1022 |     async def _create_dream_variation(
1023 |         self, base_response: dict[str, Any], dream_seed: DreamSeed, variation_index: int
     |                                              ^^^^^^^^^^
1024 |     ) -> dict[str, Any]:
1025 |         """Create a variation of the base dream response."""
     |

ARG002 Unused method argument: `dream_seed`
    --> candidate/governance/identity/core/colonies/dream_verification_colony.py:1055:77
     |
1053 |         return variation
1054 |
1055 |     async def _extract_dream_symbols(self, dream_variation: dict[str, Any], dream_seed: DreamSeed) -> list[DreamSymbol]:
     |                                                                             ^^^^^^^^^^
1056 |         """Extract symbolic elements from dream variation."""
1057 |         symbols = []
     |

PERF401 Use a list comprehension to create a transformed list
    --> candidate/governance/identity/core/colonies/dream_verification_colony.py:1105:17
     |
1103 |         for result in analysis_results:
1104 |             if result.get("success"):
1105 |                 signature_elements.append(f"{result.get('specialization')}:{result.get('confidence'):.3f}")
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1106 |
1107 |         signature_string = "|".join(sorted(signature_elements))
     |
help: Replace for loop with list comprehension

DTZ003 `datetime.datetime.utcnow()` used
  --> candidate/governance/identity/core/commercial/commercial_module.py:67:75
   |
65 |     def is_valid(self) -> bool:
66 |         """Check if brand prefix is currently valid."""
67 |         return self.status == BrandStatus.APPROVED and self.expiry_date > datetime.utcnow()
   |                                                                           ^^^^^^^^^^^^^^^^^
   |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/commercial/commercial_module.py:209:23
    |
207 |         # Create brand registration
208 |         registration_id = f"brand_reg_{int(time.time())}"
209 |         expiry_date = datetime.utcnow() + timedelta(days=365)
    |                       ^^^^^^^^^^^^^^^^^
210 |
211 |         brand_prefix = BrandPrefix(
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/commercial/commercial_module.py:217:31
    |
215 |             commercial_tier=commercial_tier,
216 |             status=BrandStatus.PENDING,
217 |             registration_date=datetime.utcnow(),
    |                               ^^^^^^^^^^^^^^^^^
218 |             expiry_date=expiry_date,
219 |             verification_documents=verification_documents,
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/commercial/commercial_module.py:331:33
    |
329 |                 brand_prefix=brand_code,
330 |                 commercial_tier=commercial_tier,
331 |                 generation_time=datetime.utcnow(),
    |                                 ^^^^^^^^^^^^^^^^^
332 |                 entropy_score=entropy_score,
333 |                 validation_result=validation_result.__dict__,
    |
help: Use `datetime.datetime.now(tz=...)` instead

ARG002 Unused method argument: `user_context`
   --> candidate/governance/identity/core/commercial/commercial_module.py:349:9
    |
347 |         brand_code: str,
348 |         tier: int,
349 |         user_context: dict[str, Any],
    |         ^^^^^^^^^^^^
350 |         options: Optional[dict[str, Any]],
351 |     ) -> str:
    |

ARG002 Unused method argument: `lambda_id`
   --> candidate/governance/identity/core/commercial/commercial_module.py:465:52
    |
463 |         return f"{custom_prefix}{brand_code}-{enhanced_tier}-{timestamp_hash}-{symbolic_char}-{entropy_hash}"
464 |
465 |     def _update_usage_stats(self, brand_code: str, lambda_id: str):
    |                                                    ^^^^^^^^^
466 |         """Update usage statistics for brand prefix."""
467 |         if brand_code in self.registered_brands:
    |

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/commercial/commercial_module.py:470:46
    |
468 |             brand = self.registered_brands[brand_code]
469 |             brand.usage_stats["lambda_ids_generated"] += 1
470 |             brand.usage_stats["last_used"] = datetime.utcnow()
    |                                              ^^^^^^^^^^^^^^^^^
471 |
472 |             # Track daily usage
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/commercial/commercial_module.py:473:21
    |
472 |             # Track daily usage
473 |             today = datetime.utcnow().strftime("%Y-%m-%d")
    |                     ^^^^^^^^^^^^^^^^^
474 |             if brand_code not in self.usage_tracking:
475 |                 self.usage_tracking[brand_code] = {}
    |
help: Use `datetime.datetime.now(tz=...)` instead

ARG002 Unused method argument: `user_context`
   --> candidate/governance/identity/core/commercial/commercial_module.py:480:61
    |
478 |             self.usage_tracking[brand_code][today] += 1
479 |
480 |     def _calculate_billing(self, brand_prefix: BrandPrefix, user_context: dict[str, Any]) -> dict[str, Any]:
    |                                                             ^^^^^^^^^^^^
481 |         """Calculate billing information for commercial Î›iD generation."""
482 |         tier_config = self.config["commercial_tiers"][brand_prefix.commercial_tier.value]
    |

ARG002 Unused method argument: `lambda_id`
   --> candidate/governance/identity/core/commercial/commercial_module.py:603:15
    |
602 |     def _validate_commercial_specific(
603 |         self, lambda_id: str, commercial_info: dict[str, Any], brand_prefix: BrandPrefix
    |               ^^^^^^^^^
604 |     ) -> dict[str, Any]:
605 |         """Perform commercial-specific validation checks."""
    |

SIM105 Use `contextlib.suppress(Exception)` instead of `try`-`except`-`pass`
  --> candidate/governance/identity/core/events/__init__.py:55:13
   |
53 |           self.event_history.append(event)
54 |           for subscriber in self.subscribers:
55 | /             try:
56 | |                 subscriber(event)
57 | |             except Exception:
58 | |                 # Log but don't fail
59 | |                 pass
   | |____________________^
60 |
61 |       def subscribe(self, handler):
   |
help: Replace with `contextlib.suppress(Exception)`

PERF203 `try`-`except` within a loop incurs performance overhead
  --> candidate/governance/identity/core/events/__init__.py:57:13
   |
55 |               try:
56 |                   subscriber(event)
57 | /             except Exception:
58 | |                 # Log but don't fail
59 | |                 pass
   | |____________________^
60 |
61 |       def subscribe(self, handler):
   |

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/events/identity_event_publisher.py:99:30
    |
 97 |                 "requires_monitoring": auth_context.risk_score > 0.7,
 98 |             },
 99 |             processing_start=datetime.utcnow(),
    |                              ^^^^^^^^^^^^^^^^^
100 |         )
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/events/identity_event_publisher.py:365:41
    |
363 |             data={
364 |                 "activated_benefits": benefits,
365 |                 "activation_timestamp": datetime.utcnow().isoformat(),
    |                                         ^^^^^^^^^^^^^^^^^
366 |             },
367 |         )
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/events/identity_event_publisher.py:380:36
    |
378 |         # Calculate processing duration if end time is set
379 |         if event.processing_start:
380 |             event.processing_end = datetime.utcnow()
    |                                    ^^^^^^^^^^^^^^^^^
381 |             event.calculate_processing_duration()
    |
help: Use `datetime.datetime.now(tz=...)` instead

PERF203 `try`-`except` within a loop incurs performance overhead
   --> candidate/governance/identity/core/events/identity_event_publisher.py:422:17
    |
420 |                   try:
421 |                       await handler(event)
422 | /                 except Exception as e:
423 | |                     logger.error(f"Event handler error: {e}")
    | |_____________________________________________________________^
424 |
425 |       async def _setup_event_subscriptions(self):
    |

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/glyph/distributed_glyph_generation.py:132:22
    |
130 |         """Generate a GLYPH fragment based on specialization."""
131 |
132 |         start_time = datetime.utcnow()
    |                      ^^^^^^^^^^^^^^^^^
133 |
134 |         try:
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/glyph/distributed_glyph_generation.py:162:34
    |
160 |                     "generation_params": fragment_params,
161 |                 },
162 |                 generation_time=(datetime.utcnow() - start_time).total_seconds(),
    |                                  ^^^^^^^^^^^^^^^^^
163 |                 quality_score=quality_score,
164 |             )
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/glyph/distributed_glyph_generation.py:299:30
    |
297 |                 "tier_level": task.tier_level,
298 |                 "glyph_type": task.glyph_type.value,
299 |                 "timestamp": datetime.utcnow().isoformat(),
    |                              ^^^^^^^^^^^^^^^^^
300 |                 **task.steganographic_data,
301 |             }
    |
help: Use `datetime.datetime.now(tz=...)` instead

ARG002 Unused method argument: `consciousness_data`
   --> candidate/governance/identity/core/glyph/distributed_glyph_generation.py:461:42
    |
459 |         return pattern
460 |
461 |     def _encode_consciousness_data(self, consciousness_data: np.ndarray, size: tuple[int, int]) -> np.ndarray:
    |                                          ^^^^^^^^^^^^^^^^^^
462 |         """Encode consciousness data into visual pattern."""
463 |         # This would implement actual consciousness encoding
    |

ARG002 Unused method argument: `dream_sequence`
   --> candidate/governance/identity/core/glyph/distributed_glyph_generation.py:466:57
    |
464 |         return self._create_default_consciousness_pattern(size)
465 |
466 |     def _overlay_dream_patterns(self, base: np.ndarray, dream_sequence: list[dict[str, Any]]) -> np.ndarray:
    |                                                         ^^^^^^^^^^^^^^
467 |         """Overlay dream sequence patterns."""
468 |         # This would implement dream pattern overlay
    |

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/glyph/distributed_glyph_generation.py:592:65
    |
590 |         # Create generation task
591 |         task = GLYPHGenerationTask(
592 |             task_id=f"glyph_{lambda_id}_{glyph_type.value}_{int(datetime.utcnow().timestamp())}",
    |                                                                 ^^^^^^^^^^^^^^^^^
593 |             lambda_id=lambda_id,
594 |             glyph_type=glyph_type,
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/glyph/distributed_glyph_generation.py:600:22
    |
598 |             orb_state=orb_state,
599 |             steganographic_data=steganographic_data,
600 |             deadline=datetime.utcnow() + timedelta(seconds=self.assembly_timeout),
    |                      ^^^^^^^^^^^^^^^^^
601 |         )
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/glyph/distributed_glyph_generation.py:674:17
    |
672 |             # Update metrics
673 |             generation_time = (
674 |                 datetime.utcnow() - task.deadline + timedelta(seconds=self.assembly_timeout)
    |                 ^^^^^^^^^^^^^^^^^
675 |             ).total_seconds()
676 |             self.average_generation_time = (
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/glyph/distributed_glyph_generation.py:754:70
    |
752 |         # Create GLYPH
753 |         glyph = GeneratedGLYPH(
754 |             glyph_id=f"{task.lambda_id}_{task.glyph_type.value}_{int(datetime.utcnow().timestamp())}",
    |                                                                      ^^^^^^^^^^^^^^^^^
755 |             lambda_id=task.lambda_id,
756 |             glyph_type=task.glyph_type,
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/glyph/distributed_glyph_generation.py:770:23
    |
768 |             consensus_achieved=len(selected_fragments) >= len(fragments_by_type) * 0.8,
769 |             quality_metrics=quality_metrics,
770 |             timestamp=datetime.utcnow(),
    |                       ^^^^^^^^^^^^^^^^^
771 |         )
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/glyph/distributed_glyph_generation.py:904:62
    |
902 |         """Generate quantum seed for GLYPH generation."""
903 |         # Combine identity and session for uniqueness
904 |         seed_data = f"{lambda_id}:{session_id or 'default'}:{datetime.utcnow().isoformat()}"
    |                                                              ^^^^^^^^^^^^^^^^^
905 |         return hashlib.sha256(seed_data.encode()).digest()
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/glyph/glyph_pipeline.py:273:45
    |
271 |                     "qrg_type": qrg_type.value,
272 |                     "processing_time": processing_time,
273 |                     "generation_timestamp": datetime.now().isoformat(),
    |                                             ^^^^^^^^^^^^^^
274 |                     "pipeline_version": "1.0.0",
275 |                 },
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/glyph/glyph_pipeline.py:343:39
    |
341 |             "steganographic_verified": steganographic_verified,
342 |             "identity_verified": identity_verified,
343 |             "verification_timestamp": datetime.now().isoformat(),
    |                                       ^^^^^^^^^^^^^^
344 |             "glyph_metadata": glyph_result.generation_metadata,
345 |         }
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/glyph/glyph_pipeline.py:361:37
    |
359 |             "glyph_type": request.glyph_type.value,
360 |             "security_level": request.security_level.value,
361 |             "generation_timestamp": datetime.now().isoformat(),
    |                                     ^^^^^^^^^^^^^^
362 |         }
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/glyph/glyph_pipeline.py:393:23
    |
392 |         # Add expiry
393 |         expiry_time = datetime.now() + timedelta(hours=request.expiry_hours)
    |                       ^^^^^^^^^^^^^^
394 |         identity_data["expires_at"] = expiry_time.isoformat()
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

F821 Undefined name `timedelta`
   --> candidate/governance/identity/core/glyph/glyph_pipeline.py:393:40
    |
392 |         # Add expiry
393 |         expiry_time = datetime.now() + timedelta(hours=request.expiry_hours)
    |                                        ^^^^^^^^^
394 |         identity_data["expires_at"] = expiry_time.isoformat()
    |

ARG002 Unused method argument: `identity_data`
   --> candidate/governance/identity/core/glyph/glyph_pipeline.py:472:9
    |
470 |         base_glyph: dict[str, Any],
471 |         request: GLYPHGenerationRequest,
472 |         identity_data: dict[str, Any],
    |         ^^^^^^^^^^^^^
473 |     ) -> dict[str, Any]:
474 |         """Embed identity features into the GLYPH"""
    |

ARG002 Unused method argument: `request`
   --> candidate/governance/identity/core/glyph/glyph_pipeline.py:621:9
    |
619 |         glyph: dict[str, Any],
620 |         orb_visualization: Optional[dict[str, Any]],
621 |         request: GLYPHGenerationRequest,
    |         ^^^^^^^
622 |     ) -> Optional[Image.Image]:
623 |         """Create final GLYPH image with all enhancements"""
    |

ARG002 Unused method argument: `glyph_data`
   --> candidate/governance/identity/core/glyph/glyph_pipeline.py:668:9
    |
666 |         self,
667 |         signature: str,
668 |         glyph_data: dict[str, Any],
    |         ^^^^^^^^^^
669 |         verification_data: dict[str, Any],
670 |     ) -> bool:
    |

ARG002 Unused method argument: `verification_data`
   --> candidate/governance/identity/core/glyph/glyph_pipeline.py:669:9
    |
667 |         signature: str,
668 |         glyph_data: dict[str, Any],
669 |         verification_data: dict[str, Any],
    |         ^^^^^^^^^^^^^^^^^
670 |     ) -> bool:
671 |         """Verify quantum signature"""
    |

ARG002 Unused method argument: `verification_data`
   --> candidate/governance/identity/core/glyph/glyph_pipeline.py:676:69
    |
674 |         return bool(signature)
675 |
676 |     def _verify_steganographic_layers(self, layers: dict[str, Any], verification_data: dict[str, Any]) -> bool:
    |                                                                     ^^^^^^^^^^^^^^^^^
677 |         """Verify steganographic layers"""
678 |         # This would verify the steganographic embedding
    |

ARG002 Unused method argument: `verification_data`
   --> candidate/governance/identity/core/glyph/glyph_pipeline.py:681:69
    |
679 |         return layers.get("data_integrity", True)
680 |
681 |     def _verify_identity_embedding(self, embedding: dict[str, Any], verification_data: dict[str, Any]) -> bool:
    |                                                                     ^^^^^^^^^^^^^^^^^
682 |         """Verify identity embedding"""
683 |         # Basic verification of identity embedding
    |

ARG002 Unused method argument: `strength`
   --> candidate/governance/identity/core/glyph/steganographic_id.py:329:59
    |
327 |         return fernet.decrypt(encrypted_data)
328 |
329 |     def _embed_lsb(self, image: Image.Image, data: bytes, strength: EmbeddingStrength) -> dict[str, Any]:
    |                                                           ^^^^^^^^
330 |         """Embed data using LSB method"""
331 |         img_array = np.array(image.convert("RGB"))
    |

SIM102 Use a single `if` statement instead of nested `if` statements
   --> candidate/governance/identity/core/glyph/steganographic_id.py:404:17
    |
402 |                   # Apply quantum noise for detection resistance
403 |                   qi_noise = self._get_quantum_entropy(1)[0] & 0x01
404 | /                 if strength == EmbeddingStrength.QUANTUM:
405 | |                     # Add quantum countermeasures
406 | |                     if qi_noise:
    | |________________________________^
407 |                           # Occasionally flip adjacent bits to confuse detectors
408 |                           adjacent_pos = self._get_adjacent_position(i, j, k, img_array.shape)
    |
help: Combine `if` statements using `and`

ARG002 Unused method argument: `strength`
   --> candidate/governance/identity/core/glyph/steganographic_id.py:466:59
    |
464 |         }
465 |
466 |     def _embed_dct(self, image: Image.Image, data: bytes, strength: EmbeddingStrength) -> dict[str, Any]:
    |                                                           ^^^^^^^^
467 |         """Embed data using DCT (Discrete Cosine Transform) method"""
468 |         # This is a simplified DCT embedding
    |

ARG002 Unused method argument: `strength`
   --> candidate/governance/identity/core/glyph/steganographic_id.py:513:63
    |
511 |         }
512 |
513 |     def _embed_fractal(self, image: Image.Image, data: bytes, strength: EmbeddingStrength) -> dict[str, Any]:
    |                                                               ^^^^^^^^
514 |         """Embed data using fractal-based method"""
515 |         # Simplified fractal embedding
    |

DTZ003 `datetime.datetime.utcnow()` used
  --> candidate/governance/identity/core/health/identity_health_monitor.py:75:49
   |
73 |     def add_error(self, error: str):
74 |         """Add error to history."""
75 |         self.error_history.append({"timestamp": datetime.utcnow(), "error": error})
   |                                                 ^^^^^^^^^^^^^^^^^
76 |
77 |     def calculate_health_score(self) -> float:
   |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/health/identity_health_monitor.py:109:71
    |
107 |         # Consider error history
108 |         recent_errors = sum(
109 |             1 for error in self.error_history if error["timestamp"] > datetime.utcnow() - timedelta(minutes=5)
    |                                                                       ^^^^^^^^^^^^^^^^^
110 |         )
111 |         if recent_errors > 10:
    |
help: Use `datetime.datetime.now(tz=...)` instead

RUF006 Store a reference to the return value of `asyncio.create_task`
   --> candidate/governance/identity/core/health/identity_health_monitor.py:215:9
    |
214 |         # Start monitoring tasks
215 |         asyncio.create_task(self._monitor_system_health())
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
216 |         asyncio.create_task(self._monitor_component_health())
217 |         asyncio.create_task(self._execute_healing_plans())
    |

RUF006 Store a reference to the return value of `asyncio.create_task`
   --> candidate/governance/identity/core/health/identity_health_monitor.py:216:9
    |
214 |         # Start monitoring tasks
215 |         asyncio.create_task(self._monitor_system_health())
216 |         asyncio.create_task(self._monitor_component_health())
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
217 |         asyncio.create_task(self._execute_healing_plans())
218 |         asyncio.create_task(self._analyze_health_trends())
    |

RUF006 Store a reference to the return value of `asyncio.create_task`
   --> candidate/governance/identity/core/health/identity_health_monitor.py:217:9
    |
215 |         asyncio.create_task(self._monitor_system_health())
216 |         asyncio.create_task(self._monitor_component_health())
217 |         asyncio.create_task(self._execute_healing_plans())
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
218 |         asyncio.create_task(self._analyze_health_trends())
    |

RUF006 Store a reference to the return value of `asyncio.create_task`
   --> candidate/governance/identity/core/health/identity_health_monitor.py:218:9
    |
216 |         asyncio.create_task(self._monitor_component_health())
217 |         asyncio.create_task(self._execute_healing_plans())
218 |         asyncio.create_task(self._analyze_health_trends())
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
219 |
220 |         logger.info("Identity Health Monitor initialized")
    |

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/health/identity_health_monitor.py:237:28
    |
235 |                 status=HealthStatus.HEALTHY,
236 |                 health_score=1.0,
237 |                 last_check=datetime.utcnow(),
    |                            ^^^^^^^^^^^^^^^^^
238 |                 metrics={},
239 |             )
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/health/identity_health_monitor.py:247:30
    |
245 |         # Initialize tier-specific data
246 |         self.component_health[component_id].tier_specific_data[tier_level] = {
247 |             "registered_at": datetime.utcnow(),
    |                              ^^^^^^^^^^^^^^^^^
248 |             "performance_baseline": {},
249 |         }
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/health/identity_health_monitor.py:264:32
    |
262 |         component = self.component_health[component_id]
263 |         component.metrics.update(metrics)
264 |         component.last_check = datetime.utcnow()
    |                                ^^^^^^^^^^^^^^^^^
265 |
266 |         # Update tier-specific metrics
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/health/identity_health_monitor.py:271:67
    |
270 |         component.tier_specific_data[tier_level]["last_metrics"] = metrics
271 |         component.tier_specific_data[tier_level]["last_update"] = datetime.utcnow()
    |                                                                   ^^^^^^^^^^^^^^^^^
272 |
273 |         # Calculate new health score
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/health/identity_health_monitor.py:294:30
    |
292 |         self.health_history.append(
293 |             {
294 |                 "timestamp": datetime.utcnow(),
    |                              ^^^^^^^^^^^^^^^^^
295 |                 "component_id": component_id,
296 |                 "health_score": component.health_score,
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/health/identity_health_monitor.py:329:69
    |
327 |         # Update error rate metric
328 |         error_count = len(
329 |             [e for e in component.error_history if e["timestamp"] > datetime.utcnow() - timedelta(minutes=5)]
    |                                                                     ^^^^^^^^^^^^^^^^^
330 |         )
331 |         # Errors per second over 5 minutes
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/health/identity_health_monitor.py:359:39
    |
358 |         # Check healing cooldown
359 |         if component.last_healing and datetime.utcnow() - component.last_healing < timedelta(minutes=5):
    |                                       ^^^^^^^^^^^^^^^^^
360 |             logger.info(f"Component {component_id} in healing cooldown")
361 |             return
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/health/identity_health_monitor.py:365:48
    |
363 |         # Create healing plan
364 |         plan = HealingPlan(
365 |             plan_id=f"heal_{component_id}_{int(datetime.utcnow().timestamp())}",
    |                                                ^^^^^^^^^^^^^^^^^
366 |             component_id=component_id,
367 |             component_type=component.component_type,
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/health/identity_health_monitor.py:372:22
    |
370 |             steps=[],
371 |             priority=priority,
372 |             deadline=datetime.utcnow() + timedelta(minutes=30),
    |                      ^^^^^^^^^^^^^^^^^
373 |         )
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/health/identity_health_monitor.py:385:34
    |
383 |         self.active_healing_plans[plan.plan_id] = plan
384 |         component.healing_attempts += 1
385 |         component.last_healing = datetime.utcnow()
    |                                  ^^^^^^^^^^^^^^^^^
386 |
387 |         # Publish healing event
    |
help: Use `datetime.datetime.now(tz=...)` instead

ARG002 Unused method argument: `tier_level`
   --> candidate/governance/identity/core/health/identity_health_monitor.py:443:80
    |
441 |         ]
442 |
443 |     async def _heal_colony_agent_replacement(self, component: ComponentHealth, tier_level: int) -> list[dict[str, Any]]:
    |                                                                                ^^^^^^^^^^
444 |         """Replace unhealthy agents in colony."""
445 |         return [
    |

ARG002 Unused method argument: `tier_level`
   --> candidate/governance/identity/core/health/identity_health_monitor.py:469:43
    |
468 |     async def _heal_colony_consensus_adjustment(
469 |         self, component: ComponentHealth, tier_level: int
    |                                           ^^^^^^^^^^
470 |     ) -> list[dict[str, Any]]:
471 |         """Adjust consensus parameters for better performance."""
    |

ARG002 Unused method argument: `tier_level`
   --> candidate/governance/identity/core/health/identity_health_monitor.py:494:43
    |
493 |     async def _heal_swarm_task_redistribution(
494 |         self, component: ComponentHealth, tier_level: int
    |                                           ^^^^^^^^^^
495 |     ) -> list[dict[str, Any]]:
496 |         """Redistribute tasks in swarm hub."""
    |

ARG002 Unused method argument: `tier_level`
   --> candidate/governance/identity/core/health/identity_health_monitor.py:543:72
    |
541 |         ]
542 |
543 |     async def _heal_auth_cache_clear(self, component: ComponentHealth, tier_level: int) -> list[dict[str, Any]]:
    |                                                                        ^^^^^^^^^^
544 |         """Clear authentication caches."""
545 |         return [
    |

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/health/identity_health_monitor.py:594:24
    |
592 |                 for plan_id, plan in self.active_healing_plans.items():
593 |                     # Check deadline
594 |                     if datetime.utcnow() > plan.deadline:
    |                        ^^^^^^^^^^^^^^^^^
595 |                         logger.error(f"Healing plan {plan_id} exceeded deadline")
596 |                         completed_plans.append(plan_id)
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/health/identity_health_monitor.py:614:51
    |
612 |                     try:
613 |                         next_step["status"] = "executing"
614 |                         next_step["started_at"] = datetime.utcnow()
    |                                                   ^^^^^^^^^^^^^^^^^
615 |
616 |                         # Execute healing action
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/health/identity_health_monitor.py:624:53
    |
623 |                         next_step["status"] = "completed"
624 |                         next_step["completed_at"] = datetime.utcnow()
    |                                                     ^^^^^^^^^^^^^^^^^
625 |                         next_step["result"] = result
    |
help: Use `datetime.datetime.now(tz=...)` instead

ARG002 Unused method argument: `component_type`
   --> candidate/governance/identity/core/health/identity_health_monitor.py:652:82
    |
650 |                 await asyncio.sleep(5)
651 |
652 |     async def _execute_healing_action(self, action: str, params: dict[str, Any], component_type: ComponentType) -> Any:
    |                                                                                  ^^^^^^^^^^^^^^
653 |         """Execute a specific healing action."""
    |

PERF203 `try`-`except` within a loop incurs performance overhead
   --> candidate/governance/identity/core/health/identity_health_monitor.py:683:13
    |
681 |                   await asyncio.sleep(10)  # Check every 10 seconds
682 |
683 | /             except Exception as e:
684 | |                 logger.error(f"System health monitor error: {e}")
685 | |                 await asyncio.sleep(10)
    | |_______________________________________^
686 |
687 |       async def _monitor_component_health(self):
    |

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/health/identity_health_monitor.py:706:24
    |
705 |                     # Check for stale components
706 |                     if datetime.utcnow() - component.last_check > timedelta(minutes=5):
    |                        ^^^^^^^^^^^^^^^^^
707 |                         component.status = HealthStatus.UNKNOWN
708 |                         logger.warning(f"Component {component_id} health check stale")
    |
help: Use `datetime.datetime.now(tz=...)` instead

PERF203 `try`-`except` within a loop incurs performance overhead
   --> candidate/governance/identity/core/health/identity_health_monitor.py:712:13
    |
710 |                   await asyncio.sleep(30)  # Check every 30 seconds
711 |
712 | /             except Exception as e:
713 | |                 logger.error(f"Component health monitor error: {e}")
714 | |                 await asyncio.sleep(30)
    | |_______________________________________^
715 |
716 |       async def _analyze_health_trends(self):
    |

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/health/identity_health_monitor.py:722:72
    |
720 |                 # Analyze recent health history
721 |                 recent_history = [
722 |                     h for h in self.health_history if h["timestamp"] > datetime.utcnow() - timedelta(hours=1)
    |                                                                        ^^^^^^^^^^^^^^^^^
723 |                 ]
    |
help: Use `datetime.datetime.now(tz=...)` instead

PERF203 `try`-`except` within a loop incurs performance overhead
   --> candidate/governance/identity/core/health/identity_health_monitor.py:755:13
    |
753 |                   await asyncio.sleep(300)  # Analyze every 5 minutes
754 |
755 | /             except Exception as e:
756 | |                 logger.error(f"Health trend analysis error: {e}")
757 | |                 await asyncio.sleep(300)
    | |________________________________________^
758 |
759 |       async def _trigger_system_healing(self, reason: str):
    |

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/health/identity_health_monitor.py:841:73
    |
839 |             "metrics": {k.value: v for k, v in component.metrics.items()},
840 |             "recent_errors": len(
841 |                 [e for e in component.error_history if e["timestamp"] > datetime.utcnow() - timedelta(hours=1)]
    |                                                                         ^^^^^^^^^^^^^^^^^
842 |             ),
843 |             "healing_attempts": component.healing_attempts,
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/id_service/entropy_engine.py:150:32
    |
148 |             # Add metadata
149 |             analysis.metadata = {
150 |                 "analyzed_at": datetime.now().isoformat(),
    |                                ^^^^^^^^^^^^^^
151 |                 "tier": tier,
152 |                 "component_count": len(analysis.component_scores),
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

E501 Line too long (121 > 120)
   --> candidate/governance/identity/core/id_service/entropy_engine.py:445:121
    |
443 |             if analysis.overall_score < tier_config.get("recommended", 2.0):
444 |                 recommendations.append(
445 |                     f"Aim for entropy score of {tier_config.get('recommended', 2.0)} for optimal Tier {tier} performance"
    |                                                                                                                         ^
446 |                 )
    |

ARG002 Unused method argument: `partial_id`
   --> candidate/governance/identity/core/id_service/entropy_engine.py:450:42
    |
448 |         analysis.recommendations = recommendations
449 |
450 |     def _generate_live_suggestions(self, partial_id: str, current_score: float, target_score: float) -> list[str]:
    |                                          ^^^^^^^^^^
451 |         """Generate real-time suggestions during Î›iD construction"""
452 |         suggestions = []
    |

ARG002 Unused method argument: `config_path`
   --> candidate/governance/identity/core/id_service/entropy_engine.py:558:28
    |
556 |         return tier_symbols.get(tier, [])
557 |
558 |     def _load_config(self, config_path: Optional[str] = None) -> dict[str, Any]:
    |                            ^^^^^^^^^^^
559 |         """Load entropy engine configuration"""
560 |         return {
    |

E402 Module level import not at top of file
  --> candidate/governance/identity/core/id_service/lambd_id_entropy.py:32:1
   |
30 | """
31 |
32 | import math
   | ^^^^^^^^^^^
33 | import re
34 | import statistics
   |

E402 Module level import not at top of file
  --> candidate/governance/identity/core/id_service/lambd_id_entropy.py:33:1
   |
32 | import math
33 | import re
   | ^^^^^^^^^
34 | import statistics
35 | from collections import Counter
   |

E402 Module level import not at top of file
  --> candidate/governance/identity/core/id_service/lambd_id_entropy.py:34:1
   |
32 | import math
33 | import re
34 | import statistics
   | ^^^^^^^^^^^^^^^^^
35 | from collections import Counter
36 | from datetime import datetime
   |

E402 Module level import not at top of file
  --> candidate/governance/identity/core/id_service/lambd_id_entropy.py:35:1
   |
33 | import re
34 | import statistics
35 | from collections import Counter
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
36 | from datetime import datetime
37 | from enum import Enum
   |

E402 Module level import not at top of file
  --> candidate/governance/identity/core/id_service/lambd_id_entropy.py:36:1
   |
34 | import statistics
35 | from collections import Counter
36 | from datetime import datetime
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
37 | from enum import Enum
38 | from typing import Optional
   |

E402 Module level import not at top of file
  --> candidate/governance/identity/core/id_service/lambd_id_entropy.py:37:1
   |
35 | from collections import Counter
36 | from datetime import datetime
37 | from enum import Enum
   | ^^^^^^^^^^^^^^^^^^^^^
38 | from typing import Optional
   |

E402 Module level import not at top of file
  --> candidate/governance/identity/core/id_service/lambd_id_entropy.py:38:1
   |
36 | from datetime import datetime
37 | from enum import Enum
38 | from typing import Optional
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |

ARG002 Unused method argument: `symbolic_char`
   --> candidate/governance/identity/core/id_service/lambd_id_entropy.py:181:41
    |
179 |         return self._calculate_shannon_entropy(component)
180 |
181 |     def _analyze_symbolic_entropy(self, symbolic_char: str, tier: int) -> float:
    |                                         ^^^^^^^^^^^^^
182 |         """Analyze entropy contribution of symbolic character"""
183 |         tier_symbols = self.tier_requirements.get(f"tier_{tier}", {}).get("symbols", [])
    |

E501 Line too long (130 > 120)
   --> candidate/governance/identity/core/id_service/lambd_id_entropy.py:360:121
    |
358 |         if analysis.normalized_entropy < tier_min_entropy:
359 |             recommendations.append(
360 |                 f"Increase entropy for Tier {tier} (current: {analysis.normalized_entropy:.2f}, required: {tier_min_entropy:.2f})"
    |                                                                                                                         ^^^^^^^^^^
361 |             )
    |

ARG002 Unused method argument: `components`
   --> candidate/governance/identity/core/id_service/lambd_id_entropy.py:374:67
    |
372 |         return recommendations
373 |
374 |     def _detect_entropy_warnings(self, analysis: EntropyAnalysis, components: tuple) -> list[str]:
    |                                                                   ^^^^^^^^^^
375 |         """Detect entropy-related warnings"""
376 |         warnings = []
    |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/id_service/lambd_id_entropy.py:408:30
    |
406 |         self.entropy_history.append(
407 |             {
408 |                 "timestamp": datetime.now().isoformat(),
    |                              ^^^^^^^^^^^^^^
409 |                 "lambda_id": lambda_id,
410 |                 "shannon_entropy": analysis.shannon_entropy,
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

ARG002 Unused method argument: `config_path`
   --> candidate/governance/identity/core/id_service/lambd_id_entropy.py:436:28
    |
434 |         }
435 |
436 |     def _load_config(self, config_path: Optional[str] = None) -> dict:
    |                            ^^^^^^^^^^^
437 |         """Load entropy engine configuration"""
438 |         return {
    |

E402 Module level import not at top of file
  --> candidate/governance/identity/core/id_service/lambd_id_generator.py:13:1
   |
12 | __all__ = ["LambdIDGenerator", "LambdaIDGenerator"]
13 | import hashlib
   | ^^^^^^^^^^^^^^
14 | import json
15 | import secrets
   |

E402 Module level import not at top of file
  --> candidate/governance/identity/core/id_service/lambd_id_generator.py:14:1
   |
12 | __all__ = ["LambdIDGenerator", "LambdaIDGenerator"]
13 | import hashlib
14 | import json
   | ^^^^^^^^^^^
15 | import secrets
16 | import time
   |

E402 Module level import not at top of file
  --> candidate/governance/identity/core/id_service/lambd_id_generator.py:15:1
   |
13 | import hashlib
14 | import json
15 | import secrets
   | ^^^^^^^^^^^^^^
16 | import time
17 | from datetime import datetime
   |

E402 Module level import not at top of file
  --> candidate/governance/identity/core/id_service/lambd_id_generator.py:16:1
   |
14 | import json
15 | import secrets
16 | import time
   | ^^^^^^^^^^^
17 | from datetime import datetime
18 | from enum import Enum
   |

E402 Module level import not at top of file
  --> candidate/governance/identity/core/id_service/lambd_id_generator.py:17:1
   |
15 | import secrets
16 | import time
17 | from datetime import datetime
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
18 | from enum import Enum
19 | from typing import Optional
   |

E402 Module level import not at top of file
  --> candidate/governance/identity/core/id_service/lambd_id_generator.py:18:1
   |
16 | import time
17 | from datetime import datetime
18 | from enum import Enum
   | ^^^^^^^^^^^^^^^^^^^^^
19 | from typing import Optional
   |

E402 Module level import not at top of file
  --> candidate/governance/identity/core/id_service/lambd_id_generator.py:19:1
   |
17 | from datetime import datetime
18 | from enum import Enum
19 | from typing import Optional
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/id_service/lambd_id_generator.py:154:42
    |
153 |         # Add tier-specific salt
154 |         tier_salt = f"tier_{tier.value}_{datetime.now().isoformat()}"
    |                                          ^^^^^^^^^^^^^^
155 |         combined_entropy = base_entropy + tier_salt
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

ARG002 Unused method argument: `config_path`
   --> candidate/governance/identity/core/id_service/lambd_id_generator.py:175:28
    |
173 |         return self.generate_lambda_id(tier, collision_context, symbolic_preference)
174 |
175 |     def _load_config(self, config_path: Optional[str] = None) -> dict:
    |                            ^^^^^^^^^^^
176 |         """Load Î›iD generation configuration"""
177 |         # TODO: Load from actual config file
    |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/id_service/lambd_id_generator.py:207:26
    |
205 |         """Log Î›iD generation event for audit trail"""
206 |         {
207 |             "timestamp": datetime.now().isoformat(),
    |                          ^^^^^^^^^^^^^^
208 |             "lambda_id": lambda_id,
209 |             "tier": tier.value,
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

PERF401 Use a list comprehension to create a transformed list
   --> candidate/governance/identity/core/id_service/lambd_id_validator.py:418:17
    |
416 |             # Convert hex to digits
417 |             for char in timestamp_hash + entropy_hash:
418 |                 numeric_parts.append(int(char, 16))
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
419 |
420 |             # Add tier as modifier
    |
help: Replace for loop with list comprehension

ARG002 Unused method argument: `config_path`
   --> candidate/governance/identity/core/id_service/lambd_id_validator.py:511:28
    |
509 |         }
510 |
511 |     def _load_config(self, config_path: Optional[str] = None) -> dict:
    |                            ^^^^^^^^^^^
512 |         """Load validator configuration"""
513 |         return {
    |

ARG002 Unused method argument: `passphrase`
  --> candidate/governance/identity/core/id_service/mnemonic.py:37:33
   |
35 |         return " ".join(self.wordlist[: min(word_count, len(self.wordlist))])
36 |
37 |     def to_seed(self, mnemonic, passphrase=""):
   |                                 ^^^^^^^^^^
38 |         """Convert mnemonic to seed (mock implementation)."""
39 |         # Mock implementation - returns a fake seed
   |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/id_service/portability_system.py:169:30
    |
167 |         package.geo_location = geo_location
168 |         package.security_level = security_level
169 |         package.created_at = datetime.now()
    |                              ^^^^^^^^^^^^^^
170 |         package.expiry_date = self._calculate_expiry_date(security_level)
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/id_service/portability_system.py:241:24
    |
239 |             "location": geo_location,
240 |             "security_level": security_level,
241 |             "expiry": (datetime.now() + timedelta(days=365)).isoformat(),
    |                        ^^^^^^^^^^^^^^
242 |             "recovery_instructions": self._get_qr_recovery_instructions(),
243 |         }
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/id_service/portability_system.py:261:29
    |
259 |         attempt.attempt_id = self._generate_attempt_id()
260 |         attempt.method = RecoveryMethod.QR_GEO
261 |         attempt.timestamp = datetime.now()
    |                             ^^^^^^^^^^^^^^
262 |         attempt.geo_location = current_location
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/id_service/portability_system.py:294:40
    |
292 |             # Check expiry
293 |             package = self.active_packages[lambda_id]
294 |             if package.expiry_date and datetime.now() > package.expiry_date:
    |                                        ^^^^^^^^^^^^^^
295 |                 attempt.status = RecoveryStatus.EXPIRED
296 |                 attempt.failure_reasons.append("Recovery package expired")
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/id_service/portability_system.py:363:29
    |
361 |         attempt.attempt_id = self._generate_attempt_id()
362 |         attempt.method = RecoveryMethod.EMERGENCY_CODE
363 |         attempt.timestamp = datetime.now()
    |                             ^^^^^^^^^^^^^^
364 |
365 |         # Search for matching Î›iD
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/id_service/portability_system.py:432:29
    |
430 |         attempt.attempt_id = self._generate_attempt_id()
431 |         attempt.method = RecoveryMethod.RECOVERY_PHRASE
432 |         attempt.timestamp = datetime.now()
    |                             ^^^^^^^^^^^^^^
433 |
434 |         try:
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/id_service/portability_system.py:481:31
    |
479 |             "source_device": source_device,
480 |             "target_devices": target_devices,
481 |             "sync_timestamp": datetime.now().isoformat(),
    |                               ^^^^^^^^^^^^^^
482 |             "successful_syncs": [],
483 |             "failed_syncs": [],
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/id_service/portability_system.py:529:33
    |
527 |             "lambda_id": lambda_id,
528 |             "package": package.to_dict(),
529 |             "backup_timestamp": datetime.now().isoformat(),
    |                                 ^^^^^^^^^^^^^^
530 |             "version": "1.0",
531 |         }
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/id_service/portability_system.py:538:80
    |
536 |         return {
537 |             "backup_file": base64.b64encode(encrypted_backup).decode(),
538 |             "filename": f"lambda_id_backup_{lambda_id.replace('LUKHAS', 'L')}_{datetime.now().strftime('%Y%m%d')}.lbak",
    |                                                                                ^^^^^^^^^^^^^^
539 |             "size_bytes": len(encrypted_backup),
540 |             "created_at": datetime.now().isoformat(),
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/id_service/portability_system.py:540:27
    |
538 |             "filename": f"lambda_id_backup_{lambda_id.replace('LUKHAS', 'L')}_{datetime.now().strftime('%Y%m%d')}.lbak",
539 |             "size_bytes": len(encrypted_backup),
540 |             "created_at": datetime.now().isoformat(),
    |                           ^^^^^^^^^^^^^^
541 |         }
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/id_service/portability_system.py:557:29
    |
555 |         attempt.attempt_id = self._generate_attempt_id()
556 |         attempt.method = RecoveryMethod.BACKUP_FILE
557 |         attempt.timestamp = datetime.now()
    |                             ^^^^^^^^^^^^^^
558 |
559 |         try:
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/id_service/portability_system.py:667:27
    |
665 |             "security_level": security_level,
666 |             "backup_version": "1.0",
667 |             "created_at": datetime.now().isoformat(),
    |                           ^^^^^^^^^^^^^^
668 |             "checksum": hashlib.sha256(lambda_id.encode()).hexdigest(),
669 |         }
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/id_service/portability_system.py:675:16
    |
673 |         days_mapping = {"standard": 365, "high": 730, "ultra": 1095}
674 |         days = days_mapping.get(security_level, 365)
675 |         return datetime.now() + timedelta(days=days)
    |                ^^^^^^^^^^^^^^
676 |
677 |     def _add_security_layer(self, payload: str, security_level: str) -> str:
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/id_service/portability_system.py:681:25
    |
679 |         if security_level == "high":
680 |             # Add timestamp and signature
681 |             timestamp = datetime.now().timestamp()
    |                         ^^^^^^^^^^^^^^
682 |             secured_payload = f"{payload}|{timestamp}"
683 |             return base64.b64encode(secured_payload.encode()).decode()
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

ARG002 Unused method argument: `lambda_id`
   --> candidate/governance/identity/core/id_service/portability_system.py:718:42
    |
716 |         }
717 |
718 |     def _verify_additional_factors(self, lambda_id: str, factors: dict[str, str]) -> bool:
    |                                          ^^^^^^^^^
719 |         """Verify additional authentication factors"""
720 |         # Placeholder for additional verification logic
    |

ARG002 Unused method argument: `factors`
   --> candidate/governance/identity/core/id_service/portability_system.py:718:58
    |
716 |         }
717 |
718 |     def _verify_additional_factors(self, lambda_id: str, factors: dict[str, str]) -> bool:
    |                                                          ^^^^^^^
719 |         """Verify additional authentication factors"""
720 |         # Placeholder for additional verification logic
    |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/id_service/portability_system.py:725:23
    |
723 |     def _generate_attempt_id(self) -> str:
724 |         """Generate unique attempt ID"""
725 |         return f"rec_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{secrets.token_hex(4)}"
    |                       ^^^^^^^^^^^^^^
726 |
727 |     def _get_qr_recovery_instructions(self) -> list[str]:
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

ARG002 Unused method argument: `device_id`
   --> candidate/governance/identity/core/id_service/portability_system.py:742:31
    |
740 |         return base64.b64encode(encrypted_data).decode()
741 |
742 |     def _sync_to_device(self, device_id: str, sync_package: str) -> bool:
    |                               ^^^^^^^^^
743 |         """Simulate device synchronization"""
744 |         # In real implementation, this would use device-specific protocols
    |

ARG002 Unused method argument: `sync_package`
   --> candidate/governance/identity/core/id_service/portability_system.py:742:47
    |
740 |         return base64.b64encode(encrypted_data).decode()
741 |
742 |     def _sync_to_device(self, device_id: str, sync_package: str) -> bool:
    |                                               ^^^^^^^^^^^^
743 |         """Simulate device synchronization"""
744 |         # In real implementation, this would use device-specific protocols
    |

ARG002 Unused method argument: `config_path`
   --> candidate/governance/identity/core/id_service/portability_system.py:803:28
    |
801 |         return Fernet.generate_key()
802 |
803 |     def _load_config(self, config_path: Optional[str] = None) -> dict[str, Any]:
    |                            ^^^^^^^^^^^
804 |         """Load portability system configuration"""
805 |         return {
    |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/id_service/portability_system.py:827:26
    |
825 |             "lambda_id": lambda_id,
826 |             "geo_location": geo_location,
827 |             "timestamp": datetime.now().timestamp(),
    |                          ^^^^^^^^^^^^^^
828 |         }
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/integrations/consciousness_bridge.py:168:27
    |
166 |                 lambda_id=lambda_id,
167 |                 sync_mode=sync_mode,
168 |                 last_sync=datetime.now(),
    |                           ^^^^^^^^^^^^^^
169 |                 sync_frequency=self._get_sync_frequency(sync_mode),
170 |                 coherence_score=1.0,
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/integrations/consciousness_bridge.py:174:39
    |
172 |                 anomaly_count=0,
173 |                 sync_metadata={
174 |                     "established_at": datetime.now().isoformat(),
    |                                       ^^^^^^^^^^^^^^
175 |                     "sync_mode": sync_mode.value,
176 |                     "initial_baseline": True,
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/integrations/consciousness_bridge.py:262:36
    |
261 |             # Update sync state
262 |             sync_state.last_sync = datetime.now()
    |                                    ^^^^^^^^^^^^^^
263 |             sync_state.coherence_score = coherence_analysis["coherence_score"]
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/integrations/consciousness_bridge.py:322:27
    |
321 |             # Filter by time window
322 |             cutoff_time = datetime.now() - analysis_window
    |                           ^^^^^^^^^^^^^^
323 |             recent_states = [
324 |                 state
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ006 `datetime.datetime.fromtimestamp()` called without a `tz` argument
   --> candidate/governance/identity/core/integrations/consciousness_bridge.py:326:20
    |
324 |                 state
325 |                 for state in user_states[-100:]  # Last 100 states
326 |                 if datetime.fromtimestamp(state.timestamp) >= cutoff_time
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
327 |             ]
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

ARG002 Unused method argument: `lambda_id`
   --> candidate/governance/identity/core/integrations/consciousness_bridge.py:481:37
    |
479 |         return True
480 |
481 |     def _perform_initial_sync(self, lambda_id: str, sync_state: ConsciousnessSync) -> dict[str, Any]:
    |                                     ^^^^^^^^^
482 |         """Perform initial synchronization"""
483 |         return {
    |

ARG002 Unused method argument: `sync_state`
   --> candidate/governance/identity/core/integrations/consciousness_bridge.py:481:53
    |
479 |         return True
480 |
481 |     def _perform_initial_sync(self, lambda_id: str, sync_state: ConsciousnessSync) -> dict[str, Any]:
    |                                                     ^^^^^^^^^^
482 |         """Perform initial synchronization"""
483 |         return {
    |

ARG002 Unused method argument: `current_state`
   --> candidate/governance/identity/core/integrations/consciousness_bridge.py:489:64
    |
487 |         }
488 |
489 |     def _analyze_consciousness_coherence(self, lambda_id: str, current_state: ConsciousnessState) -> dict[str, Any]:
    |                                                                ^^^^^^^^^^^^^
490 |         """Analyze consciousness coherence"""
491 |         # Get recent states for comparison
    |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/integrations/consciousness_bridge.py:579:23
    |
577 |             consciousness_state=consciousness_state,
578 |             event_data=event_data,
579 |             timestamp=datetime.now(),
    |                       ^^^^^^^^^^^^^^
580 |             confidence=0.8,
581 |             metadata={},
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

ARG002 Unused method argument: `lambda_id`
   --> candidate/governance/identity/core/integrations/consciousness_bridge.py:629:43
    |
627 |             return None
628 |
629 |     def _sync_with_external_systems(self, lambda_id: str, consciousness_state: ConsciousnessState) -> dict[str, bool]:
    |                                           ^^^^^^^^^
630 |         """Sync with external consciousness systems"""
631 |         # Placeholder for external system integration
    |

ARG002 Unused method argument: `consciousness_state`
   --> candidate/governance/identity/core/integrations/consciousness_bridge.py:629:59
    |
627 |             return None
628 |
629 |     def _sync_with_external_systems(self, lambda_id: str, consciousness_state: ConsciousnessState) -> dict[str, bool]:
    |                                                           ^^^^^^^^^^^^^^^^^^^
630 |         """Sync with external consciousness systems"""
631 |         # Placeholder for external system integration
    |

ARG002 Unused method argument: `states`
   --> candidate/governance/identity/core/integrations/consciousness_bridge.py:715:44
    |
713 |         }
714 |
715 |     def _calculate_pattern_coherence(self, states: list[ConsciousnessState]) -> dict[str, Any]:
    |                                            ^^^^^^
716 |         """Calculate overall pattern coherence"""
717 |         # This would implement sophisticated coherence analysis
    |

ARG002 Unused method argument: `lambda_id`
   --> candidate/governance/identity/core/integrations/consciousness_bridge.py:808:42
    |
806 |         return sum(consistency_scores) / len(consistency_scores) if consistency_scores else 0.5
807 |
808 |     def _detect_temporal_anomalies(self, lambda_id: str, current_state: ConsciousnessState) -> bool:
    |                                          ^^^^^^^^^
809 |         """Detect temporal anomalies in consciousness patterns"""
810 |         # This would implement temporal anomaly detection
    |

ARG002 Unused method argument: `current_state`
   --> candidate/governance/identity/core/integrations/consciousness_bridge.py:808:58
    |
806 |         return sum(consistency_scores) / len(consistency_scores) if consistency_scores else 0.5
807 |
808 |     def _detect_temporal_anomalies(self, lambda_id: str, current_state: ConsciousnessState) -> bool:
    |                                                          ^^^^^^^^^^^^^
809 |         """Detect temporal anomalies in consciousness patterns"""
810 |         # This would implement temporal anomaly detection
    |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
  --> candidate/governance/identity/core/integrations/inference_adapter.py:81:31
   |
79 |     def __post_init__(self):
80 |         if self.created_at is None:
81 |             self.created_at = datetime.now()
   |                               ^^^^^^^^^^^^^^
   |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/integrations/inference_adapter.py:102:33
    |
100 |     def __post_init__(self):
101 |         if self.generated_at is None:
102 |             self.generated_at = datetime.now()
    |                                 ^^^^^^^^^^^^^^
103 |
104 |         # Auto-determine confidence level from score
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

SIM108 Use ternary operator `confidence_score = sum(confidence_factors) / len(confidence_factors) if confidence_factors else 0.3` instead of `if`-`else`-block
   --> candidate/governance/identity/core/integrations/inference_adapter.py:616:9
    |
615 |           # Calculate overall confidence
616 | /         if confidence_factors:
617 | |             confidence_score = sum(confidence_factors) / len(confidence_factors)
618 | |         else:
619 | |             confidence_score = 0.3  # Low confidence without data
    | |__________________________________^
620 |
621 |           # Determine verification result
    |
help: Replace `if`-`else`-block with `confidence_score = sum(confidence_factors) / len(confidence_factors) if confidence_factors else 0.3`

E501 Line too long (129 > 120)
   --> candidate/governance/identity/core/integrations/inference_adapter.py:635:121
    |
633 |             confidence_score=confidence_score,
634 |             reasoning_steps=reasoning_steps,
635 |             explanation=f"Identity verification {'successful' if verified else 'failed'} with confidence {confidence_score:.2f}",
    |                                                                                                                         ^^^^^^^^^
636 |         )
    |

E501 Line too long (168 > 120)
   --> candidate/governance/identity/core/integrations/inference_adapter.py:806:121
    |
804 | â€¦
805 | â€¦
806 | â€¦ification_confidence:.2f}), risk score ({risk_score:.2f}), and {anomaly_count} anomalies",
    |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
807 | â€¦
808 | â€¦
    |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/integrations/memory_connector.py:450:32
    |
448 |             emotional_weight=memory_data.get("emotional_weight", 0.5),
449 |             consciousness_markers=memory_data.get("consciousness_markers", {}),
450 |             creation_timestamp=datetime.now(),
    |                                ^^^^^^^^^^^^^^
451 |             last_accessed=datetime.now(),
452 |             access_count=0,
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/integrations/memory_connector.py:451:27
    |
449 |             consciousness_markers=memory_data.get("consciousness_markers", {}),
450 |             creation_timestamp=datetime.now(),
451 |             last_accessed=datetime.now(),
    |                           ^^^^^^^^^^^^^^
452 |             access_count=0,
453 |             integrity_hash=content_hash,
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/integrations/memory_connector.py:469:32
    |
467 |         # In full implementation, would decrypt content
468 |         # For now, just return the record
469 |         record.last_accessed = datetime.now()
    |                                ^^^^^^^^^^^^^^
470 |         record.access_count += 1
471 |         return record
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

ARG002 Unused method argument: `query`
   --> candidate/governance/identity/core/integrations/memory_connector.py:513:73
    |
511 |         return access_hierarchy[required_level] >= access_hierarchy[memory.access_level]
512 |
513 |     def _sort_memories_by_relevance(self, memories: list[MemoryRecord], query: MemoryQuery) -> list[MemoryRecord]:
    |                                                                         ^^^^^
514 |         """Sort memories by relevance to query"""
    |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/integrations/memory_connector.py:520:25
    |
519 |             # Recent memories score higher
520 |             days_old = (datetime.now() - memory.creation_timestamp).days
    |                         ^^^^^^^^^^^^^^
521 |             recency_score = max(0, 1.0 - (days_old / 365))  # Decay over year
522 |             score += recency_score * 0.3
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

ARG002 Unused method argument: `memory_record`
   --> candidate/governance/identity/core/integrations/memory_connector.py:558:47
    |
556 |             self.access_patterns[lambda_id] = self.access_patterns[lambda_id][-1000:]
557 |
558 |     def _integrate_with_external_memory(self, memory_record: MemoryRecord) -> dict[str, Any]:
    |                                               ^^^^^^^^^^^^^
559 |         """Integrate with external memory systems"""
560 |         # Placeholder for external system integration
    |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/lambd_id_service.py:206:34
    |
204 |                 metadata={
205 |                     "tier_info": tier_info,
206 |                     "timestamp": datetime.now().isoformat(),
    |                                  ^^^^^^^^^^^^^^
207 |                     "version": "2.0.0",
208 |                 },
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

ARG002 Unused method argument: `user_context`
   --> candidate/governance/identity/core/lambd_id_service.py:591:33
    |
589 |         return f"ðŸ†”{lambda_id}{tier_symbol}{symbolic_char}âœ¨"
590 |
591 |     def _check_rate_limit(self, user_context: Optional[UserContext], operation: str) -> bool:
    |                                 ^^^^^^^^^^^^
592 |         """Check rate limiting for user/operation"""
593 |         # TODO: Implement proper rate limiting
    |

ARG002 Unused method argument: `operation`
   --> candidate/governance/identity/core/lambd_id_service.py:591:70
    |
589 |         return f"ðŸ†”{lambda_id}{tier_symbol}{symbolic_char}âœ¨"
590 |
591 |     def _check_rate_limit(self, user_context: Optional[UserContext], operation: str) -> bool:
    |                                                                      ^^^^^^^^^
592 |         """Check rate limiting for user/operation"""
593 |         # TODO: Implement proper rate limiting
    |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/lambd_id_service.py:611:35
    |
609 |                     "user_context": asdict(user_context) if user_context else None,
610 |                     "entropy_score": entropy_score,
611 |                     "created_at": datetime.now().isoformat(),
    |                                   ^^^^^^^^^^^^^^
612 |                 }
613 |             )
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

ARG002 Unused method argument: `user_context`
   --> candidate/governance/identity/core/lambd_id_service.py:615:64
    |
613 |             )
614 |
615 |     def _log_generation_event(self, lambda_id: str, tier: int, user_context: Optional[UserContext]) -> None:
    |                                                                ^^^^^^^^^^^^
616 |         """Log Î›iD generation event"""
617 |         logger.info(f"Î›iD Generated: {lambda_id} (Tier {tier})")
    |

ARG002 Unused method argument: `upgrade_key`
   --> candidate/governance/identity/core/lambd_id_service.py:619:40
    |
617 |         logger.info(f"Î›iD Generated: {lambda_id} (Tier {tier})")
618 |
619 |     def _check_automatic_upgrade(self, upgrade_key: str, user_context: Optional[UserContext]) -> dict[str, Any]:
    |                                        ^^^^^^^^^^^
620 |         """Check automatic upgrade eligibility"""
621 |         # TODO: Implement automatic upgrade logic
    |

ARG002 Unused method argument: `user_context`
   --> candidate/governance/identity/core/lambd_id_service.py:619:58
    |
617 |         logger.info(f"Î›iD Generated: {lambda_id} (Tier {tier})")
618 |
619 |     def _check_automatic_upgrade(self, upgrade_key: str, user_context: Optional[UserContext]) -> dict[str, Any]:
    |                                                          ^^^^^^^^^^^^
620 |         """Check automatic upgrade eligibility"""
621 |         # TODO: Implement automatic upgrade logic
    |

ARG002 Unused method argument: `upgrade_key`
   --> candidate/governance/identity/core/lambd_id_service.py:624:37
    |
622 |         return {"eligible": False, "reason": "Not implemented"}
623 |
624 |     def _check_manual_upgrade(self, upgrade_key: str, user_context: Optional[UserContext]) -> dict[str, Any]:
    |                                     ^^^^^^^^^^^
625 |         """Check manual upgrade eligibility"""
626 |         # TODO: Implement manual upgrade logic
    |

ARG002 Unused method argument: `user_context`
   --> candidate/governance/identity/core/lambd_id_service.py:624:55
    |
622 |         return {"eligible": False, "reason": "Not implemented"}
623 |
624 |     def _check_manual_upgrade(self, upgrade_key: str, user_context: Optional[UserContext]) -> dict[str, Any]:
    |                                                       ^^^^^^^^^^^^
625 |         """Check manual upgrade eligibility"""
626 |         # TODO: Implement manual upgrade logic
    |

DTZ003 `datetime.datetime.utcnow()` used
  --> candidate/governance/identity/core/namespace_manager.py:56:57
   |
54 |         self.allowed_origins = policy_data.get("allowed_origins", [])
55 |         self.rate_limits = policy_data.get("rate_limits", {})
56 |         self.created_at = policy_data.get("created_at", datetime.utcnow().isoformat())
   |                                                         ^^^^^^^^^^^^^^^^^
57 |         self.updated_at = policy_data.get("updated_at", datetime.utcnow().isoformat())
   |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
  --> candidate/governance/identity/core/namespace_manager.py:57:57
   |
55 |         self.rate_limits = policy_data.get("rate_limits", {})
56 |         self.created_at = policy_data.get("created_at", datetime.utcnow().isoformat())
57 |         self.updated_at = policy_data.get("updated_at", datetime.utcnow().isoformat())
   |                                                         ^^^^^^^^^^^^^^^^^
58 |
59 |     def to_dict(self) -> dict[str, Any]:
   |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
  --> candidate/governance/identity/core/namespace_manager.py:89:60
   |
87 |         self.tenant_id = namespace_data.get("tenant_id", "")
88 |         self.active = namespace_data.get("active", True)
89 |         self.created_at = namespace_data.get("created_at", datetime.utcnow().isoformat())
   |                                                            ^^^^^^^^^^^^^^^^^
90 |         self.updated_at = namespace_data.get("updated_at", datetime.utcnow().isoformat())
91 |         self.metadata = namespace_data.get("metadata", {})
   |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
  --> candidate/governance/identity/core/namespace_manager.py:90:60
   |
88 |         self.active = namespace_data.get("active", True)
89 |         self.created_at = namespace_data.get("created_at", datetime.utcnow().isoformat())
90 |         self.updated_at = namespace_data.get("updated_at", datetime.utcnow().isoformat())
   |                                                            ^^^^^^^^^^^^^^^^^
91 |         self.metadata = namespace_data.get("metadata", {})
   |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/namespace_manager.py:396:33
    |
394 |                     setattr(policy, key, value)
395 |
396 |             policy.updated_at = datetime.utcnow().isoformat()
    |                                 ^^^^^^^^^^^^^^^^^
397 |
398 |             # Clear policy cache
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/namespace_manager.py:455:31
    |
453 |                 "identity_mapping": identity_mapping,
454 |                 "creator_id": creator_id,
455 |                 "created_at": datetime.utcnow().isoformat(),
    |                               ^^^^^^^^^^^^^^^^^
456 |                 "active": True,
457 |             }
    |
help: Use `datetime.datetime.now(tz=...)` instead

ARG002 Unused method argument: `context`
   --> candidate/governance/identity/core/namespace_manager.py:585:52
    |
583 |         return identifier
584 |
585 |     def _resolve_by_pattern(self, identifier: str, context: Optional[dict] = None) -> Optional[IdentityNamespace]:
    |                                                    ^^^^^^^
586 |         """Resolve namespace by pattern matching"""
587 |         # Try exact match first
    |

E501 Line too long (149 > 120)
   --> candidate/governance/identity/core/onboarding/onboarding.py:329:121
    |
327 | â€¦
328 | â€¦ here",
329 | â€¦ique identity that reflects your cultural background and personal preferences.",
    |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
330 | â€¦
331 | â€¦
    |

PERF203 `try`-`except` within a loop incurs performance overhead
   --> candidate/governance/identity/core/onboarding/onboarding.py:453:13
    |
451 |                   processed_elements.append(entry)
452 |
453 | /             except Exception as e:
454 | |                 logger.warning(f"Î›TRACE: Failed to process symbolic element: {e}")
455 | |                 continue
    | |________________________^
456 |
457 |           # Update context
    |

ARG002 Unused method argument: `stage_result`
   --> candidate/governance/identity/core/onboarding/onboarding.py:476:9
    |
474 |         current_stage: OnboardingStage,
475 |         context: OnboardingContext,
476 |         stage_result: dict[str, Any],
    |         ^^^^^^^^^^^^
477 |     ) -> OnboardingStage:
478 |         """Determine next onboarding stage based on context and results."""
    |

ARG002 Unused method argument: `progress`
   --> candidate/governance/identity/core/onboarding/onboarding.py:569:69
    |
567 |         }
568 |
569 |     def _build_final_user_profile(self, context: OnboardingContext, progress: OnboardingProgress) -> dict[str, Any]:
    |                                                                     ^^^^^^^^
570 |         """Build final user profile from onboarding data."""
    |

PERF401 Use `list.extend` to create a transformed list
   --> candidate/governance/identity/core/onboarding/onboarding.py:576:17
    |
574 |           if "symbolic_vault" in context.user_preferences:
575 |               for entry in context.user_preferences["symbolic_vault"]:
576 | /                 symbolic_entries.append(
577 | |                     {
578 | |                         "type": entry.entry_type.value,
579 | |                         "value": entry.value,
580 | |                         "cultural_context": entry.cultural_context,
581 | |                         "entropy_contribution": entry.entropy_contribution,
582 | |                     }
583 | |                 )
    | |_________________^
584 |
585 |           # Build comprehensive profile
    |
help: Replace for loop with list.extend

PERF401 Use `list.extend` to create a transformed list
   --> candidate/governance/identity/core/onboarding/onboarding.py:677:21
    |
675 |               if cultural_indicator in self.cultural_suggestions:
676 |                   for suggestion in self.cultural_suggestions[cultural_indicator][:3]:
677 | /                     suggestions.append(
678 | |                         {
679 | |                             "value": suggestion,
680 | |                             "type": ("emoji" if len(suggestion) == 1 and ord(suggestion) > 127 else "word"),
681 | |                             "cultural_context": cultural_indicator,
682 | |                             "reason": f"Popular in {cultural_indicator} culture",
683 | |                         }
684 | |                     )
    | |_____________________^
685 |
686 |           # Personality-based suggestions
    |
help: Replace for loop with list.extend

PERF401 Use `list.extend` to create a transformed list
   --> candidate/governance/identity/core/onboarding/onboarding.py:714:21
    |
712 |               if context.personality_type in personality_suggestions:
713 |                   for suggestion in personality_suggestions[context.personality_type]:
714 | /                     suggestions.append(
715 | |                         {
716 | |                             "value": suggestion,
717 | |                             "type": ("emoji" if len(suggestion) == 1 and ord(suggestion) > 127 else "word"),
718 | |                             "reason": f"Matches {context.personality_type.value} personality",
719 | |                         }
720 | |                     )
    | |_____________________^
721 |
722 |           return suggestions[:10]  # Limit to 10 suggestions
    |
help: Replace for loop with list.extend

ARG002 Unused method argument: `data`
   --> candidate/governance/identity/core/onboarding/onboarding_config.py:713:31
    |
711 |             return {"valid": False, "message": f"Validation error: {e!s}"}
712 |
713 |     def _dict_to_config(self, data: dict[str, Any]) -> OnboardingSystemConfig:
    |                               ^^^^
714 |         """Convert dictionary to configuration object."""
715 |         # This would implement proper deserialization
    |

PERF203 `try`-`except` within a loop incurs performance overhead
   --> candidate/governance/identity/core/performance/auth_optimizer.py:503:17
    |
501 |                       time.sleep(60)
502 |
503 | /                 except Exception as e:
504 | |                     print(f"Performance monitor error: {e}")
505 | |                     time.sleep(60)
    | |__________________________________^
506 |
507 |           monitor_thread = threading.Thread(target=monitor_performance, daemon=True)
    |

E501 Line too long (150 > 120)
   --> candidate/governance/identity/core/performance/auth_optimizer.py:551:121
    |
549 | â€¦
550 | â€¦
551 | â€¦get_p95_latency}ms. Consider increasing cache size or enabling async processing."
    |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
552 | â€¦
    |

E501 Line too long (165 > 120)
   --> candidate/governance/identity/core/performance/auth_optimizer.py:556:121
    |
554 | â€¦
555 | â€¦
556 | â€¦get_cache_hit_rate:.2%}. Consider enabling predictive caching or increasing TTL values."
    |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
557 | â€¦
    |

SIM102 Use a single `if` statement instead of nested `if` statements
   --> candidate/governance/identity/core/qrg/qrg_manager.py:593:13
    |
591 |                   if not self._validate_word_challenge(element, response[element]):
592 |                       return False
593 | /             elif element.startswith("biometric_"):
594 | |                 if not self._validate_biometric_challenge(element, response[element]):
    | |______________________________________________________________________________________^
595 |                       return False
    |
help: Combine `if` statements using `and`

ARG002 Unused method argument: `challenge`
   --> candidate/governance/identity/core/qrg/qrg_manager.py:599:41
    |
597 |         return True
598 |
599 |     def _validate_emoji_challenge(self, challenge: str, response: str) -> bool:
    |                                         ^^^^^^^^^
600 |         """Validate emoji challenge response."""
601 |         # Implement emoji validation logic
    |

ARG002 Unused method argument: `challenge`
   --> candidate/governance/identity/core/qrg/qrg_manager.py:604:40
    |
602 |         return len(response) > 0  # Placeholder
603 |
604 |     def _validate_word_challenge(self, challenge: str, response: str) -> bool:
    |                                        ^^^^^^^^^
605 |         """Validate word challenge response."""
606 |         # Implement word validation logic
    |

ARG002 Unused method argument: `challenge`
   --> candidate/governance/identity/core/qrg/qrg_manager.py:609:45
    |
607 |         return len(response) > 2  # Placeholder
608 |
609 |     def _validate_biometric_challenge(self, challenge: str, response: str) -> bool:
    |                                             ^^^^^^^^^
610 |         """Validate biometric challenge response."""
611 |         # Implement biometric validation logic
    |

DTZ003 `datetime.datetime.utcnow()` used
  --> candidate/governance/identity/core/sent/consent_history.py:32:21
   |
30 |     def record_consent_event(self, user_id: str, event_type: str, scope_data: dict, metadata: dict) -> str:
31 |         """Record a consent event in immutable history"""
32 |         timestamp = datetime.utcnow().isoformat()
   |                     ^^^^^^^^^^^^^^^^^
33 |
34 |         # Create consent record
   |
help: Use `datetime.datetime.now(tz=...)` instead

ARG002 Unused method argument: `user_id`
  --> candidate/governance/identity/core/sent/consent_history.py:69:29
   |
67 |         return hashlib.sha256(hash_data.encode()).hexdigest()
68 |
69 |     def _log_to_trace(self, user_id: str, consent_record: dict):
   |                             ^^^^^^^
70 |         """Log consent event to Î›TRACE system"""
71 |         {
   |

ARG002 Unused method argument: `user_tier`
   --> candidate/governance/identity/core/sent/consent_manager.py:156:45
    |
154 |         return self.scopes_manager.get_symbolic_representation(consented_scopes)
155 |
156 |     def _validate_tier_consent_access(self, user_tier: int, consent_scope: str) -> bool:
    |                                             ^^^^^^^^^
157 |         """Validate if user tier allows access to consent scope"""
158 |         # TODO: Load tier boundaries from consent_tiers.json
    |

ARG002 Unused method argument: `consent_scope`
   --> candidate/governance/identity/core/sent/consent_manager.py:156:61
    |
154 |         return self.scopes_manager.get_symbolic_representation(consented_scopes)
155 |
156 |     def _validate_tier_consent_access(self, user_tier: int, consent_scope: str) -> bool:
    |                                                             ^^^^^^^^^^^^^
157 |         """Validate if user tier allows access to consent scope"""
158 |         # TODO: Load tier boundaries from consent_tiers.json
    |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/sent/policy_engine.py:214:29
    |
212 |             "average_evaluation_time": 0.0,
213 |             "constitutional_compliance_rate": 1.0,
214 |             "last_updated": datetime.now().isoformat(),
    |                             ^^^^^^^^^^^^^^
215 |         }
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/sent/policy_engine.py:308:22
    |
307 |         evaluation_id = f"eval_{uuid.uuid4().hex[:8]}"
308 |         start_time = datetime.now()
    |                      ^^^^^^^^^^^^^^
309 |
310 |         try:
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

E501 Line too long (130 > 120)
   --> candidate/governance/identity/core/sent/policy_engine.py:394:120
    |
393 |             logger.info(
394 |                 f"ðŸ” Ethical evaluation completed: {action} -> {evaluation.recommended_action.value} (score: {overall_score:.3f})"
    |                                                                                                                         ^^^^^^^^^^
395 |             )
396 |             return evaluation
    |

ARG002 Unused method argument: `action`
   --> candidate/governance/identity/core/sent/policy_engine.py:444:48
    |
442 |         return max(0.0, min(1.0, score))
443 |
444 |     async def _evaluate_consequentialist(self, action: str, context: dict[str, Any]) -> float:
    |                                                ^^^^^^
445 |         """Evaluate using consequentialist (outcome-based) ethics"""
    |

ARG002 Unused method argument: `action`
   --> candidate/governance/identity/core/sent/policy_engine.py:618:41
    |
616 |         return scores
617 |
618 |     async def _evaluate_principle(self, action: str, context: dict[str, Any], principle: EthicalPrinciple) -> float:
    |                                         ^^^^^^
619 |         """Evaluate a specific ethical principle"""
    |

B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   --> candidate/governance/identity/core/sent/policy_engine.py:772:13
    |
770 |         except Exception as e:
771 |             logger.error(f"âŒ Failed to create policy: {e}")
772 |             raise ValueError(f"Invalid policy data: {e!s}")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
773 |
774 |     def update_policy(self, policy_id: str, updates: dict[str, Any]) -> bool:
    |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/sent/policy_engine.py:877:24
    |
876 |         if not time_period:
877 |             end_time = datetime.now()
    |                        ^^^^^^^^^^^^^^
878 |             start_time = end_time - timedelta(days=30)
879 |             time_period = (start_time, end_time)
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/core/sent/policy_engine.py:884:29
    |
882 |             "report_id": f"ethics_compliance_{uuid.uuid4().hex[:8]}",
883 |             "user_id": user_id,
884 |             "generated_at": datetime.now().isoformat(),
    |                             ^^^^^^^^^^^^^^
885 |             "period": {
886 |                 "start": time_period[0].isoformat(),
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

PERF401 Use a list comprehension to create a transformed list
   --> candidate/governance/identity/core/sent/policy_engine.py:962:17
    |
960 |           for rule in policy.rules:
961 |               if not await self._evaluate_rule(rule, evaluation, context):
962 | /                 violations.append(
963 | |                     {
964 | |                         "policy_id": policy.policy_id,
965 | |                         "rule": rule.get("name", "unnamed_rule"),
966 | |                         "description": rule.get("description", "Rule violation"),
967 | |                         "severity": policy.enforcement_level.value,
968 | |                     }
969 | |                 )
    | |_________________^
970 |
971 |           return violations
    |
help: Replace for loop with list comprehension

DTZ005 `datetime.datetime.now()` called without a `tz` argument
    --> candidate/governance/identity/core/sent/policy_engine.py:1262:22
     |
1261 |         # Update evaluation time
1262 |         eval_time = (datetime.now() - start_time).total_seconds()
     |                      ^^^^^^^^^^^^^^
1263 |         current_avg = self.metrics["average_evaluation_time"]
1264 |         total_evals = self.metrics["total_evaluations"]
     |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
    --> candidate/governance/identity/core/sent/policy_engine.py:1276:40
     |
1274 |         self.metrics["constitutional_compliance_rate"] = compliance_count / total_evals
1275 |
1276 |         self.metrics["last_updated"] = datetime.now().isoformat()
     |                                        ^^^^^^^^^^^^^^
1277 |
1278 |     def get_metrics(self) -> dict[str, Any]:
     |
help: Pass a `datetime.timezone` object to the `tz` parameter

invalid-syntax: Expected a newline after line continuation character
   --> candidate/governance/identity/core/sing/cross_device_manager.py:175:14
    |
173 | â€¦         'sync_method': 'secure_channel',
174 | â€¦         'guardian_approved': True
175 | â€¦     }\n            \n            # Store token sync record\n            if device_id not in self.device_tokens[user_id]:\n         â€¦
    |        ^
    |

invalid-syntax: Expected a newline after line continuation character
   --> candidate/governance/identity/core/sing/cross_device_manager.py:175:28
    |
173 | â€¦         'sync_method': 'secure_channel',
174 | â€¦         'guardian_approved': True
175 | â€¦     }\n            \n            # Store token sync record\n            if device_id not in self.device_tokens[user_id]:\n         â€¦
    |                      ^
    |

E501 Line too long (22071 > 120)
   --> candidate/governance/identity/core/sing/cross_device_manager.py:175:121
    |
173 | â€¦
174 | â€¦
175 | â€¦ens[user_id]:\n                self.device_tokens[user_id][device_id] = []\n                \n            self.device_tokens[user_id][device_id].append(sync_record)\n            \n            # Add to sync queue for real-time propagation\n            self.sync_queue.append({\n                'action': 'token_sync',\n                'user_id': user_id,\n                'device_id': device_id,\n                'sync_record': sync_record,\n                'timestamp': time.time()\n            })\n            \n            # ðŸ§  Update consciousness patterns\n            self._update_consciousness_patterns(user_id, device_id, 'token_sync')\n            \n            # Performance tracking\n            sync_time = (time.time() - start_time) * 1000\n            \n            return {\n                'success': True,\n                'device_id': device_id,\n                'sync_id': sync_record.get('sync_id', secrets.token_hex(8)),\n                'trust_score': trust_score,\n                'expires_at': sync_record['expires_at'],\n                'sync_time_ms': sync_time,\n                'device_fingerprint': sync_record['device_fingerprint'],\n                'guardian_approved': True\n            }\n            \n        except Exception as e:\n            return {\n                'success': False,\n                'error': f'Token sync failed: {str(e)}',\n                'sync_time_ms': (time.time() - start_time) * 1000 if 'start_time' in locals() else 0\n            }\n\n    def invalidate_device_tokens(self, device_id: str, user_id: str, \n                                reason: str = 'manual_revocation') -> Dict[str, Any]:\n        \"\"\"ðŸš« Invalidate all tokens for a specific device\"\"\"\n        try:\n            start_time = time.time()\n            \n            if user_id not in self.device_tokens or device_id not in self.device_tokens[user_id]:\n                return {\n                    'success': False,\n                    'error': 'Device not found',\n                    'invalidation_time_ms': (time.time() - start_time) * 1000\n                }\n            \n            # Get device tokens\n            device_token_records = self.device_tokens[user_id][device_id]\n            invalidated_count = 0\n            \n            # Mark all tokens as invalidated\n            for token_record in device_token_records:\n                if not token_record.get('invalidated', False):\n                    token_record['invalidated'] = True\n                    token_record['invalidated_at'] = datetime.utcnow().isoformat()\n                    token_record['invalidation_reason'] = reason\n                    invalidated_count += 1\n            \n            # Add to sync queue for real-time propagation\n            self.sync_queue.append({\n                'action': 'token_invalidation',\n                'user_id': user_id,\n                'device_id': device_id,\n                'reason': reason,\n                'invalidated_count': invalidated_count,\n                'timestamp': time.time()\n            })\n            \n            # ðŸ§  Update consciousness patterns for security event\n            self._update_consciousness_patterns(user_id, device_id, 'token_invalidation')\n            \n            return {\n                'success': True,\n                'device_id': device_id,\n                'invalidated_count': invalidated_count,\n                'reason': reason,\n                'invalidated_at': datetime.utcnow().isoformat(),\n                'invalidation_time_ms': (time.time() - start_time) * 1000\n            }\n            \n        except Exception as e:\n            return {\n                'success': False,\n                'error': f'Token invalidation failed: {str(e)}',\n                'invalidation_time_ms': (time.time() - start_time) * 1000 if 'start_time' in locals() else 0\n            }\n\n    def get_device_tokens(self, user_id: str, device_id: str, \n                         include_expired: bool = False) -> Dict[str, Any]:\n        \"\"\"ðŸ“± Get all active tokens for a device\"\"\"\n        try:\n            start_time = time.time()\n            \n            if user_id not in self.device_tokens or device_id not in self.device_tokens[user_id]:\n                return {\n                    'success': False,\n                    'error': 'Device not found',\n                    'tokens': [],\n                    'retrieval_time_ms': (time.time() - start_time) * 1000\n                }\n            \n            device_token_records = self.device_tokens[user_id][device_id]\n            active_tokens = []\n            \n            current_time = datetime.utcnow()\n            \n            for token_record in device_token_records:\n                # Skip invalidated tokens\n                if token_record.get('invalidated', False):\n                    continue\n                    \n                # Check expiration\n                expires_at = datetime.fromisoformat(token_record['expires_at'])\n                is_expired = current_time > expires_at\n                \n                if is_expired and not include_expired:\n                    continue\n                \n                # Decrypt token for return (in real implementation, \n                # you might return token metadata instead)\n                decrypted_token = self._decrypt_token(\n                    token_record['token'], device_id\n                )\n                \n                active_tokens.append({\n                    'token_id': token_record.get('sync_id', 'unknown'),\n                    'synced_at': token_record['synced_at'],\n                    'expires_at': token_record['expires_at'],\n                    'trust_score': token_record['trust_score'],\n                    'is_expired': is_expired,\n                    'sync_method': token_record['sync_method'],\n                    # Only include actual token in secure contexts\n                    'token': decrypted_token if not is_expired else None\n                })\n            \n            return {\n                'success': True,\n                'device_id': device_id,\n                'user_id': user_id,\n                'tokens': active_tokens,\n                'active_count': len([t for t in active_tokens if not t['is_expired']]),\n                'total_count': len(active_tokens),\n                'retrieval_time_ms': (time.time() - start_time) * 1000\n            }\n            \n        except Exception as e:\n            return {\n                'success': False,\n                'error': f'Token retrieval failed: {str(e)}',\n                'tokens': [],\n                'retrieval_time_ms': (time.time() - start_time) * 1000 if 'start_time' in locals() else 0\n            }\n\n    def sync_tokens_across_devices(self, user_id: str, source_device_id: str, \n                                  target_device_ids: Optional[List[str]] = None) -> Dict[str, Any]:\n        \"\"\"ðŸ”„ Sync tokens across multiple devices for a user\"\"\"\n        try:\n            start_time = time.time()\n            \n            if user_id not in self.device_tokens:\n                return {\n                    'success': False,\n                    'error': 'User has no registered devices',\n                    'sync_time_ms': (time.time() - start_time) * 1000\n                }\n            \n            user_devices = self.device_tokens[user_id]\n            \n            # If no target devices specified, sync to all trusted devices\n            if target_device_ids is None:\n                target_device_ids = [\n                    device_id for device_id, tokens in user_devices.items()\n                    if device_id != source_device_id and \n                    self._is_device_trusted(user_id, device_id)\n                ]\n            \n            # Get source device tokens\n            source_tokens_result = self.get_device_tokens(user_id, source_device_id)\n            if not source_tokens_result['success']:\n                return {\n                    'success': False,\n                    'error': f'Failed to get source device tokens: {source_tokens_result[\"error\"]}',\n                    'sync_time_ms': (time.time() - start_time) * 1000\n                }\n            \n            source_tokens = source_tokens_result['tokens']\n            sync_results = {}\n            \n            # Sync to each target device\n            for target_device_id in target_device_ids:\n                device_sync_results = []\n                \n                for token_data in source_tokens:\n                    if token_data['token'] and not token_data['is_expired']:\n                        sync_result = self.sync_token_to_device(\n                            token_data['token'],\n                            target_device_id,\n                            user_id\n                        )\n                        device_sync_results.append(sync_result)\n                \n                sync_results[target_device_id] = {\n                    'synced_tokens': len([r for r in device_sync_results if r['success']]),\n                    'failed_tokens': len([r for r in device_sync_results if not r['success']]),\n                    'results': device_sync_results\n                }\n            \n            total_synced = sum(r['synced_tokens'] for r in sync_results.values())\n            total_failed = sum(r['failed_tokens'] for r in sync_results.values())\n            \n            return {\n                'success': total_synced > 0,\n                'source_device_id': source_device_id,\n                'target_devices': target_device_ids,\n                'total_synced': total_synced,\n                'total_failed': total_failed,\n                'device_results': sync_results,\n                'sync_time_ms': (time.time() - start_time) * 1000\n            }\n            \n        except Exception as e:\n            return {\n                'success': False,\n                'error': f'Cross-device sync failed: {str(e)}',\n                'sync_time_ms': (time.time() - start_time) * 1000 if 'start_time' in locals() else 0\n            }\n\n    def get_user_devices(self, user_id: str, include_trust_scores: bool = True) -> Dict[str, Any]:\n        \"\"\"ðŸ“‹ Get all registered devices for a user\"\"\"\n        try:\n            if user_id not in self.device_tokens:\n                return {\n                    'success': True,\n                    'user_id': user_id,\n                    'devices': [],\n                    'total_devices': 0\n                }\n            \n            devices = []\n            for device_id, token_records in self.device_tokens[user_id].items():\n                device_info = {\n                    'device_id': device_id,\n                    'token_count': len([t for t in token_records if not t.get('invalidated', False)]),\n                    'last_sync': max([t['synced_at'] for t in token_records], default='never'),\n                }\n                \n                if include_trust_scores and token_records:\n                    # Get latest device data for trust score\n                    latest_record = max(token_records, key=lambda x: x['synced_at'])\n                    device_info['trust_score'] = latest_record['trust_score']\n                    device_info['device_fingerprint'] = latest_record['device_fingerprint']\n                \n                devices.append(device_info)\n            \n            return {\n                'success': True,\n                'user_id': user_id,\n                'devices': devices,\n                'total_devices': len(devices),\n                'trusted_devices': len([d for d in devices if d.get('trust_score', 0) >= self.trust_threshold])\n            }\n            \n        except Exception as e:\n            return {\n                'success': False,\n                'error': f'Failed to get user devices: {str(e)}',\n                'devices': []\n            }\n\n    # Helper methods for cross-device token management\n    \n    def _generate_encryption_key(self) -> Optional[object]:\n        \"\"\"Generate encryption key for token security\"\"\"\n        if Fernet:\n            return Fernet.generate_key()\n        return None\n    \n    def _encrypt_token(self, token: str, device_id: str) -> str:\n        \"\"\"Encrypt token for secure storage\"\"\"\n        if self.token_encryption_key and Fernet:\n            try:\n                f = Fernet(self.token_encryption_key)\n                # Add device_id as additional context\n                token_with_context = f\"{token}|{device_id}\"\n                return f.encrypt(token_with_context.encode()).decode()\n            except Exception:\n                pass\n        \n        # Fallback to base64 encoding (not secure, for development only)\n        import base64\n        return base64.b64encode(f\"{token}|{device_id}\".encode()).decode()\n    \n    def _decrypt_token(self, encrypted_token: str, device_id: str) -> Optional[str]:\n        \"\"\"Decrypt token from secure storage\"\"\"\n        if self.token_encryption_key and Fernet:\n            try:\n                f = Fernet(self.token_encryption_key)\n                decrypted = f.decrypt(encrypted_token.encode()).decode()\n                token, stored_device_id = decrypted.split('|', 1)\n                if stored_device_id == device_id:\n                    return token\n                return None\n            except Exception:\n                pass\n        \n        # Fallback for base64 encoding\n        try:\n            import base64\n            decrypted = base64.b64decode(encrypted_token.encode()).decode()\n            token, stored_device_id = decrypted.split('|', 1)\n            if stored_device_id == device_id:\n                return token\n        except Exception:\n            pass\n        \n        return None\n    \n    def _get_device_data(self, user_id: str, device_id: str, device_info: Optional[Dict] = None) -> Dict:\n        \"\"\"Get or create device data record\"\"\"\n        # In a real implementation, this would fetch from a database\n        default_device_data = {\n            'device_id': device_id,\n            'user_id': user_id,\n            'registered_at': datetime.utcnow().isoformat(),\n            'last_used': datetime.utcnow().isoformat(),\n            'biometric_enabled': device_info.get('biometric_enabled', False) if device_info else False,\n            'secure_enclave': device_info.get('secure_enclave', False) if device_info else False,\n            'device_encrypted': device_info.get('device_encrypted', True) if device_info else True,\n            'network_consistency_score': 0.7,  # Would be calculated from network patterns\n            'auth_success_rate': 0.95,  # Would be calculated from auth history\n            'device_type': device_info.get('device_type', 'unknown') if device_info else 'unknown',\n            'os_version': device_info.get('os_version', 'unknown') if device_info else 'unknown',\n            'app_version': device_info.get('app_version', 'unknown') if device_info else 'unknown'\n        }\n        \n        # Update with provided device info\n        if device_info:\n            default_device_data.update(device_info)\n            default_device_data['last_used'] = datetime.utcnow().isoformat()\n        \n        return default_device_data\n    \n    def _generate_device_fingerprint(self, device_data: Dict) -> str:\n        \"\"\"Generate unique device fingerprint\"\"\"\n        fingerprint_data = f\"{device_data.get('device_id')}|{device_data.get('device_type')}|{device_data.get('os_version')}\"\n        return hashlib.sha256(fingerprint_data.encode()).hexdigest()[:16]\n    \n    def _constitutional_validation(self, user_id: str, device_id: str, device_data: Dict) -> bool:\n        \"\"\"ðŸ›¡ï¸ Guardian constitutional validation\"\"\"\n        try:\n            # Basic safety checks\n            if not user_id or not device_id:\n                return False\n            \n            # Check for suspicious device patterns\n            if device_data.get('auth_success_rate', 1.0) < 0.5:\n                return False  # Too many failed authentications\n            \n            # Check device registration age (prevent rapid device additions)\n            reg_date = datetime.fromisoformat(device_data.get('registered_at', '2024-01-01'))\n            if (datetime.utcnow() - reg_date).total_seconds() < 300:  # 5 minutes minimum\n                return False\n            \n            # âš›ï¸ Identity integrity check\n            if len(user_id) < 8:\n                return False\n                \n            return True\n            \n        except Exception:\n            return False  # Deny on error for safety\n    \n    def _update_consciousness_patterns(self, user_id: str, device_id: str, action: str):\n        \"\"\"ðŸ§  Update consciousness patterns for security analysis\"\"\"\n        # This would integrate with the consciousness tracking system\n        # For now, just log the activity\n        timestamp = datetime.utcnow().isoformat()\n        print(f\"Consciousness update: {user_id} | {device_id} | {action} | {timestamp}\")\n    \n    def _is_device_trusted(self, user_id: str, device_id: str) -> bool:\n        \"\"\"Check if device meets trust threshold\"\"\"\n        try:\n            if user_id not in self.device_tokens or device_id not in self.device_tokens[user_id]:\n                return False\n            \n            device_records = self.device_tokens[user_id][device_id]\n            if not device_records:\n                return False\n            \n            # Get latest trust score\n            latest_record = max(device_records, key=lambda x: x['synced_at'])\n            return latest_record['trust_score'] >= self.trust_threshold\n            \n        except Exception:\n            return False\n    \n    def cleanup_expired_tokens(self) -> Dict[str, Any]:\n        \"\"\"ðŸ§¹ Cleanup expired tokens across all devices\"\"\"\n        try:\n            start_time = time.time()\n            total_cleaned = 0\n            current_time = datetime.utcnow()\n            \n            for user_id, user_devices in self.device_tokens.items():\n                for device_id, token_records in user_devices.items():\n                    cleaned_count = 0\n                    for token_record in token_records[:]:\n                        try:\n                            expires_at = datetime.fromisoformat(token_record['expires_at'])\n                            if current_time > expires_at:\n                                token_records.remove(token_record)\n                                cleaned_count += 1\n                        except (ValueError, KeyError):\n                            # Remove malformed records\n                            token_records.remove(token_record)\n                            cleaned_count += 1\n                    \n                    total_cleaned += cleaned_count\n            \n            return {\n                'success': True,\n                'tokens_cleaned': total_cleaned,\n                'cleanup_time_ms': (time.time() - start_time) * 1000\n            }\n            \n        except Exception as e:\n            return {\n                'success': False,\n                'error': f'Cleanup failed: {str(e)}',\n                'tokens_cleaned': 0\n            }\n\n\n# WebRTC-based real-time sync for trusted devices\nclass WebRTCDeviceSync:\n    \"\"\"ðŸŒ WebRTC-based real-time token synchronization\"\"\"\n    \n    def __init__(self, cross_device_manager: CrossDeviceTokenManager):\n        self.device_manager = cross_device_manager\n        self.active_channels = {}\n        self.sync_callbacks = []\n    \n    async def establish_sync_channel(self, user_id: str, device_a: str, device_b: str) -> bool:\n        \"\"\"Establish WebRTC sync channel between two trusted devices\"\"\"\n        try:\n            # Verify both devices are trusted\n            if not (self.device_manager._is_device_trusted(user_id, device_a) and \n                   self.device_manager._is_device_trusted(user_id, device_b)):\n                return False\n            \n            # Create sync channel identifier\n            channel_id = f\"{user_id}:{min(device_a, device_b)}:{max(device_a, device_b)}\"\n            \n            # In a real implementation, this would establish WebRTC connection\n            self.active_channels[channel_id] = {\n                'user_id': user_id,\n                'devices': [device_a, device_b],\n                'established_at': datetime.utcnow().isoformat(),\n                'status': 'active'\n            }\n            \n            return True\n            \n        except Exception:\n            return False\n    \n    async def sync_via_webrtc(self, user_id: str, source_device: str, \n                            target_device: str, token_data: Dict) -> bool:\n        \"\"\"Sync token via WebRTC channel\"\"\"\n        try:\n            # Check for active channel\n            channel_id = f\"{user_id}:{min(source_device, target_device)}:{max(source_device, target_device)}\"\n            \n            if channel_id not in self.active_channels:\n                return False\n            \n            # In a real implementation, this would send via WebRTC data channel\n            # For now, just use the regular sync mechanism\n            result = self.device_manager.sync_token_to_device(\n                token_data['token'],\n                target_device,\n                user_id\n            )\n            \n            return result['success']\n            \n        except Exception:\n            return False\n\n\n# Export main classes\n__all__ = [\n    \"CrossDeviceTokenManager\",\n    \"DeviceTrustScore\", \n    \"WebRTCDeviceSync\"\n]
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |

invalid-syntax: Expected `except` or `finally` after `try` block
   --> candidate/governance/identity/core/sing/cross_device_manager.py:176:1
    |
174 | â€¦
175 | â€¦,\n    \"DeviceTrustScore\", \n    \"WebRTCDeviceSync\"\n]
    |                                                            ^
    |

DTZ003 `datetime.datetime.utcnow()` used
  --> candidate/governance/identity/core/sing/sso_engine.py:72:27
   |
70 |             "user_id": user_id,
71 |             "service_scope": service_scope,
72 |             "created_at": datetime.utcnow().isoformat(),
   |                           ^^^^^^^^^^^^^^^^^
73 |             "expires_at": (datetime.utcnow() + timedelta(hours=self.token_expiry_hours)).isoformat(),
74 |             "device_info": device_info or {},
   |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
  --> candidate/governance/identity/core/sing/sso_engine.py:73:28
   |
71 |             "service_scope": service_scope,
72 |             "created_at": datetime.utcnow().isoformat(),
73 |             "expires_at": (datetime.utcnow() + timedelta(hours=self.token_expiry_hours)).isoformat(),
   |                            ^^^^^^^^^^^^^^^^^
74 |             "device_info": device_info or {},
75 |             "symbolic_signature": self._generate_symbolic_signature(user_id, service_scope),
   |
help: Use `datetime.datetime.now(tz=...)` instead

SIM102 Use a single `if` statement instead of nested `if` statements
   --> candidate/governance/identity/core/sing/sso_engine.py:132:9
    |
131 |           # Validate symbolic signature if provided
132 | /         if validation_context and "symbolic_challenge" in validation_context:
133 | |             if not self._validate_symbolic_challenge(token_data, validation_context["symbolic_challenge"]):
    | |___________________________________________________________________________________________________________^
134 |                   return {"valid": False, "reason": "Symbolic challenge failed"}
    |
help: Combine `if` statements using `and`

SIM102 Use a single `if` statement instead of nested `if` statements
   --> candidate/governance/identity/core/sing/sso_engine.py:188:13
    |
186 |               token_result = self.generate_sso_token(user_id, glyph_payload.get("service_scope", ["basic"]), device_info)
187 |
188 | /             if token_result["success"]:
189 | |                 # Log QR-G authentication
190 | |                 if self.trace_logger:
    | |_____________________________________^
191 |                       self.trace_logger.log_activity(
192 |                           user_id,
    |
help: Combine `if` statements using `and`

PERF203 `try`-`except` within a loop incurs performance overhead
   --> candidate/governance/identity/core/sing/sso_engine.py:275:13
    |
273 |                   }
274 |
275 | /             except Exception as e:
276 | |                 sync_results[device_id] = {"success": False, "error": str(e)}
    | |_____________________________________________________________________________^
277 |
278 |           # Log cross-device sync
    |

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/sing/sso_engine.py:327:27
    |
325 |             "success": True,
326 |             "token_id": token_id,
327 |             "revoked_at": datetime.utcnow().isoformat(),
    |                           ^^^^^^^^^^^^^^^^^
328 |             "affected_services": token_data.get("service_scope", []),
329 |         }
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/sing/sso_engine.py:341:30
    |
339 |             "symbolic_integration": service_config.get("symbolic_integration", False),
340 |             "platform_support": service_config.get("platform_support", ["web"]),
341 |             "registered_at": datetime.utcnow().isoformat(),
    |                              ^^^^^^^^^^^^^^^^^
342 |         }
    |
help: Use `datetime.datetime.now(tz=...)` instead

ARG002 Unused method argument: `user_id`
   --> candidate/governance/identity/core/sing/sso_engine.py:360:44
    |
358 |         return hashlib.sha256(payload.encode()).hexdigest()
359 |
360 |     def _generate_symbolic_signature(self, user_id: str, service_scope: list[str]) -> str:
    |                                            ^^^^^^^
361 |         """Generate symbolic signature for token"""
362 |         # Combine user tier symbol with service symbols
    |

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/sing/sso_engine.py:442:16
    |
440 |         """Check if token is expired"""
441 |         expires_at = datetime.fromisoformat(token_data["expires_at"])
442 |         return datetime.utcnow() > expires_at
    |                ^^^^^^^^^^^^^^^^^
443 |
444 |     def _invalidate_token(self, token_id: str, reason: str):
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/sing/sso_engine.py:486:27
    |
484 |         self.device_registry[user_id][device_id] = {
485 |             "device_info": device_info,
486 |             "first_seen": datetime.utcnow().isoformat(),
    |                           ^^^^^^^^^^^^^^^^^
487 |             "last_token": token_id,
488 |             "trust_level": 0.5,  # Initial trust level
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/sing/sso_engine.py:518:34
    |
516 |         """Calculate remaining time in seconds for token"""
517 |         expires_at = datetime.fromisoformat(token_data["expires_at"])
518 |         remaining = expires_at - datetime.utcnow()
    |                                  ^^^^^^^^^^^^^^^^^
519 |         return max(0, int(remaining.total_seconds()))
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/sing/sso_engine.py:567:16
    |
566 |             expires_at = datetime.fromisoformat(glyph_payload["expires_at"])
567 |             if datetime.utcnow() > expires_at:
    |                ^^^^^^^^^^^^^^^^^
568 |                 raise ValueError("QR-G code has expired")
    |
help: Use `datetime.datetime.now(tz=...)` instead

ARG002 Unused method argument: `user_id`
   --> candidate/governance/identity/core/sing/sso_engine.py:625:42
    |
623 |             return False  # Deny on error for security
624 |
625 |     def _verify_symbolic_challenge(self, user_id: str, symbolic_challenge: str) -> bool:
    |                                          ^^^^^^^
626 |         """Verify symbolic challenge for authentication"""
627 |         # TODO: Implement symbolic challenge verification
    |

ARG002 Unused method argument: `symbolic_challenge`
   --> candidate/governance/identity/core/sing/sso_engine.py:625:56
    |
623 |             return False  # Deny on error for security
624 |
625 |     def _verify_symbolic_challenge(self, user_id: str, symbolic_challenge: str) -> bool:
    |                                                        ^^^^^^^^^^^^^^^^^^
626 |         """Verify symbolic challenge for authentication"""
627 |         # TODO: Implement symbolic challenge verification
    |

ARG002 Unused method argument: `user_id`
   --> candidate/governance/identity/core/sing/sso_engine.py:630:40
    |
628 |         return True
629 |
630 |     def _validate_biometric_data(self, user_id: str, biometric_data: dict) -> bool:
    |                                        ^^^^^^^
631 |         """Validate biometric authentication data"""
632 |         # TODO: Implement biometric validation
    |

ARG002 Unused method argument: `user_tokens`
   --> candidate/governance/identity/core/sing/sso_engine.py:641:41
    |
639 |         return hashlib.sha256(payload_str.encode()).hexdigest()
640 |
641 |     def _create_device_sync_token(self, user_tokens: dict, device_id: str) -> dict:
    |                                         ^^^^^^^^^^^
642 |         """Create device-specific sync token"""
643 |         # TODO: Implement device sync token creation
    |

ARG002 Unused method argument: `device_id`
   --> candidate/governance/identity/core/sing/sso_engine.py:641:60
    |
639 |         return hashlib.sha256(payload_str.encode()).hexdigest()
640 |
641 |     def _create_device_sync_token(self, user_tokens: dict, device_id: str) -> dict:
    |                                                            ^^^^^^^^^
642 |         """Create device-specific sync token"""
643 |         # TODO: Implement device sync token creation
    |

ARG002 Unused method argument: `sync_token`
   --> candidate/governance/identity/core/sing/sso_engine.py:646:36
    |
644 |         return {}
645 |
646 |     def _register_sync_token(self, sync_token: dict) -> str:
    |                                    ^^^^^^^^^^
647 |         """Register sync token for cross-device use"""
648 |         # TODO: Implement sync token registration
    |

RUF006 Store a reference to the return value of `asyncio.create_task`
   --> candidate/governance/identity/core/swarm/tier_aware_swarm_hub.py:202:9
    |
201 |         # Start tier-based task scheduler
202 |         asyncio.create_task(self._tier_task_scheduler())
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
203 |
204 |         # Start colony health monitor
    |

RUF006 Store a reference to the return value of `asyncio.create_task`
   --> candidate/governance/identity/core/swarm/tier_aware_swarm_hub.py:205:9
    |
204 |         # Start colony health monitor
205 |         asyncio.create_task(self._colony_health_monitor())
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
206 |
207 |         logger.info("Tier-Aware Swarm Hub fully initialized")
    |

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/swarm/tier_aware_swarm_hub.py:231:31
    |
229 |             self.colony_health[colony_name] = {
230 |                 "status": "healthy",
231 |                 "last_check": datetime.utcnow(),
    |                               ^^^^^^^^^^^^^^^^^
232 |                 "success_rate": 1.0,
233 |                 "active_tasks": 0,
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/swarm/tier_aware_swarm_hub.py:266:50
    |
264 |         # Create identity swarm task
265 |         task = IdentitySwarmTask(
266 |             task_id=f"id_verify_{lambda_id}_{int(datetime.utcnow().timestamp())}",
    |                                                  ^^^^^^^^^^^^^^^^^
267 |             task_type=f"identity_{verification_type}",
268 |             priority=adjusted_priority,
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/swarm/tier_aware_swarm_hub.py:324:83
    |
322 |             raise ValueError("Target tier must be higher than current tier")
323 |
324 |         migration_id = f"migrate_{lambda_id}_{current_tier}_to_{target_tier}_{int(datetime.utcnow().timestamp())}"
    |                                                                                   ^^^^^^^^^^^^^^^^^
325 |
326 |         # Create migration request
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/swarm/tier_aware_swarm_hub.py:333:29
    |
331 |             "target_tier": target_tier,
332 |             "reason": migration_reason,
333 |             "requested_at": datetime.utcnow(),
    |                             ^^^^^^^^^^^^^^^^^
334 |             "verification_data": verification_data,
335 |             "status": "pending",
    |
help: Use `datetime.datetime.now(tz=...)` instead

SIM102 Use a single `if` statement instead of nested `if` statements
   --> candidate/governance/identity/core/swarm/tier_aware_swarm_hub.py:400:9
    |
399 |           # Special cases for verification types
400 | /         if verification_type == "high_security":
401 | |             # High security always uses all available colonies for the tier
402 | |             if tier_level >= 3 and "consciousness" not in required:
    | |___________________________________________________________________^
403 |                   required.append("consciousness")
    |
help: Combine `if` statements using `and`

RUF006 Store a reference to the return value of `asyncio.create_task`
   --> candidate/governance/identity/core/swarm/tier_aware_swarm_hub.py:494:29
    |
493 |                             # Execute task with orchestration
494 |                             asyncio.create_task(self._execute_orchestrated_task(task))
    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
495 |
496 |                 await asyncio.sleep(0.1)  # Small delay between scheduling cycles
    |

PERF203 `try`-`except` within a loop incurs performance overhead
   --> candidate/governance/identity/core/swarm/tier_aware_swarm_hub.py:498:13
    |
496 |                   await asyncio.sleep(0.1)  # Small delay between scheduling cycles
497 |
498 | /             except Exception as e:
499 | |                 logger.error(f"Task scheduler error: {e}")
500 | |                 await asyncio.sleep(1)
    | |______________________________________^
501 |
502 |       async def _execute_orchestrated_task(self, task: IdentitySwarmTask):
    |

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/swarm/tier_aware_swarm_hub.py:509:22
    |
507 |             return
508 |
509 |         start_time = datetime.utcnow()
    |                      ^^^^^^^^^^^^^^^^^
510 |         results = {}
511 |         success = True
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/swarm/tier_aware_swarm_hub.py:596:25
    |
595 |             # Update tier metrics
596 |             duration = (datetime.utcnow() - start_time).total_seconds()
    |                         ^^^^^^^^^^^^^^^^^
597 |             self._update_tier_metrics(task.tier_level, success, duration)
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/swarm/tier_aware_swarm_hub.py:685:49
    |
683 |             # Update migration status
684 |             migration_request["status"] = "approved" if migration_approved else "denied"
685 |             migration_request["completed_at"] = datetime.utcnow()
    |                                                 ^^^^^^^^^^^^^^^^^
686 |             migration_request["avg_confidence"] = avg_confidence
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/swarm/tier_aware_swarm_hub.py:730:63
    |
728 |         for colony_name in orchestration.colonies:
729 |             self.colony_health[colony_name]["status"] = "healing"
730 |             self.colony_health[colony_name]["last_failure"] = datetime.utcnow()
    |                                                               ^^^^^^^^^^^^^^^^^
731 |
732 |     async def _colony_health_monitor(self):
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/swarm/tier_aware_swarm_hub.py:745:44
    |
744 |                     # Update health tracking
745 |                     health["last_check"] = datetime.utcnow()
    |                                            ^^^^^^^^^^^^^^^^^
746 |                     health["success_rate"] = colony_status.get("performance_metrics", {}).get("success_rate", 1.0)
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
  --> candidate/governance/identity/core/tagging/identity_tag_resolver.py:75:33
   |
73 |         """Update trust based on interaction."""
74 |         self.interaction_count += 1
75 |         self.last_interaction = datetime.utcnow()
   |                                 ^^^^^^^^^^^^^^^^^
76 |
77 |         if positive:
   |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
  --> candidate/governance/identity/core/tagging/identity_tag_resolver.py:87:25
   |
86 |             # Apply decay for old relationships
87 |             age_days = (datetime.utcnow() - self.established_at).days
   |                         ^^^^^^^^^^^^^^^^^
88 |             decay_factor = 1.0 / (1.0 + age_days / 365)  # Yearly decay
   |
help: Use `datetime.datetime.now(tz=...)` instead

RUF006 Store a reference to the return value of `asyncio.create_task`
   --> candidate/governance/identity/core/tagging/identity_tag_resolver.py:191:9
    |
190 |         # Start consensus processor
191 |         asyncio.create_task(self._process_consensus_requests())
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
192 |
193 |         # Start trust network analyzer
    |

RUF006 Store a reference to the return value of `asyncio.create_task`
   --> candidate/governance/identity/core/tagging/identity_tag_resolver.py:194:9
    |
193 |         # Start trust network analyzer
194 |         asyncio.create_task(self._analyze_trust_network())
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
195 |
196 |         logger.info("Identity Tag Resolver initialized")
    |

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/tagging/identity_tag_resolver.py:221:26
    |
219 |             consensus_required=require_consensus,
220 |             issuer_id=issuer_id or "system",
221 |             expiry_time=(datetime.utcnow() + timedelta(hours=expiry_hours) if expiry_hours else None),
    |                          ^^^^^^^^^^^^^^^^^
222 |         )
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/tagging/identity_tag_resolver.py:234:66
    |
233 |             # Create consensus request
234 |             request_id = f"consensus_{lambda_id}_{tag.name}_{int(datetime.utcnow().timestamp())}"
    |                                                                  ^^^^^^^^^^^^^^^^^
235 |             consensus_request = TagConsensusRequest(
236 |                 request_id=request_id,
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/tagging/identity_tag_resolver.py:242:26
    |
240 |                 trust_network=trust_network[:10],  # Limit to 10 trusted identities
241 |                 required_votes=min(5, len(trust_network)),
242 |                 deadline=datetime.utcnow() + timedelta(minutes=5),
    |                          ^^^^^^^^^^^^^^^^^
243 |             )
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/tagging/identity_tag_resolver.py:270:34
    |
268 |             self.tag_history.append(
269 |                 {
270 |                     "timestamp": datetime.utcnow(),
    |                                  ^^^^^^^^^^^^^^^^^
271 |                     "lambda_id": lambda_id,
272 |                     "tag": tag,
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/tagging/identity_tag_resolver.py:307:45
    |
305 |             # Update existing relationship
306 |             relationship = self.trust_relationships[relationship_key]
307 |             relationship.last_interaction = datetime.utcnow()
    |                                             ^^^^^^^^^^^^^^^^^
308 |             if trust_factors:
309 |                 relationship.trust_factors.update(trust_factors)
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/tagging/identity_tag_resolver.py:317:32
    |
315 |                 trust_level=initial_trust,
316 |                 trust_score=initial_trust.value,
317 |                 established_at=datetime.utcnow(),
    |                                ^^^^^^^^^^^^^^^^^
318 |                 last_interaction=datetime.utcnow(),
319 |                 trust_factors=trust_factors or {},
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/tagging/identity_tag_resolver.py:318:34
    |
316 |                 trust_score=initial_trust.value,
317 |                 established_at=datetime.utcnow(),
318 |                 last_interaction=datetime.utcnow(),
    |                                  ^^^^^^^^^^^^^^^^^
319 |                 trust_factors=trust_factors or {},
320 |             )
    |
help: Use `datetime.datetime.now(tz=...)` instead

ARG002 Unused method argument: `details`
   --> candidate/governance/identity/core/tagging/identity_tag_resolver.py:354:9
    |
352 |         positive: bool,
353 |         interaction_type: str,
354 |         details: Optional[dict[str, Any]] = None,
    |         ^^^^^^^
355 |     ):
356 |         """
    |

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/tagging/identity_tag_resolver.py:410:54
    |
408 |         valid_tags = []
409 |         for tag in identity_tags:
410 |             if tag.expiry_time and tag.expiry_time < datetime.utcnow():
    |                                                      ^^^^^^^^^^^^^^^^^
411 |                 continue
412 |             if tag.tier_required and tier_level < tag.tier_required:
    |
help: Use `datetime.datetime.now(tz=...)` instead

PERF203 `try`-`except` within a loop incurs performance overhead
   --> candidate/governance/identity/core/tagging/identity_tag_resolver.py:460:17
    |
458 |                       weight = float(tag.metadata.get("weight", 1.0))
459 |                       scores.append(score * weight)
460 | /                 except BaseException:
461 | |                     pass
    | |________________________^
462 |
463 |               if scores:
    |

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/tagging/identity_tag_resolver.py:584:32
    |
582 |         while True:
583 |             try:
584 |                 current_time = datetime.utcnow()
    |                                ^^^^^^^^^^^^^^^^^
585 |                 completed_requests = []
    |
help: Use `datetime.datetime.now(tz=...)` instead

PERF203 `try`-`except` within a loop incurs performance overhead
   --> candidate/governance/identity/core/tagging/identity_tag_resolver.py:640:13
    |
638 |                   await asyncio.sleep(1)
639 |
640 | /             except Exception as e:
641 | |                 logger.error(f"Consensus processor error: {e}")
642 | |                 await asyncio.sleep(5)
    | |______________________________________^
643 |
644 |       async def _analyze_trust_network(self):
    |

PERF203 `try`-`except` within a loop incurs performance overhead
   --> candidate/governance/identity/core/tagging/identity_tag_resolver.py:668:13
    |
666 |                   await asyncio.sleep(60)  # Analyze every minute
667 |
668 | /             except Exception as e:
669 | |                 logger.error(f"Trust network analysis error: {e}")
670 | |                 await asyncio.sleep(60)
    | |_______________________________________^
671 |
672 |       def get_resolver_statistics(self) -> dict[str, Any]:
    |

PERF401 Use `list.extend` to create a transformed list
   --> candidate/governance/identity/core/tier/tier_manager.py:229:21
    |
227 |                 missing_caps = requested_requirements.required_capabilities - current_requirements.required_capabilities
228 |                 for cap in missing_caps:
229 |                     missing_requirements.append(f"Missing capability: {cap.value}")
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
230 |
231 |                 # Generate QRS-enhanced recommendations
    |
help: Replace for loop with list.extend

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/tier/tier_manager.py:240:41
    |
238 |                 "missing_requirements": missing_requirements,
239 |                 "recommendations": recommendations,
240 |                 "validation_timestamp": datetime.utcnow().isoformat(),
    |                                         ^^^^^^^^^^^^^^^^^
241 |             }
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/tier/tier_manager.py:248:41
    |
246 |                 "access_granted": False,
247 |                 "error": f"Invalid tier level: {e}",
248 |                 "validation_timestamp": datetime.utcnow().isoformat(),
    |                                         ^^^^^^^^^^^^^^^^^
249 |             }
250 |         except Exception as e:
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/tier/tier_manager.py:255:41
    |
253 |                 "access_granted": False,
254 |                 "error": str(e),
255 |                 "validation_timestamp": datetime.utcnow().isoformat(),
    |                                         ^^^^^^^^^^^^^^^^^
256 |             }
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/tier/tier_manager.py:408:29
    |
407 |         # Perform tier upgrade
408 |         upgrade_timestamp = datetime.utcnow().isoformat()
    |                             ^^^^^^^^^^^^^^^^^
409 |
410 |         # Update user tier data
    |
help: Use `datetime.datetime.now(tz=...)` instead

ARG002 Unused method argument: `user_id`
   --> candidate/governance/identity/core/tier/tier_manager.py:649:38
    |
647 |         }
648 |
649 |     def _validate_tier_upgrade(self, user_id: str, current_tier: int, new_tier: int, validation_data: dict) -> dict:
    |                                      ^^^^^^^
650 |         """Comprehensive tier upgrade validation"""
    |

ARG002 Unused method argument: `user_id`
   --> candidate/governance/identity/core/tier/tier_manager.py:732:41
    |
730 |         return min(current_entropy / required_entropy, 1.0)
731 |
732 |     def _initialize_new_user_tier(self, user_id: str) -> dict:
    |                                         ^^^^^^^
733 |         """Initialize tier data for new user"""
734 |         return {
    |

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/tier/tier_manager.py:736:27
    |
734 |         return {
735 |             "current_tier": 0,
736 |             "created_at": datetime.utcnow().isoformat(),
    |                           ^^^^^^^^^^^^^^^^^
737 |             "entropy_score": 0.0,
738 |             "progression_history": [],
    |
help: Use `datetime.datetime.now(tz=...)` instead

ARG002 Unused method argument: `user_id`
   --> candidate/governance/identity/core/tier/tier_manager.py:741:36
    |
739 |         }
740 |
741 |     def _load_user_tier_data(self, user_id: str) -> Optional[dict]:
    |                                    ^^^^^^^
742 |         """Load user tier data from persistent storage"""
743 |         # TODO: Implement persistent storage loading
    |

ARG002 Unused method argument: `validation_data`
   --> candidate/governance/identity/core/tier/tier_manager.py:750:43
    |
748 |         # TODO: Implement persistent storage
749 |
750 |     def _calculate_validation_score(self, validation_data: dict, requirements: dict) -> float:
    |                                           ^^^^^^^^^^^^^^^
751 |         """Calculate validation score for tier upgrade"""
752 |         # TODO: Implement sophisticated scoring algorithm
    |

ARG002 Unused method argument: `requirements`
   --> candidate/governance/identity/core/tier/tier_manager.py:750:66
    |
748 |         # TODO: Implement persistent storage
749 |
750 |     def _calculate_validation_score(self, validation_data: dict, requirements: dict) -> float:
    |                                                                  ^^^^^^^^^^^^
751 |         """Calculate validation score for tier upgrade"""
752 |         # TODO: Implement sophisticated scoring algorithm
    |

ARG001 Unused function argument: `user_id`
  --> candidate/governance/identity/core/tier/tier_system.py:48:19
   |
48 | def get_user_tier(user_id: str) -> int:
   |                   ^^^^^^^
49 |     """
50 |     Get the current tier level of a user.
   |

ARG001 Unused function argument: `permission`
  --> candidate/governance/identity/core/tier/tier_system.py:66:44
   |
66 | def validate_tier_permission(user_id: str, permission: str) -> bool:
   |                                            ^^^^^^^^^^
67 |     """
68 |     Check if a user has a specific tier-based permission.
   |

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/tier/tier_validator.py:239:33
    |
237 |             report = {
238 |                 "user_id": user_id,
239 |                 "generated_at": datetime.utcnow().isoformat(),
    |                                 ^^^^^^^^^^^^^^^^^
240 |                 "current_tier": {
241 |                     "level": current_tier,
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/tier/tier_validator.py:292:33
    |
290 |                 "error": f"Failed to generate tier report: {e!s}",
291 |                 "user_id": user_id,
292 |                 "generated_at": datetime.utcnow().isoformat(),
    |                                 ^^^^^^^^^^^^^^^^^
293 |             }
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/tier/tier_validator.py:411:28
    |
409 |             "developer_certified": False,
410 |             "activity_start_date": "2024-01-01",
411 |             "last_active": datetime.utcnow().isoformat(),
    |                            ^^^^^^^^^^^^^^^^^
412 |             "daily_generations": 5,
413 |             "daily_validations": 20,
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/tier/tier_validator.py:422:21
    |
420 |         try:
421 |             start_date = datetime.fromisoformat(user_data.get("activity_start_date", "2024-01-01"))
422 |             return (datetime.utcnow() - start_date).days
    |                     ^^^^^^^^^^^^^^^^^
423 |         except (ValueError, TypeError):
424 |             return 0
    |
help: Use `datetime.datetime.now(tz=...)` instead

SIM103 Return the negated condition directly
   --> candidate/governance/identity/core/tier/tier_validator.py:444:13
    |
442 |               # Consciousness pattern validation (ðŸ§ )
443 |               consciousness_score = self._analyze_consciousness_patterns(user_data)
444 | /             if consciousness_score < 0.1:  # Minimum consciousness threshold
445 | |                 return False
446 | |
447 | |             return True
    | |_______________________^
448 |
449 |           except Exception:
    |
help: Inline condition

ARG002 Unused method argument: `user_data`
   --> candidate/governance/identity/core/tier/tier_validator.py:528:54
    |
526 |         return tier_config.get("rate_limits", {})
527 |
528 |     def _get_next_tier_requirements(self, tier: int, user_data: dict) -> list[str]:
    |                                                      ^^^^^^^^^
529 |         """Get requirements for next tier"""
530 |         tier_config = self.tier_permissions.get("tier_permissions", {}).get(str(tier), {})
    |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
   --> candidate/governance/identity/core/tier/tier_validator.py:612:25
    |
610 |       """ðŸ”— OAuth2/OIDC scope to LUKHAS tier mapping"""
611 |
612 |       SCOPE_TO_TIER_MAP = {
    |  _________________________^
613 | |         "lukhas:basic": 0,
614 | |         "lukhas:identity:read": 1,
615 | |         "lukhas:identity:write": 2,
616 | |         "lukhas:premium": 3,
617 | |         "lukhas:enterprise": 4,
618 | |         "lukhas:admin": 5,
619 | |         # Standard OIDC scopes
620 | |         "openid": 0,
621 | |         "profile": 1,
622 | |         "email": 1,
623 | |         "phone": 2,
624 | |     }
    | |_____^
625 |
626 |       @classmethod
    |

DTZ003 `datetime.datetime.utcnow()` used
  --> candidate/governance/identity/core/trace/activity_logger.py:53:21
   |
51 |             return None
52 |
53 |         timestamp = datetime.utcnow().isoformat()
   |                     ^^^^^^^^^^^^^^^^^
54 |         event_symbol = self.symbolic_map.get(activity_type, "â“")
   |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/core/trace/activity_logger.py:109:33
    |
107 |             "change_reason": change_reason,
108 |             "progression_symbol": f"T{old_tier}â†’T{new_tier}",
109 |             "timestamp_change": datetime.utcnow().isoformat(),
    |                                 ^^^^^^^^^^^^^^^^^
110 |         }
111 |         return self.log_activity(user_id, "tier_change", symbolic_data)
    |
help: Use `datetime.datetime.now(tz=...)` instead

ARG002 Unused method argument: `activity_type`
   --> candidate/governance/identity/core/trace/activity_logger.py:205:50
    |
203 |         return f"TR_{hashlib.sha256(data.encode()).hexdigest()[:8]}"
204 |
205 |     def _build_trace_context(self, user_id: str, activity_type: str) -> dict:
    |                                                  ^^^^^^^^^^^^^
206 |         """Build contextual information for trace"""
207 |         return {
    |

ARG002 Unused method argument: `user_id`
   --> candidate/governance/identity/core/trace/activity_logger.py:227:30
    |
225 |         # TODO: Implement persistent storage logic
226 |
227 |     def _get_user_tier(self, user_id: str) -> int:
    |                              ^^^^^^^
228 |         """Get current user tier"""
229 |         # TODO: Integration with Î›TIER system
    |

invalid-syntax: Expected ',', found ':'
   --> candidate/governance/identity/core/unified_auth_manager.py:300:21
    |
298 |         return {
299 |             "primary": cultural_context.get("preferred_color", ")  # 4A90E2",
300 |             "accent": cultural_context.get("accent_color", ")  # 7ED321",
    |                     ^
301 |             "warning": cultural_context.get("warning_color", ")  # F5A623",
302 |         }
    |

invalid-syntax: Expected ',', found ':'
   --> candidate/governance/identity/core/unified_auth_manager.py:301:22
    |
299 |             "primary": cultural_context.get("preferred_color", ")  # 4A90E2",
300 |             "accent": cultural_context.get("accent_color", ")  # 7ED321",
301 |             "warning": cultural_context.get("warning_color", ")  # F5A623",
    |                      ^
302 |         }
    |

invalid-syntax: Expected ',', found '}'
   --> candidate/governance/identity/core/unified_auth_manager.py:302:9
    |
300 |             "accent": cultural_context.get("accent_color", ")  # 7ED321",
301 |             "warning": cultural_context.get("warning_color", ")  # F5A623",
302 |         }
    |         ^
303 |
304 |     def _get_cultural_symbols(self, cultural_context: dict[str, Any]) -> list[str]:
    |

invalid-syntax: Expected ')', found NonLogicalNewline
   --> candidate/governance/identity/core/unified_auth_manager.py:302:10
    |
300 |             "accent": cultural_context.get("accent_color", ")  # 7ED321",
301 |             "warning": cultural_context.get("warning_color", ")  # F5A623",
302 |         }
    |          ^
303 |
304 |     def _get_cultural_symbols(self, cultural_context: dict[str, Any]) -> list[str]:
    |

invalid-syntax: Expected '}', found dedent
   --> candidate/governance/identity/core/unified_auth_manager.py:304:5
    |
302 |         }
303 |
304 |     def _get_cultural_symbols(self, cultural_context: dict[str, Any]) -> list[str]:
    |     ^
305 |         """Get culturally appropriate symbols"""
306 |         region = cultural_context.get("region", "").lower()
    |

F821 Undefined name `logger`
   --> candidate/governance/identity/core/user_tier_mapping.py:128:17
    |
126 |                     for lambda_id, profile_data in data.items():
127 |                         self.cache[lambda_id] = UserTierProfile.from_dict(profile_data)
128 |                 logger.info(f"Loaded {len(self.cache)} user tier profiles")
    |                 ^^^^^^
129 |             except Exception as e:
130 |                 logger.error(f"Failed to load tier database: {e}")
    |

F821 Undefined name `logger`
   --> candidate/governance/identity/core/user_tier_mapping.py:130:17
    |
128 |                 logger.info(f"Loaded {len(self.cache)} user tier profiles")
129 |             except Exception as e:
130 |                 logger.error(f"Failed to load tier database: {e}")
    |                 ^^^^^^
131 |                 self.cache = {}
132 |         else:
    |

F821 Undefined name `logger`
   --> candidate/governance/identity/core/user_tier_mapping.py:133:13
    |
131 |                 self.cache = {}
132 |         else:
133 |             logger.info("No existing tier database found, starting fresh")
    |             ^^^^^^
134 |             self._initialize_default_users()
    |

F821 Undefined name `logger`
   --> candidate/governance/identity/core/user_tier_mapping.py:143:13
    |
141 |             with open(self.db_path, "w") as f:
142 |                 json.dump(data, f, indent=2)
143 |             logger.debug(f"Saved {len(data)} user tier profiles")
    |             ^^^^^^
144 |         except Exception as e:
145 |             logger.error(f"Failed to save tier database: {e}")
    |

F821 Undefined name `logger`
   --> candidate/governance/identity/core/user_tier_mapping.py:145:13
    |
143 |             logger.debug(f"Saved {len(data)} user tier profiles")
144 |         except Exception as e:
145 |             logger.error(f"Failed to save tier database: {e}")
    |             ^^^^^^
146 |
147 |     def _initialize_default_users(self):
    |

F821 Undefined name `logger`
   --> candidate/governance/identity/core/user_tier_mapping.py:260:17
    |
258 |             # Check if tier has expired
259 |             if profile.tier_expiry and datetime.now(timezone.utc) > profile.tier_expiry:
260 |                 logger.info(f"Tier expired for {lambda_id}, reverting to base tier")
    |                 ^^^^^^
261 |                 self._revert_to_base_tier(lambda_id)
    |

F821 Undefined name `logger`
   --> candidate/governance/identity/core/user_tier_mapping.py:350:9
    |
348 |         self._save_database()
349 |
350 |         logger.info(
    |         ^^^^^^
351 |             f"Set tier for {lambda_id} to {tier.name}",
352 |             temporary=duration_minutes is not None,
    |

SIM108 Use ternary operator `consciousness_level = sum(f * w for f, w in zip(factors, weights)) / sum(weights) if factors else 0.5` instead of `if`-`else`-block
   --> candidate/governance/identity/core/visualization/consciousness_mapper.py:257:9
    |
256 |           # Calculate weighted average
257 | /         if factors:
258 | |             consciousness_level = sum(f * w for f, w in zip(factors, weights)) / sum(weights)
259 | |         else:
260 | |             consciousness_level = 0.5  # Default to moderate consciousness
    | |_____________________________________^
261 |
262 |           # Apply creativity boost
    |
help: Replace `if`-`else`-block with `consciousness_level = sum(f * w for f, w in zip(factors, weights)) / sum(weights) if factors else 0.5`

ARG002 Unused method argument: `delta_time`
   --> candidate/governance/identity/core/visualization/orb.py:276:35
    |
274 |         return pattern_map.get(base_pattern, OrbPattern.PULSE)
275 |
276 |     def get_animation_frame(self, delta_time: float) -> dict[str, Any]:
    |                                   ^^^^^^^^^^
277 |         """
278 |         Get current animation frame data
    |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
  --> candidate/governance/identity/deployment_package.py:50:18
   |
49 |     VERSION = "1.0.0"
50 |     BUILD_DATE = datetime.now().isoformat()
   |                  ^^^^^^^^^^^^^^
51 |
52 |     REQUIRED_PYTHON_VERSION = (3, 7)
   |
help: Pass a `datetime.timezone` object to the `tz` parameter

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> candidate/governance/identity/deployment_package.py:53:24
   |
52 |       REQUIRED_PYTHON_VERSION = (3, 7)
53 |       REQUIRED_MODULES = [
   |  ________________________^
54 | |         "qrg_generators",
55 | |         "qrg_integration",
56 | |         "qrg_complete_demo",
57 | |         "ultimate_test_suite",
58 | |     ]
   | |_____^
59 |
60 |       REQUIRED_DIRECTORIES = [
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> candidate/governance/identity/deployment_package.py:60:28
   |
58 |       ]
59 |
60 |       REQUIRED_DIRECTORIES = [
   |  ____________________________^
61 | |         "core",
62 | |         "web",
63 | |         "backend",
64 | |         "mobile",
65 | |         "utils",
66 | |         "tests",
67 | |         "assets",
68 | |     ]
   | |_____^
69 |
70 |       REQUIRED_FILES = [
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> candidate/governance/identity/deployment_package.py:70:22
   |
68 |       ]
69 |
70 |       REQUIRED_FILES = [
   |  ______________________^
71 | |         "README.md",
72 | |         "ARCHITECTURE.md",
73 | |         "qrg_generators.py",
74 | |         "qrg_integration.py",
75 | |         "qrg_complete_demo.py",
76 | |         "ultimate_test_suite.py",
77 | |     ]
   | |_____^
   |

PERF203 `try`-`except` within a loop incurs performance overhead
   --> candidate/governance/identity/deployment_package.py:118:13
    |
116 |                   __import__(module)
117 |                   available_modules.append(module)
118 | /             except ImportError:
119 | |                 missing_modules.append(module)
    | |______________________________________________^
120 |
121 |           results["details"]["available_modules"] = available_modules
    |

PERF401 Use a list comprehension to create a transformed list
   --> candidate/governance/identity/deployment_package.py:474:13
    |
473 |         for i in range(1000):
474 |             data.append(f"qrg_pattern_{i}")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
475 |
476 |         final_size = sys.getsizeof(data)
    |
help: Replace for loop with list comprehension

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/enhancements/emotional_drift_monitoring.py:186:23
    |
184 |         """Extract emotional data points from session history"""
185 |
186 |         cutoff_date = datetime.utcnow() - timedelta(days=days)
    |                       ^^^^^^^^^^^^^^^^^
187 |         emotional_data = []
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/enhancements/emotional_drift_monitoring.py:190:76
    |
189 |         for session in session_history:
190 |             session_time = datetime.fromisoformat(session.get("timestamp", datetime.utcnow().isoformat()))
    |                                                                            ^^^^^^^^^^^^^^^^^
191 |
192 |             if session_time < cutoff_date:
    |
help: Use `datetime.datetime.now(tz=...)` instead

ARG002 Unused method argument: `patterns`
   --> candidate/governance/identity/enhancements/emotional_drift_monitoring.py:474:57
    |
473 |     def _identify_positive_indicators(
474 |         self, emotional_data: list[EmotionalDataPoint], patterns: list[EmotionalPattern]
    |                                                         ^^^^^^^^
475 |     ) -> list[str]:
476 |         """Identify positive emotional indicators"""
    |

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/enhancements/emotional_drift_monitoring.py:612:17
    |
610 |     # Mock session history
611 |     session_history = []
612 |     base_time = datetime.utcnow() - timedelta(days=30)
    |                 ^^^^^^^^^^^^^^^^^
613 |
614 |     consciousness_cycle = [
    |
help: Use `datetime.datetime.now(tz=...)` instead

E501 Line too long (179 > 120)
   --> candidate/governance/identity/enhancements/llm_assisted_entry.py:127:121
    |
125 | â€¦
126 | â€¦
127 | â€¦ authentication. The system recognizes your concentrated mental state and adapts accordingly.",
    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
128 | â€¦hentication process. The system embraces your innovative approach while maintaining security.",
129 | â€¦ation experience. The system honors your peaceful state with gentle, secure validation.",
    |

E501 Line too long (179 > 120)
   --> candidate/governance/identity/enhancements/llm_assisted_entry.py:128:121
    |
126 | â€¦
127 | â€¦ authentication. The system recognizes your concentrated mental state and adapts accordingly.",
128 | â€¦hentication process. The system embraces your innovative approach while maintaining security.",
    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
129 | â€¦ation experience. The system honors your peaceful state with gentle, secure validation.",
130 | â€¦n process. The system appreciates your systematic approach to authentication.",
    |

E501 Line too long (173 > 120)
   --> candidate/governance/identity/enhancements/llm_assisted_entry.py:129:121
    |
127 | â€¦for authentication. The system recognizes your concentrated mental state and adapts accordingly.",
128 | â€¦authentication process. The system embraces your innovative approach while maintaining security.",
129 | â€¦tication experience. The system honors your peaceful state with gentle, secure validation.",
    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
130 | â€¦tion process. The system appreciates your systematic approach to authentication.",
131 | â€¦nto the authentication flow. The system respects the ethereal nature of your current awareness.",
    |

E501 Line too long (163 > 120)
   --> candidate/governance/identity/enhancements/llm_assisted_entry.py:130:121
    |
128 | â€¦ the authentication process. The system embraces your innovative approach while maintaining security.",
129 | â€¦uthentication experience. The system honors your peaceful state with gentle, secure validation.",
130 | â€¦alidation process. The system appreciates your systematic approach to authentication.",
    |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
131 | â€¦ted into the authentication flow. The system respects the ethereal nature of your current awareness.",
132 | â€¦cation. The system recognizes your peak performance and responds fluidly.",
    |

E501 Line too long (178 > 120)
   --> candidate/governance/identity/enhancements/llm_assisted_entry.py:131:121
    |
129 | â€¦cation experience. The system honors your peaceful state with gentle, secure validation.",
130 | â€¦on process. The system appreciates your systematic approach to authentication.",
131 | â€¦o the authentication flow. The system respects the ethereal nature of your current awareness.",
    |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
132 | â€¦ The system recognizes your peak performance and responds fluidly.",
133 | â€¦
    |

E501 Line too long (151 > 120)
   --> candidate/governance/identity/enhancements/llm_assisted_entry.py:132:121
    |
130 | â€¦rity validation process. The system appreciates your systematic approach to authentication.",
131 | â€¦ntegrated into the authentication flow. The system respects the ethereal nature of your current awareness.",
132 | â€¦thentication. The system recognizes your peak performance and responds fluidly.",
    |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
133 | â€¦
    |

E501 Line too long (136 > 120)
   --> candidate/governance/identity/enhancements/llm_assisted_entry.py:231:121
    |
229 | â€¦
230 | â€¦
231 | â€¦ral patterns with {analysis['consistency_score']:.1f} consistency score. "
    |                                                            ^^^^^^^^^^^^^^^^
232 | â€¦
233 | â€¦
    |

E501 Line too long (153 > 120)
   --> candidate/governance/identity/enhancements/llm_assisted_entry.py:249:121
    |
247 | â€¦
248 | â€¦
249 | â€¦t.cultural_context['region']} cultural context, ensuring a harmonious experience."
    |                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
250 | â€¦
251 | â€¦
    |

E501 Line too long (190 > 120)
   --> candidate/governance/identity/enhancements/llm_assisted_entry.py:259:121
    |
257 | â€¦
258 | â€¦
259 | â€¦tication method provides the optimal balance of security and user experience for your current state."
    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
260 | â€¦
261 | â€¦
    |

ARG002 Unused method argument: `context`
   --> candidate/governance/identity/enhancements/llm_assisted_entry.py:263:44
    |
261 |         return f"{base_narrative}{cultural_detail}{security_detail}{method_detail}"
262 |
263 |     async def _assess_security_risks(self, context: LLMAnalysisContext, analysis: dict[str, Any]) -> str:
    |                                            ^^^^^^^
264 |         """Assess security risks using LLM reasoning"""
    |

E501 Line too long (126 > 120)
   --> candidate/governance/identity/enhancements/llm_assisted_entry.py:270:121
    |
269 |         if risk_level == "low" and not anomalies:
270 |             return "Security assessment: EXCELLENT. All patterns align with expected user behavior and no anomalies detected."
    |                                                                                                                         ^^^^^^
271 |
272 |         elif risk_level == "medium":
    |

ARG002 Unused method argument: `context`
   --> candidate/governance/identity/enhancements/llm_assisted_entry.py:322:41
    |
320 |             return LLMValidationResult.REQUIRES_REVIEW
321 |
322 |     def _create_fallback_response(self, context: LLMAnalysisContext) -> LLMValidationResponse:
    |                                         ^^^^^^^
323 |         """Create fallback response when LLM analysis fails"""
    |

E402 Module level import not at top of file
  --> candidate/governance/identity/enterprise/auth.py:32:1
   |
30 | PLACEHOLDER_BIND_PASSWORD = "service-account-password"  # nosec B105
31 |
32 | import jwt
   | ^^^^^^^^^^
33 | import requests
34 | from cryptography.fernet import Fernet
   |

E402 Module level import not at top of file
  --> candidate/governance/identity/enterprise/auth.py:33:1
   |
32 | import jwt
33 | import requests
   | ^^^^^^^^^^^^^^^
34 | from cryptography.fernet import Fernet
   |

E402 Module level import not at top of file
  --> candidate/governance/identity/enterprise/auth.py:34:1
   |
32 | import jwt
33 | import requests
34 | from cryptography.fernet import Fernet
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |

DTZ006 `datetime.datetime.fromtimestamp()` called without a `tz` argument
   --> candidate/governance/identity/enterprise/auth.py:527:16
    |
526 |             # Check expiration
527 |             if datetime.fromtimestamp(payload.get("exp", 0)) < datetime.utcnow():
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
528 |                 return self._failed_auth_result(session_id, "Token expired")
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/enterprise/auth.py:527:64
    |
526 |             # Check expiration
527 |             if datetime.fromtimestamp(payload.get("exp", 0)) < datetime.utcnow():
    |                                                                ^^^^^^^^^^^^^^^^^
528 |                 return self._failed_auth_result(session_id, "Token expired")
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/enterprise/auth.py:725:12
    |
724 |         # Check session expiry
725 |         if datetime.utcnow() > session["expires_at"]:
    |            ^^^^^^^^^^^^^^^^^
726 |             del self.active_sessions[session_id]
727 |             return None
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/enterprise/auth.py:758:20
    |
756 |             "user_id": user_id,
757 |             "token_type": "mfa",
758 |             "exp": datetime.utcnow() + timedelta(minutes=10),
    |                    ^^^^^^^^^^^^^^^^^
759 |         }
760 |         return jwt.encode(payload, self.jwt_secret, algorithm=self.jwt_algorithm)
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/enterprise/auth.py:764:15
    |
762 |     def _generate_tokens(self, user: EnterpriseUser) -> tuple[str, str, datetime]:
763 |         """Generate access and refresh tokens."""
764 |         now = datetime.utcnow()
    |               ^^^^^^^^^^^^^^^^^
765 |         expires_at = now + timedelta(hours=self.token_expiry_hours)
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/enterprise/auth.py:798:27
    |
796 |             "user": user,
797 |             "access_token": access_token,
798 |             "created_at": datetime.utcnow(),
    |                           ^^^^^^^^^^^^^^^^^
799 |             "expires_at": datetime.utcnow() + timedelta(hours=self.config.get("session_timeout_hours", 8)),
800 |             "last_activity": datetime.utcnow(),
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/enterprise/auth.py:799:27
    |
797 |             "access_token": access_token,
798 |             "created_at": datetime.utcnow(),
799 |             "expires_at": datetime.utcnow() + timedelta(hours=self.config.get("session_timeout_hours", 8)),
    |                           ^^^^^^^^^^^^^^^^^
800 |             "last_activity": datetime.utcnow(),
801 |         }
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/enterprise/auth.py:800:30
    |
798 |             "created_at": datetime.utcnow(),
799 |             "expires_at": datetime.utcnow() + timedelta(hours=self.config.get("session_timeout_hours", 8)),
800 |             "last_activity": datetime.utcnow(),
    |                              ^^^^^^^^^^^^^^^^^
801 |         }
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/enterprise/auth.py:917:24
    |
915 |             authentication_methods=[AuthenticationMethod.LDAP],
916 |             last_login=None,
917 |             created_at=datetime.utcnow(),
    |                        ^^^^^^^^^^^^^^^^^
918 |             updated_at=datetime.utcnow(),
919 |             is_active=True,
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/enterprise/auth.py:918:24
    |
916 |             last_login=None,
917 |             created_at=datetime.utcnow(),
918 |             updated_at=datetime.utcnow(),
    |                        ^^^^^^^^^^^^^^^^^
919 |             is_active=True,
920 |             requires_mfa=False,
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/enterprise/auth.py:944:24
    |
942 |             authentication_methods=[AuthenticationMethod.OAUTH2_OIDC],
943 |             last_login=None,
944 |             created_at=datetime.utcnow(),
    |                        ^^^^^^^^^^^^^^^^^
945 |             updated_at=datetime.utcnow(),
946 |             is_active=True,
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/enterprise/auth.py:945:24
    |
943 |             last_login=None,
944 |             created_at=datetime.utcnow(),
945 |             updated_at=datetime.utcnow(),
    |                        ^^^^^^^^^^^^^^^^^
946 |             is_active=True,
947 |             requires_mfa=False,
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/enterprise/auth.py:971:24
    |
969 |             authentication_methods=[AuthenticationMethod.SAML_SSO],
970 |             last_login=None,
971 |             created_at=datetime.utcnow(),
    |                        ^^^^^^^^^^^^^^^^^
972 |             updated_at=datetime.utcnow(),
973 |             is_active=True,
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/enterprise/auth.py:972:24
    |
970 |             last_login=None,
971 |             created_at=datetime.utcnow(),
972 |             updated_at=datetime.utcnow(),
    |                        ^^^^^^^^^^^^^^^^^
973 |             is_active=True,
974 |             requires_mfa=False,
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
    --> candidate/governance/identity/enterprise/auth.py:998:24
     |
 996 |             authentication_methods=[AuthenticationMethod.JWT_TOKEN],
 997 |             last_login=None,
 998 |             created_at=datetime.utcnow(),
     |                        ^^^^^^^^^^^^^^^^^
 999 |             updated_at=datetime.utcnow(),
1000 |             is_active=True,
     |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
    --> candidate/governance/identity/enterprise/auth.py:999:24
     |
 997 |             last_login=None,
 998 |             created_at=datetime.utcnow(),
 999 |             updated_at=datetime.utcnow(),
     |                        ^^^^^^^^^^^^^^^^^
1000 |             is_active=True,
1001 |             requires_mfa=False,
     |
help: Use `datetime.datetime.now(tz=...)` instead

ARG002 Unused method argument: `user_id`
    --> candidate/governance/identity/enterprise/auth.py:1036:33
     |
1034 |         return attributes
1035 |
1036 |     def _verify_totp_code(self, user_id: str, code: str) -> bool:
     |                                 ^^^^^^^
1037 |         """Verify TOTP code (placeholder implementation)."""
1038 |         # Real implementation would use PyOTP or similar
     |

ARG002 Unused method argument: `user_id`
    --> candidate/governance/identity/enterprise/auth.py:1042:32
     |
1040 |         return len(code) == 6 and code.isdigit()
1041 |
1042 |     def _verify_sms_code(self, user_id: str, code: str) -> bool:
     |                                ^^^^^^^
1043 |         """Verify SMS code (placeholder implementation)."""
1044 |         # Real implementation would check against sent SMS codes
     |

ARG002 Unused method argument: `user_id`
    --> candidate/governance/identity/enterprise/auth.py:1047:34
     |
1045 |         return len(code) == 6 and code.isdigit()
1046 |
1047 |     def _verify_email_code(self, user_id: str, code: str) -> bool:
     |                                  ^^^^^^^
1048 |         """Verify email code (placeholder implementation)."""
1049 |         # Real implementation would check against sent email codes
     |

RUF001 String contains ambiguous `â•±` (BOX DRAWINGS LIGHT DIAGONAL UPPER RIGHT TO LOWER LEFT). Did you mean `/` (SOLIDUS)?
  --> candidate/governance/identity/gateway/stargate_activation.py:74:18
   |
72 |             â•­â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•®
73 |             â•‘  â—    âš¡    âš¡    â—‘  â•‘
74 |             â•‘    â•±           â•²    â•‘
   |                  ^
75 |             â•‘   â•±             â•²   â•‘
76 |             â•‘  â—    âš¡    âš¡    â—‘  â•‘
   |

RUF001 String contains ambiguous `â•±` (BOX DRAWINGS LIGHT DIAGONAL UPPER RIGHT TO LOWER LEFT). Did you mean `/` (SOLIDUS)?
  --> candidate/governance/identity/gateway/stargate_activation.py:75:17
   |
73 |             â•‘  â—    âš¡    âš¡    â—‘  â•‘
74 |             â•‘    â•±           â•²    â•‘
75 |             â•‘   â•±             â•²   â•‘
   |                 ^
76 |             â•‘  â—    âš¡    âš¡    â—‘  â•‘
77 |             â•°â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¯
   |

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/gateway/stargate_gateway.py:246:26
    |
244 |         """Log gateway events with symbolic glyphs"""
245 |         event = {
246 |             "timestamp": datetime.utcnow().isoformat(),
    |                          ^^^^^^^^^^^^^^^^^
247 |             "event_type": event_type,
248 |             "details": kwargs,
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/gateway/stargate_gateway.py:276:30
    |
274 |             self.log_event("supervisor_override", user_id=payload.user_id, glyph="ðŸ‘¤")
275 |             self.supervisor_overrides[payload.user_id] = {
276 |                 "timestamp": datetime.utcnow(),
    |                              ^^^^^^^^^^^^^^^^^
277 |                 "reason": "Manual authentication override",
278 |             }
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/gateway/stargate_gateway.py:348:28
    |
346 |             "session_key": session_key,  # Internal key for operations
347 |             "public_verification_hash": session_data.get("public_verification_hash", ""),
348 |             "established": datetime.utcnow(),
    |                            ^^^^^^^^^^^^^^^^^
349 |             "status": "active",
350 |             "supervisor_override": supervisor_override,
    |
help: Use `datetime.datetime.now(tz=...)` instead

E501 Line too long (138 > 120)
   --> candidate/governance/identity/gateway/stargate_gateway.py:713:121
    |
711 | â€¦
712 | â€¦
713 | â€¦ the user's mental state and cultural context throughout your response.""",
    |                                                           ^^^^^^^^^^^^^^^^^^
714 | â€¦
715 | â€¦
    |

E501 Line too long (151 > 120)
   --> candidate/governance/identity/gateway/stargate_gateway.py:717:120
    |
715 | â€¦
716 | â€¦
717 | â€¦stand this is a consciousness-aware transmission from the LUKHÎ›S system. I will:
    |                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
718 | â€¦
719 | â€¦
    |

E501 Line too long (143 > 120)
   --> candidate/governance/identity/gateway/stargate_gateway.py:768:120
    |
766 | â€¦
767 | â€¦
768 | â€¦, where patterns dance like auroras across the quantum field of possibility.
    |                                                       ^^^^^^^^^^^^^^^^^^^^^^^
769 | â€¦
770 | â€¦
    |

E501 Line too long (129 > 120)
   --> candidate/governance/identity/gateway/stargate_gateway.py:773:121
    |
772 | ðŸŒˆ CREATIVE SYNTHESIS:
773 | Your request opens a kaleidoscope of interconnected meanings. Like a jazz improvisation on the theme of identity, we can explore:
    |                                                                                                                         ^^^^^^^^^
774 |
775 | âœ¨ **Metaphorical Architecture**:
    |

E501 Line too long (172 > 120)
   --> candidate/governance/identity/gateway/stargate_gateway.py:790:120
    |
788 | â€¦
789 | â€¦
790 | â€¦ of your existence, painting your digital presence with the colors of consciousness itself.
    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
791 | â€¦
792 | â€¦
    |

E501 Line too long (128 > 120)
   --> candidate/governance/identity/gateway/stargate_gateway.py:831:120
    |
829 |    | Quantum      | Ed448      | 100%         |
830 |
831 | ðŸ“ CONCLUSION: The LUKHÎ›S architecture demonstrates mathematical elegance in balancing security with consciousness preservation.
    |                                                                                                                         ^^^^^^^^
832 |
833 | [ðŸ“Š Analytical precision maintained]
    |

E501 Line too long (179 > 120)
   --> candidate/governance/identity/gateway/stargate_gateway.py:865:122
    |
863 | â€¦
864 | â€¦
865 | â€¦ess itself. The LUKHÎ›S system breathes with you, adapts with you, protects with gentle strength.
    |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
866 | â€¦
867 | â€¦
    |

E501 Line too long (151 > 120)
   --> candidate/governance/identity/gateway/stargate_gateway.py:892:121
    |
890 | â€¦
891 | â€¦
892 | â€¦ng user consciousness state. No extraneous features. Maximum efficiency achieved.
    |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
893 | â€¦
894 | â€¦
    |

E501 Line too long (149 > 120)
   --> candidate/governance/identity/gateway/stargate_gateway.py:909:121
    |
907 | â€¦
908 | â€¦
909 | â€¦ssly. The LUKHÎ›S system flows like water, adapting to every contour of identity:
    |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
910 | â€¦
911 | â€¦
    |

E501 Line too long (234 > 120)
   --> candidate/governance/identity/gateway/stargate_gateway.py:916:121
    |
914 | â€¦
915 | â€¦
916 | â€¦sly. The iris scanner reads not just patterns but intentions. The consent chain validates not just permissions but purpose.
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
917 | â€¦
918 | â€¦xperience of seamless, secure identity.
    |

E501 Line too long (150 > 120)
   --> candidate/governance/identity/gateway/stargate_gateway.py:918:121
    |
916 | â€¦ponent knows its role and executes flawlessly. The iris scanner reads not just patterns but intentions. The consent chain validates â€¦
917 | â€¦
918 | â€¦ars into pure function, leaving only the experience of seamless, secure identity.
    |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
919 | â€¦
920 | â€¦
    |

E501 Line too long (227 > 120)
   --> candidate/governance/identity/gateway/stargate_gateway.py:943:121
    |
941 | â€¦
942 | â€¦
943 | â€¦n't words - they're the way you move through digital space, the rhythm of your keystrokes, the dance of your attention.
    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
944 | â€¦
945 | â€¦e it's needed, growing into forests of possibility.
    |

E501 Line too long (159 > 120)
   --> candidate/governance/identity/gateway/stargate_gateway.py:945:121
    |
943 | â€¦ou can answer. But the riddles aren't words - they're the way you move through digital space, the rhythm of your keystrokes, the danâ€¦
944 | â€¦
945 | â€¦different permission, landing where it's needed, growing into forests of possibility.
    |                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
946 | â€¦
947 | â€¦ugh recognition of the soul's unique frequency. The iris lock opens not with photons but with the light of consciousness itself.
    |

E501 Line too long (202 > 120)
   --> candidate/governance/identity/gateway/stargate_gateway.py:947:121
    |
945 | â€¦ landing where it's needed, growing into forests of possibility.
946 | â€¦
947 | â€¦e soul's unique frequency. The iris lock opens not with photons but with the light of consciousness itself.
    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
948 | â€¦
949 | â€¦
    |

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/gateway/stargate_gateway.py:986:26
    |
984 |         audit_data = {
985 |             "transmission_id": f"TX_{secrets.token_hex(8)}",
986 |             "timestamp": datetime.utcnow().isoformat(),
    |                          ^^^^^^^^^^^^^^^^^
987 |             "source": payload.source_agent,
988 |             "target": payload.target_agent,
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
    --> candidate/governance/identity/gateway/stargate_gateway.py:1013:26
     |
1012 |         log_entry = {
1013 |             "timestamp": datetime.utcnow().isoformat(),
     |                          ^^^^^^^^^^^^^^^^^
1014 |             "success": response.success,
1015 |             "audit_trail": response.audit_trail,
     |
help: Use `datetime.datetime.now(tz=...)` instead

ARG002 Unused method argument: `identity_data`
   --> candidate/governance/identity/identity_validator.py:497:9
    |
495 |         self,
496 |         validation: IdentityValidation,
497 |         identity_data: dict[str, Any],
    |         ^^^^^^^^^^^^^
498 |         context: dict[str, Any],
499 |     ):
    |

ARG002 Unused method argument: `user_id`
  --> candidate/governance/identity/interface.py:62:33
   |
61 |     class ConsentManager:
62 |         def check_consent(self, user_id: str, action: str) -> bool:
   |                                 ^^^^^^^
63 |             return True
   |

ARG002 Unused method argument: `action`
  --> candidate/governance/identity/interface.py:62:47
   |
61 |     class ConsentManager:
62 |         def check_consent(self, user_id: str, action: str) -> bool:
   |                                               ^^^^^^
63 |             return True
   |

ARG002 Unused method argument: `user_id`
  --> candidate/governance/identity/interface.py:66:37
   |
65 |     class LambdIDValidator:
66 |         def validate_identity(self, user_id: str) -> bool:
   |                                     ^^^^^^^
67 |             return True
   |

SIM102 Use a single `if` statement instead of nested `if` statements
   --> candidate/governance/identity/lambda_id_auth.py:410:13
    |
408 |               bio_hash = self.hasher.hash_biometric(bio_data)
409 |               # For testing, accept mock biometric hashes
410 | /             if stored_hash and not stored_hash.startswith("mock_"):
411 | |                 if not secrets.compare_digest(bio_hash, stored_hash):
    | |_____________________________________________________________________^
412 |                       return {"success": False, "error": "Multi-factor biometric failed"}
    |
help: Combine `if` statements using `and`

PERF203 `try`-`except` within a loop incurs performance overhead
   --> candidate/governance/identity/qrg_coverage_integration.py:131:13
    |
129 |                   __import__(module_name)
130 |                   logger.debug(f"âœ… Module {module_name} available")
131 | /             except ImportError:
132 | |                 logger.warning(f"âš ï¸ Module {module_name} not available")
    | |_______________________________________________________________________^
133 |
134 |           # Validate configuration
    |

PERF203 `try`-`except` within a loop incurs performance overhead
   --> candidate/governance/identity/qrg_coverage_integration.py:152:13
    |
150 |                       test_instance.setUp()
151 |                   logger.debug(f"âœ… Test component {test_name} initialized")
152 | /             except Exception as e:
153 | |                 logger.warning(f"âš ï¸ Test component {test_name} initialization issue: {e}")
    | |_________________________________________________________________________________________^
154 |
155 |           logger.info("Test component initialization complete")
    |

ARG002 Unused method argument: `test_categories`
   --> candidate/governance/identity/qrg_coverage_integration.py:268:15
    |
267 |     def _run_test_suite_sync(
268 |         self, test_categories: Optional[list[str]], test_config: TestConfiguration
    |               ^^^^^^^^^^^^^^^
269 |     ) -> tuple[Any, float]:
270 |         """Synchronous test suite execution"""
    |

ARG002 Unused method argument: `test_config`
   --> candidate/governance/identity/qrg_coverage_integration.py:268:53
    |
267 |     def _run_test_suite_sync(
268 |         self, test_categories: Optional[list[str]], test_config: TestConfiguration
    |                                                     ^^^^^^^^^^^
269 |     ) -> tuple[Any, float]:
270 |         """Synchronous test suite execution"""
    |

ARG002 Unused method argument: `test_result`
   --> candidate/governance/identity/qrg_coverage_integration.py:299:42
    |
297 |         ]
298 |
299 |     def _analyze_test_distribution(self, test_result: Any) -> dict[str, int]:
    |                                          ^^^^^^^^^^^
300 |         """Analyze the distribution of tests across categories"""
301 |         return {
    |

ARG002 Unused method argument: `specific_tests`
   --> candidate/governance/identity/qrg_coverage_integration.py:339:35
    |
338 |     async def run_targeted_tests(
339 |         self, test_category: str, specific_tests: Optional[list[str]] = None
    |                                   ^^^^^^^^^^^^^^
340 |     ) -> dict[str, Any]:
341 |         """
    |

E501 Line too long (124 > 120)
   --> candidate/governance/identity/qrg_integration.py:167:120
    |
165 |         self.logger.info("ðŸ”— LUKHAS QRG Integrator initialized")
166 |         self.logger.info(
167 |             f"ðŸ§  Consciousness engine: {'active' if hasattr(self.consciousness_engine, 'assess_consciousness') else 'mock'}"
    |                                                                                                                         ^^^^
168 |         )
169 |         self.logger.info(
    |

ARG001 Unused function argument: `style`
  --> candidate/governance/identity/qrg_showcase.py:36:67
   |
36 | def create_ascii_qr_pattern(size: int = 25, density: float = 0.5, style: str = "standard") -> str:
   |                                                                   ^^^^^
37 |     """Create a simple ASCII QR pattern for visualization"""
38 |     pattern = "â”Œ" + "â”€" * (size + 2) + "â”\n"
   |

F821 Undefined name `secrets`
  --> candidate/governance/identity/qrg_showcase.py:43:16
   |
41 |         row = "â”‚"
42 |         for _j in range(size):
43 |             if secrets.randbelow(101) / 100 < density:
   |                ^^^^^^^
44 |                 row += "â–ˆâ–ˆ"
45 |             else:
   |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
  --> candidate/governance/identity/qrg_showcase.py:71:27
   |
69 |             "user_profiles_tested": 0,
70 |             "performance_metrics": [],
71 |             "start_time": datetime.now(),
   |                           ^^^^^^^^^^^^^^
72 |         }
   |
help: Pass a `datetime.timezone` object to the `tz` parameter

PERF203 `try`-`except` within a loop incurs performance overhead
   --> candidate/governance/identity/qrg_showcase.py:337:13
    |
335 |                   time.sleep(0.5)
336 |
337 | /             except Exception as e:
338 | |                 print(f"   âŒ Error demonstrating {user_profile['name']}: {e}")
    | |_______________________________________________________________________________^
339 |
340 |           return self._generate_showcase_summary(showcase_results)
    |

E501 Line too long (163 > 120)
   --> candidate/governance/identity/qrg_showcase.py:380:120
    |
378 | â€¦
379 | â€¦
380 | â€¦result.cultural_safety_score:.2f}, Consciousness={result.consciousness_resonance:.2f}"
    |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
381 | â€¦
    |

E501 Line too long (163 > 120)
   --> candidate/governance/identity/qrg_showcase.py:493:120
    |
492 | â€¦
493 | â€¦rofile']['name']} ({best_consciousness['qrg_result']['consciousness_resonance']:.3f})"
    |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
494 | â€¦
495 | â€¦
    |

E501 Line too long (146 > 120)
   --> candidate/governance/identity/qrg_showcase.py:496:120
    |
494 | â€¦
495 | â€¦
496 | â€¦ofile']['name']} ({fastest_generation['qrg_result']['generation_time']:.3f}s)"
    |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^
497 | â€¦
498 | â€¦
    |

E501 Line too long (146 > 120)
   --> candidate/governance/identity/qrg_showcase.py:499:120
    |
497 | â€¦
498 | â€¦
499 | â€¦ofile']['name']} ({highest_compliance['qrg_result']['compliance_score']:.3f})"
    |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^
500 | â€¦
    |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/qrg_showcase.py:541:21
    |
539 |     def save_showcase_results(self, summary: dict[str, Any]):
540 |         """Save showcase results to file"""
541 |         timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    |                     ^^^^^^^^^^^^^^
542 |         filename = f"lukhus_qrg_showcase_{timestamp}.json"
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> candidate/governance/identity/qrg_showcase.py:547:26
    |
545 |         json_data = {
546 |             "showcase_summary": summary,
547 |             "timestamp": datetime.now().isoformat(),
    |                          ^^^^^^^^^^^^^^
548 |             "system_info": {
549 |                 "version": "LUKHAS QRG Showcase v1.0",
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

PERF203 `try`-`except` within a loop incurs performance overhead
   --> candidate/governance/identity/qrg_showcase.py:605:9
    |
603 |               demo_result = showcase.run_specific_qrg_type_demo(qrg_type)
604 |               specific_demos[qrg_type.value] = demo_result
605 | /         except Exception as e:
606 | |             print(f"   âš ï¸ Error in {qrg_type.value} demo: {e}")
    | |______________________________________________________________^
607 |
608 |       summary["specific_demos"] = specific_demos
    |

PERF203 `try`-`except` within a loop incurs performance overhead
   --> candidate/governance/identity/tools/onboarding_cli.py:336:13
    |
334 |                   rating = input(f"{aspect.replace('_', ' ').title()} (1-5): ").strip()
335 |                   consciousness_data[aspect] = float(rating) / 5.0 if rating.isdigit() and 1 <= int(rating) <= 5 else 0.5
336 | /             except (KeyboardInterrupt, EOFError, ValueError) as e:
337 | |                 logger.warning(f"Error collecting consciousness aspect {aspect}: {e}")
338 | |                 consciousness_data[aspect] = 0.5
    | |________________________________________________^
339 |
340 |           return {"consciousness_metrics": consciousness_data}
    |

ARG002 Unused method argument: `dominant_state`
   --> candidate/governance/identity/unified_login_interface.py:212:34
    |
210 |         return recommendations.get(state, [AuthMethod.EMOJI_CONSCIOUSNESS])
211 |
212 |     def _get_ui_adaptation(self, dominant_state: ConsciousnessState, scores: dict) -> UIAdaptation:
    |                                  ^^^^^^^^^^^^^^
213 |         """Determine UI adaptation based on consciousness state"""
214 |         if scores[ConsciousnessState.FOCUSED] > 0.7:
    |

ARG002 Unused method argument: `language`
   --> candidate/governance/identity/unified_login_interface.py:263:36
    |
261 |         }
262 |
263 |     def _infer_cultural_type(self, language: str, region: str) -> str:
    |                                    ^^^^^^^^
264 |         """Infer cultural type from language and region"""
265 |         high_context_regions = ["asia", "middle_east", "africa", "latin_america"]
    |

ARG002 Unused method argument: `user_id`
   --> candidate/governance/identity/unified_login_interface.py:841:38
    |
840 |     # Mock admin interface methods (would connect to real monitoring systems)
841 |     async def _get_access_logs(self, user_id: str) -> list[dict[str, Any]]:
    |                                      ^^^^^^^
842 |         """Get access logs for admin interface"""
843 |         return [
    |

ARG002 Unused method argument: `user_id`
   --> candidate/governance/identity/unified_login_interface.py:851:47
    |
849 |         ]
850 |
851 |     async def _get_consciousness_traces(self, user_id: str) -> dict[str, Any]:
    |                                               ^^^^^^^
852 |         """Get consciousness traces for monitoring"""
853 |         return {"consciousness_evolution": "improving", "stability": "high"}
    |

ARG002 Unused method argument: `user_id`
   --> candidate/governance/identity/unified_login_interface.py:855:45
    |
853 |         return {"consciousness_evolution": "improving", "stability": "high"}
854 |
855 |     async def _get_cultural_analytics(self, user_id: str) -> dict[str, Any]:
    |                                             ^^^^^^^
856 |         """Get cultural analytics data"""
857 |         return {"cultural_alignment": "optimal", "adaptation_success": "high"}
    |

ARG002 Unused method argument: `user_id`
   --> candidate/governance/identity/unified_login_interface.py:859:42
    |
857 |         return {"cultural_alignment": "optimal", "adaptation_success": "high"}
858 |
859 |     async def _get_compliance_data(self, user_id: str) -> dict[str, Any]:
    |                                          ^^^^^^^
860 |         """Get compliance monitoring data"""
861 |         return {"gdpr_compliant": True, "constitutional_alignment": "verified"}
    |

ARG002 Unused method argument: `user_id`
   --> candidate/governance/identity/unified_login_interface.py:863:42
    |
861 |         return {"gdpr_compliant": True, "constitutional_alignment": "verified"}
862 |
863 |     async def _get_symbolic_traces(self, user_id: str) -> dict[str, Any]:
    |                                          ^^^^^^^
864 |         """Get symbolic trace audit data"""
865 |         return {"symbolic_integrity": "verified", "qi_signatures": "valid"}
    |

E501 Line too long (124 > 120)
   --> candidate/governance/identity/unified_login_interface.py:910:120
    |
908 |     print(f"ðŸ“ Next Step: {response.next_step.value if response.next_step else 'Complete'}")
909 |     print(
910 |         f"ðŸ§  Consciousness State: {response.debug_info.get('detected_consciousness') if response.debug_info else 'Unknown'}"
    |                                                                                                                         ^^^^
911 |     )
912 |     print(f"ðŸŒ Cultural Type: {response.debug_info.get('cultural_type') if response.debug_info else 'Unknown'}")
    |

B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
  --> candidate/governance/identity/utils/qrg_parser.py:35:13
   |
33 |             return {"type": key, "payload": value}
34 |         except Exception as e:
35 |             raise ValueError(f"Invalid QR-G data: {e}")
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
36 |
37 |     def validate_qr_format(self, qr_data: str) -> bool:
   |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
  --> candidate/governance/identity/wearables_integration/entropy_beacon.py:62:16
   |
60 |     def get_current_time(self):
61 |         """Get the current time for timestamping."""
62 |         return datetime.now().isoformat()
   |                ^^^^^^^^^^^^^^
63 |
64 |     def sign_broadcast(self, entropy_value):
   |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/zkproof/multimodal_zk_engine.py:177:29
    |
175 |             aggregated_proof=aggregated_proof,
176 |             verification_key=verification_key,
177 |             proof_timestamp=datetime.utcnow(),
    |                             ^^^^^^^^^^^^^^^^^
178 |             validity_window=timedelta(minutes=10),
179 |         )
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/zkproof/multimodal_zk_engine.py:199:26
    |
197 |         verification_results = {
198 |             "proof_id": proof.proof_id,
199 |             "timestamp": datetime.utcnow().isoformat(),
    |                          ^^^^^^^^^^^^^^^^^
200 |             "checks": {},
201 |         }
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/zkproof/multimodal_zk_engine.py:204:12
    |
203 |         # Check proof freshness
204 |         if datetime.utcnow() > proof.proof_timestamp + proof.validity_window:
    |            ^^^^^^^^^^^^^^^^^
205 |             verification_results["checks"]["freshness"] = False
206 |             return False, {"error": "Proof expired", "results": verification_results}
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/zkproof/multimodal_zk_engine.py:296:27
    |
294 |                 commitment_hash=commitment_hash,
295 |                 nullifier=nullifier,
296 |                 timestamp=datetime.utcnow(),
    |                           ^^^^^^^^^^^^^^^^^
297 |                 quality_score=quality_score,
298 |                 consciousness_binding=consciousness_binding,
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/zkproof/multimodal_zk_engine.py:338:26
    |
336 |             "coherence_score": consciousness_data.get("coherence", 0.8),
337 |             "proof_data": proof_data,
338 |             "timestamp": datetime.utcnow().isoformat(),
    |                          ^^^^^^^^^^^^^^^^^
339 |         }
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/zkproof/multimodal_zk_engine.py:367:26
    |
365 |             "cultural_region": cultural_context.get("region"),
366 |             "proof_data": proof_data,
367 |             "timestamp": datetime.utcnow().isoformat(),
    |                          ^^^^^^^^^^^^^^^^^
368 |         }
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/zkproof/multimodal_zk_engine.py:400:26
    |
398 |             "consistency_window": self.t5_requirements["temporal_consistency_window"].total_seconds(),
399 |             "proof_data": proof_data,
400 |             "timestamp": datetime.utcnow().isoformat(),
    |                          ^^^^^^^^^^^^^^^^^
401 |         }
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/zkproof/multimodal_zk_engine.py:429:26
    |
427 |             "alignment_score": constitutional_responses.get("alignment_score", 0.9),
428 |             "proof_data": proof_data,
429 |             "timestamp": datetime.utcnow().isoformat(),
    |                          ^^^^^^^^^^^^^^^^^
430 |         }
    |
help: Use `datetime.datetime.now(tz=...)` instead

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/zkproof/multimodal_zk_engine.py:442:26
    |
440 |             "proof_count": len(valid_proofs),
441 |             "proof_types": [p["proof_type"] for p in valid_proofs],
442 |             "timestamp": datetime.utcnow().isoformat(),
    |                          ^^^^^^^^^^^^^^^^^
443 |             "proofs": valid_proofs,
444 |         }
    |
help: Use `datetime.datetime.now(tz=...)` instead

ARG002 Unused method argument: `user_commitment`
   --> candidate/governance/identity/zkproof/multimodal_zk_engine.py:503:76
    |
501 |         return coherence_score >= threshold
502 |
503 |     async def _verify_temporal_proof(self, temporal_proof: dict[str, Any], user_commitment: str) -> bool:
    |                                                                            ^^^^^^^^^^^^^^^
504 |         """Verify temporal consistency proof"""
    |

DTZ003 `datetime.datetime.utcnow()` used
   --> candidate/governance/identity/zkproof/multimodal_zk_engine.py:597:23
    |
596 |         # Keep only recent commitments
597 |         cutoff_time = datetime.utcnow() - timedelta(hours=24)
    |                       ^^^^^^^^^^^^^^^^^
598 |         self.commitment_store[user_id] = [c for c in self.commitment_store[user_id] if c.timestamp > cutoff_time]
    |
help: Use `datetime.datetime.now(tz=...)` instead

ARG002 Unused method argument: `nullifier`
   --> candidate/governance/identity/zkproof/multimodal_zk_engine.py:600:34
    |
598 |         self.commitment_store[user_id] = [c for c in self.commitment_store[user_id] if c.timestamp > cutoff_time]
599 |
600 |     def _is_nullifier_used(self, nullifier: str) -> bool:
    |                                  ^^^^^^^^^
601 |         """Check if nullifier has been used (prevent replay)"""
602 |         # In production, use persistent storage
    |

Found 761 errors.
No fixes available (2 hidden fixes can be enabled with the `--unsafe-fixes` option).
