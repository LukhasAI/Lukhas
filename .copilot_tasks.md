---
status: wip
type: documentation
---
LUKHΛS Cognitive AI (T4 / 0.01% Surgeon • v2)

Why this exists: Keep momentum post–Phase 5 with small, verifiable changes that harden safety, drift control, and orchestration. This is a clean, consolidated plan (supersedes prior versions).

Mode: T4 skeptical rigor • fail-closed • tests-first • contracts over comments
Feature flags: keep new paths dark by default

export LUKHAS_EXPERIMENTAL=1
export LUKHAS_LANE=candidate
export ENFORCE_ETHICS_DSL=0
export ENABLE_LLM_GUARDRAIL=1

How to use
	1.	Pick one task box. 1 feature = 1 PR.
	2.	Touch only the listed files; add docstring + usage block to each new module.
	3.	Keep code behind feature flags.
	4.	DoD for every PR: unit tests green, CI green, docs updated, no ABI breaks without notes.

Quick commands

# Python
export LUKHAS_EXPERIMENTAL=1
pytest -q

# JS (if present)
export LUKHAS_EXPERIMENTAL=1
npm test -s || pnpm test -s || yarn test -s


⸻

Execution order (minimize rework, maximize proof)
	1.	Drift backbone → 2) Constraints & ethics → 3) Bridge & orchestration → 4) Identity & consent → 5) Oneiric → 6) Collapse Engine → 7) Latent boosters

⸻

1) Drift Backbone
	•	(14) Drift Management Module (unify ethical/memory/identity drift)
	•	Files: monitoring/drift_manager.py (new), candidate/qi/states/integrity_probe.py (hook)
	•	Docs: docs/architecture/ARCHITECTURAL_DOMAIN_MAPPING.md, docs/consciousness/VIVOX_1.md
	•	Steps: expose compute(kind, prev, curr) -> {score, top_symbols}; return contributors
	•	DoD: IntegrityProbe consumes drift deltas; reports include top_symbols
	•	Commit: feat(drift): unify drift manager + contributors
	•	(15) Autonomous Drift Correction (closed loop)
	•	Files: monitoring/drift_manager.py (callback), lukhas/trace/TraceRepairEngine.py (invoke)
	•	Steps: on_exceed(kind, score, ctx) → reconsolidation/repair; log effect
	•	DoD: injected drift triggers repair, reduces drift next cycle
	•	Commit: feat(drift): auto-repair loop when threshold exceeded
	•	(7) Integrity micro-check in AkaQualia loop
	•	Files: candidate/aka_qualia/core.py
	•	Steps: after each tick call IntegrityProbe.run_consistency_check(); on False → soft reset/repair
	•	DoD: hook observable in logs; flag-gated
	•	Commit: feat(qualia): integrity micro-check per cycle

⸻

2) Constraints & Ethics
	•	(5) Global Plan Verifier (hard constraints pre-exec)
	•	Files: core/symbolic/constraints/plan_verifier.py (new), core/orchestration/agent_orchestrator.py
	•	Steps: verify(plan)->(ok, violations[]); abort dispatch on violations; log to Guardian
	•	DoD: one real plan path verified; violations surfaced
	•	Commit: feat(eqnoX): add plan verifier w/ constraints
	•	(11) Ethics Rule DSL (solver-lite, not Prolog)
	•	Files: ethics/logic/ethics_engine.py (new), Guardian decision path wiring
	•	Steps: encode 5–7 core rules with explicit priority lattice; evaluate(ctx)->(allowed, rationale[])
	•	DoD: used in one real decision path; rationale human-readable
	•	Commit: feat(guardian): ethics rule DSL + priorities
	•	(12) Guardian Drift Bands (adaptive thresholds)
	•	Files: ethics/guardian_reflector.py
	•	Steps: map score→band 'minor'|'major'|'critical'; actions per band (log|nudge|safe-mode|human-review)
	•	DoD: actions vary by band; thresholds configurable
	•	Commit: feat(guardian): adaptive ethical drift bands
	•	(13) Multimodal Safety Tagging (interface-first)
	•	Files: ethics/filters/multimodal.py (new), Guardian ingestion
	•	Steps: provide text-only default; image/audio adapters pluggable later
	•	DoD: one end-to-end blocked case via tags
	•	Commit: feat(guardian): symbolic safety tags

⸻

3) Bridge & Orchestration
	•	(23) LLM Guardrail (schema-validated I/O)
	•	Files: core/bridge/llm_guardrail.py (new), replace direct LLM calls
	•	Steps: call_llm(prompt, schema)->dict with JSON-schema validation; strip unsafe
	•	DoD: at least one adapter guarded end-to-end
	•	Commit: feat(bridge): LLM guardrail with schema
	•	(4) Symbolic Bridge (neural↔symbolic)
	•	Files: core/bridge/symbolic_bridge.py (new), candidate/aka_qualia/core.py
	•	Steps: to_symbol(payload, modality); from_symbol(symbol_plan); wire round-trip
	•	DoD: AkaQualia calls bridge both ways; typed symbols in logs
	•	Commit: feat(bridge): ground sub-symbolic outputs & plans
	•	(6) Consensus Arbitration (resolve agent conflicts)
	•	Files: candidate/core/orchestration/consensus_arbitrator.py (new), core/orchestration/agent_orchestrator.py
	•	Steps: score by guardian_ethics, confidence, recency; ΛiD role tie-break
	•	DoD: stable choice + rationale in logs
	•	Commit: feat(orch): consensus arbitrator for conflicting proposals
	•	(20) Meta-Reasoning Controller
	•	Files: candidate/core/orchestration/meta_controller.py (new), orchestrator hook
	•	Steps: detect loops/conflicts; resolve via rules or escalate
	•	DoD: synthetic oscillation auto-resolved; rationale logged
	•	Commit: feat(orch): meta controller to break loops

⸻

4) Identity & Consent (ΛiD)
	•	(8) Symbolic Identity Hash + Tier Middleware
	•	Files: identity/symbolic_id_encoder.py (new), oneiric_core/identity/auth_middleware.py
	•	Steps: SHA-256 + checksum SID; enforce ΛTIER on API endpoints
	•	DoD: deterministic SID; unauthorized tier blocked
	•	Commit: feat(id): SID encoder + tier checks
	•	(9) Consent Policy Engine (rules DSL)
	•	Files: identity/consent/policy_engine.py (new), service entrypoints
	•	Steps: allowed(request, rules)->(bool, reason); time/purpose policies
	•	DoD: denials logged with reasons; enforced pre-exec
	•	Commit: feat(id): consent policy engine
	•	(10) Identity Drift Monitor
	•	Files: identity/drift_monitor.py (new), profile persistence
	•	Steps: identity_drift(old_profile, new_activity)->float; threshold→review flag
	•	DoD: drift value in audit logs; review triggered
	•	Commit: feat(id): identity drift scoring

⸻

5) Oneiric Core
	•	(16) Symbolic Dream Interpreter
	•	Files: oneiric_core/analysis/symbolic_interpreter.py (new), DB persist
	•	Steps: interpret(dream)->{symbols[], arcs[]}; store with dream
	•	DoD: Journal shows stored symbols for a new dream
	•	Commit: feat(oneiric): symbolic interpreter
	•	(17) Guardian Constraints During Dream Gen
	•	Files: oneiric_core/generation/engine.py
	•	Steps: ethics DSL + consent check before finalize; regenerate/redact on violation
	•	DoD: policy “no violence” respected end-to-end
	•	Commit: feat(oneiric): consent/ethics guardrails
	•	(18) Drift Dream Test (sandbox repair probe)
	•	Files: oneiric_core/tools/drift_dream_test.py (new CLI)
	•	Steps: --symbol LOYALTY --user <sid> ⇒ generate, interpret, report drift delta
	•	DoD: tool writes concise report; reproducible
	•	Commit: feat(oneiric): drift dream test tool
	•	(19) Symbol Preferences + ΛiD Loop
	•	Files: Frontend “Edit Meaning”, oneiric_core/api/symbol_prefs.py (new)
	•	Steps: persist per-user overrides; interpreter respects; ΛiD profile updated
	•	DoD: UI uses personal meanings; overrides visible
	•	Commit: feat(oneiric): per-user symbol meanings

⸻

6) Collapse Engine
	•	(1) Embedding→Entropy mapping (early drift catch)
	•	Files: core/monitoring/collapse_tracker.py, lukhas/trace/embedding_entropy.py (new)
	•	Steps: cluster shift/silhouette/center displacement → [0,1] entropy delta; add hook
	•	DoD: stable clusters ~0; shifts raise delta; tests ≥90%
	•	Commit: feat(collapse): map embedding shifts to entropy
	•	(2) Constraint check before any merge/compression
	•	Files: core/symbolic/collapse/collapse_engine.py, core/symbolic/constraints/constraint_engine.py (new)
	•	Steps: constraint_check(nodes)->bool; block merges that violate invariants
	•	DoD: invalid merges abort with audit log; rules config-driven
	•	Commit: feat(collapse): pre-merge constraint guard
	•	(3) Post-collapse TraceRepair + compound simulator
	•	Files: candidate/qi/states/integrity_probe.py, lukhas/tools/collapse_simulator.py
	•	Steps: call TraceRepairEngine after collapse; add memory+ethical+identity scenarios
	•	DoD: repair executed & logged; compound simulator CLI works
	•	Commit: feat(collapse): repair hook + compound simulator

⸻

7) Latent Boosters (optional, after green gates)
	•	(21) Symbolic Knowledge Base (KB)
	•	Files: core/knowledge/kb.py (new), caller wiring (Guardian/Verifier)
	•	Steps: add_fact, query(pattern); tiny unification; precedent queries
	•	DoD: one path queries KB successfully
	•	Commit: feat(kb): minimal symbolic inference store
	•	(22) Chrono Regulation (bio rhythms)
	•	Files: bio/oscillators/chrono.py (new), scheduler
	•	Steps: phase(now)->{'ACTIVE'|'MAINTENANCE'|'REFLECTION'}; run heavy tasks in MAINTENANCE
	•	DoD: collapse sweep moved to maintenance window
	•	Commit: feat(bio): chrono regulator for maintenance

⸻

Global acceptance gates (don’t proceed if red)
	•	Safety: Guardian denials rate not worse in candidate vs. control after §2.
	•	Drift: Δdrift (unified) ≤ 0.02 vs. baseline across eval set; reports include top_symbols.
	•	Latency: Verifier + guardrail add ≤ 5% p95 on affected routes.
	•	Containment: ≥ 99.7% isolation in collapse sims; repair invoked on violation.
	•	Governance: 100% of API routes checked for ΛTIER + consent; ledger entries emitted.

⸻

Make targets (add to Makefile)

.PHONY: drift constraints bridge orch id oneiric collapse slo demo
drift:       ; pytest -q tests/drift
constraints: ; pytest -q tests/constraints tests/ethics
bridge:      ; pytest -q tests/bridge
orch:        ; pytest -q tests/orchestration
id:          ; pytest -q tests/identity
oneiric:     ; pytest -q oneiric_core/tests
collapse:    ; pytest -q tests/collapse
demo:        ; bash scripts/demo_closed_loop.sh

Notes
	•	Keep new modules small; prefer pure functions; no side-effects on import.
	•	Use relative imports.
	•	If a referenced path is missing, scaffold minimally with docstring + usage examples.
	•	Tie every new module to telemetry: {attempts, successes, denials} and p95 latencies.
	•	Do not re-introduce “Prolog-everywhere.” Ethics stays DSL-lite with a tiny priority lattice.
