#!/usr/bin/env python3
"""
Pre-commit security hook for LUKHAS
Prevents committing code with known security vulnerabilities
"""

import json
import subprocess
import sys
from pathlib import Path


def check_dependencies():
    """Check for security vulnerabilities in dependencies"""
    print("üîí Checking for security vulnerabilities...")

    # Quick check with safety
    result = subprocess.run(
        ['python3', '-m', 'safety', 'check', '--json'],
        capture_output=True,
        text=True
    )

    if result.returncode == 0:
        print("‚úÖ No security vulnerabilities found")
        return True

    # Parse vulnerabilities
    try:
        data = json.loads(result.stdout)
        vulns = data.get('vulnerabilities', [])

        if vulns:
            print(f"\n‚ùå Found {len(vulns)} security vulnerabilities:\n")

            for vuln in vulns[:5]:  # Show first 5
                print(f"  üì¶ {vuln.get('package_name')}")
                print(f"     Current: {vuln.get('analyzed_version')}")
                print(f"     Safe: {vuln.get('safe_version')}")
                print(f"     Severity: {vuln.get('severity', 'unknown')}")
                print()

            if len(vulns) > 5:
                print(f"  ... and {len(vulns) - 5} more\n")

            print("üí° To fix vulnerabilities, run:")
            print("   make security-fix")
            print("   or")
            print("   python scripts/security-autopilot.py fix")
            print("\n‚ùå Commit blocked due to security vulnerabilities")
            return False
    except:
        # If we can't parse, allow commit but warn
        print("‚ö†Ô∏è Could not parse security scan results")
        return True

    return True


def check_secrets():
    """Check for accidentally committed secrets"""
    print("üîç Checking for secrets...")

    # Use git secrets or gitleaks if available
    result = subprocess.run(
        ['git', 'diff', '--cached', '--name-only'],
        capture_output=True,
        text=True
    )

    changed_files = result.stdout.strip().split('\n') if result.stdout else []

    # Basic patterns to check
    secret_patterns = [
        'api_key',
        'secret_key',
        'password',
        'token',
        'private_key',
        'aws_access_key',
    ]

    for file in changed_files:
        if not file or not Path(file).exists():
            continue

        try:
            with open(file, 'r') as f:
                content = f.read().lower()

                for pattern in secret_patterns:
                    if pattern in content and '=' in content:
                        # Check if it looks like an actual secret assignment
                        lines = content.split('\n')
                        for line in lines:
                            if pattern in line and '=' in line and not line.strip().startswith('#'):
                                # Check if value looks like a real secret
                                parts = line.split('=', 1)
                                if len(parts) == 2:
                                    value = parts[1].strip().strip('"').strip("'")
                                    if len(value) > 10 and not value.startswith('${') and not value.startswith('os.'):
                                        print(f"\n‚ö†Ô∏è Potential secret found in {file}")
                                        print(f"   Pattern: {pattern}")
                                        print("   Please review and use environment variables instead")
                                        return False
        except:
            continue

    print("‚úÖ No secrets detected")
    return True


def main():
    """Main pre-commit hook"""
    print("\nüõ°Ô∏è LUKHAS Security Pre-commit Hook\n")

    # Check if we're in CI (skip in CI)
    if os.environ.get('CI'):
        print("‚ÑπÔ∏è Skipping security checks in CI")
        sys.exit(0)

    # Check dependencies
    if not check_dependencies():
        sys.exit(1)

    # Check for secrets
    if not check_secrets():
        sys.exit(1)

    print("\n‚úÖ Security checks passed\n")
    sys.exit(0)


if __name__ == "__main__":
    import os
    main()
