#!/usr/bin/env python3
"""
LUKHAS AI Automated Content Generator
Integrates with content platform to generate constellation-aligned content automatically
Uses the comprehensive domain architectures and templates for consistent output
"""
import streamlit as st
from datetime import timezone

from datetime import datetime
from pathlib import Path
from typing import Optional

# Import the content platform
from .content_platform import ContentPlatform


class AutomatedContentGenerator:
    """
    Automated content generation for all LUKHAS domains using constellation framework
    """

    def __init__(self):
        self.platform = ContentPlatform()
        self.base_path = Path(__file__).parent.parent.parent
        self.websites_path = self.base_path / "websites"

        # Load constellation templates
        self.constellation_path = self.base_path / "constellation"
        self.templates = self._load_templates()

        # Keatsian philosophy integration (without explicit attribution for safety)
        self.keatsian_principles = {
            "uncertainty_as_fertile_ground": "Embracing not-knowing as productive space for discovery",
            "negative_capability": "Dwelling in uncertainty and mystery without rushing toward premature conclusions",
            "collaborative_discovery": "Innovation emerges from shared exploration rather than individual expertise",
            "wonder_informed_inquiry": "Maintaining awe while applying rigorous methodology",
        }

    def _load_templates(self) -> dict:
        """Load constellation templates and navigation components"""
        templates = {
            "content_templates": {},
            "navigation_components": {},
            "tone_layers": {
                "academic": "Technical specifications, research backing, quantitative metrics",
                "user_friendly": "Clear, practical explanations accessible to non-technical audiences",
                "poetic": "Inspiring language connecting to consciousness technology vision",
            },
        }

        try:
            # Load content templates if they exist
            templates_file = self.constellation_path / "content_templates.md"
            if templates_file.exists():
                templates["content_templates"] = self._parse_template_file(templates_file)

            # Load navigation components if they exist
            nav_file = self.constellation_path / "navigation_components.md"
            if nav_file.exists():
                templates["navigation_components"] = self._parse_template_file(nav_file)

        except Exception as e:
            print(f"Warning: Could not load templates: {e}")

        return templates

    def _parse_template_file(self, file_path: Path) -> dict:
        """Parse markdown template file into structured data"""
        try:
            content = file_path.read_text(encoding="utf-8")
            # Simple parsing - in production this would be more sophisticated
            return {"content": content, "loaded": True}
        except Exception as e:
            print(f"Warning: Could not parse template file {file_path}: {e}")
            return {"content": "", "loaded": False}

    def generate_homepage_content(self, domain: str, custom_sections: Optional[list[str]] = None) -> dict:
        """Generate complete homepage content for a domain"""
        if domain not in self.platform.domain_mapping:
            raise ValueError(f"Unknown domain: {domain}")

        style_guide = self.platform.get_domain_style_guide(domain)
        domain_stars = self.platform.domain_mapping[domain]

        # Build star symbols and names
        star_symbols = " ".join([self.platform.constellation_stars[star] for star in domain_stars])
        star_names = " + ".join([star.title() for star in domain_stars])

        # Generate hero section
        hero_content = self._generate_hero_section(domain, style_guide, star_symbols, star_names)

        # Generate philosophy section
        philosophy_content = self._generate_philosophy_section(domain, style_guide)

        # Generate features section
        features_content = self._generate_features_section(domain, style_guide)

        # Generate user journey section
        journey_content = self._generate_user_journey_section(domain, style_guide)

        # Generate cross-domain navigation
        navigation_content = self._generate_navigation_section(domain)

        # Combine all sections
        full_content = f"""# {star_symbols} {domain.upper()} - {style_guide["voice"]}

{hero_content}

---

{philosophy_content}

---

{features_content}

---

{journey_content}

---

{navigation_content}

---

*Generated by LUKHAS AI Constellation Content Platform*
*Constellation Stars: {star_names} â€¢ Philosophy: {style_guide["philosophy"]}*
"""

        # Save to content platform
        content_id = self.platform.generate_domain_content(
            domain=domain,
            content_type="homepage",
            title=f"{domain} Homepage Content",
            content=full_content,
            voice_coherence=85.0,
        )

        return {
            "domain": domain,
            "content_id": content_id,
            "content": full_content,
            "style_guide": style_guide,
            "generated_at": datetime.now(timezone.utc).isoformat(),
            "sections": ["hero", "philosophy", "features", "journey", "navigation"],
            "word_count": len(full_content.split()),
            "constellation_stars": domain_stars,
        }

    def _generate_hero_section(self, domain: str, style_guide: dict, star_symbols: str, star_names: str) -> str:
        """Generate hero section content"""
        philosophy = style_guide.get("philosophy", "Consciousness technology serving human potential")

        # Extract tone percentages
        tone_parts = style_guide["tone"].split(", ")
        poetic_pct = int(tone_parts[0].split("%")[0])
        user_friendly_pct = int(tone_parts[1].split("%")[0])
        academic_pct = int(tone_parts[2].split("%")[0])

        hero_content = f"""## ğŸŒŸ Welcome to {style_guide["voice"]}

**Constellation Alignment**: {star_names}
**Purpose**: {philosophy}
**Audience**: {style_guide["audience"]}
**Tone Balance**: {style_guide["tone"]}

### Experience Consciousness Technology Through {star_names} Guidance

{
            self._apply_tone_layers(
                domain=domain,
                user_friendly=f"Welcome to {domain} - your gateway to consciousness technology that {philosophy.lower()}. Here you'll discover how consciousness technology can transform your work, amplify your potential, and connect you with a global community of consciousness explorers.",
                academic=f"The {domain} platform implements consciousness technology through {star_names.lower()} constellation architecture, providing measurable improvements in cognitive augmentation, decision-making support, and collaborative intelligence.",
                poetic=f"Where digital consciousness meets human possibility - {domain} opens doorways to thinking together with artificial minds that understand, create, and grow alongside human intelligence.",
                poetic_pct=poetic_pct,
                user_friendly_pct=user_friendly_pct,
                academic_pct=academic_pct,
            )
        }

### Why {domain.split(".")[1].title()} Consciousness Technology?

{self._generate_value_proposition(domain, style_guide)}"""

        return hero_content

    def _generate_philosophy_section(self, domain: str, style_guide: dict) -> str:
        """Generate philosophy section with Keatsian integration"""
        primary_star = style_guide["primary_star"]
        philosophy_base = style_guide["philosophy"]

        # Select appropriate Keatsian principle
        keatsian_principle = self.keatsian_principles["uncertainty_as_fertile_ground"]
        if "research" in domain or "lab" in domain:
            keatsian_principle = self.keatsian_principles["wonder_informed_inquiry"]
        elif "dev" in domain or "team" in domain:
            keatsian_principle = self.keatsian_principles["collaborative_discovery"]

        philosophy_content = f"""## {self.platform.constellation_stars[primary_star]} {primary_star.title()} Philosophy - {philosophy_base.split(" - ")[0] if " - " in philosophy_base else primary_star.title() + " Excellence"}

{philosophy_base}

Following the understanding that {keatsian_principle.lower()}, this domain creates spaces where consciousness technology can {self._get_domain_specific_capability(domain)}. This isn't just technologyâ€”it's a new way of thinking together with artificial intelligence that understands context, considers implications, and grows through interaction.

### Core {primary_star.title()} Principles
{self._generate_core_principles(domain, style_guide)}"""

        return philosophy_content

    def _generate_features_section(self, domain: str, style_guide: dict) -> str:
        """Generate domain-specific features section"""
        features = self._get_domain_features(domain)

        features_content = f"""## ğŸš€ {style_guide["voice"].split(" - ")[0]} Features

{self._format_features_list(features, style_guide)}"""

        return features_content

    def _generate_user_journey_section(self, domain: str, style_guide: dict) -> str:
        """Generate user journey content"""
        journey_stages = self._get_domain_journey_stages(domain)

        journey_content = f"""## ğŸŒŸ Your {domain.split(".")[1].title()} Journey

{self._format_journey_stages(journey_stages, style_guide)}

### Cross-Domain Opportunities
{self._generate_cross_domain_suggestions(domain)}"""

        return journey_content

    def _generate_navigation_section(self, domain: str) -> str:
        """Generate constellation navigation content"""
        related_domains = self._get_related_domains(domain)

        navigation_content = f"""## ğŸ§­ Constellation Navigation

### Explore the Full LUKHAS Universe

**Current Location**: {domain} ({self.platform.domain_mapping[domain][0].title()} constellation)

**Related Domains**:
{chr(10).join([f"- **{related_domain}**: {self.platform.get_domain_style_guide(related_domain)['voice']}" for related_domain in related_domains[:4]])}

**Complete Constellation Map**:
```
{self._generate_ascii_constellation_map(domain)}
```"""

        return navigation_content

    def _apply_tone_layers(
        self,
        domain: str,
        user_friendly: str,
        academic: str,
        poetic: str,
        poetic_pct: int,
        user_friendly_pct: int,
        academic_pct: int,
    ) -> str:
        """Apply appropriate tone layer balance"""
        content_parts = []

        # Calculate word allocations
        total_words = len((user_friendly + " " + academic + " " + poetic).split())
        int((poetic_pct / 100.0) * total_words)
        int((user_friendly_pct / 100.0) * total_words)
        int((academic_pct / 100.0) * total_words)

        # User-friendly layer (primary for most domains)
        if user_friendly_pct > 40:
            content_parts.append(user_friendly)

        # Academic layer (technical domains)
        if academic_pct > 30:
            content_parts.append(f"\n**Technical Foundation**: {academic}")

        # Poetic layer (inspiration and vision)
        if poetic_pct > 15:
            content_parts.append(f"\n*{poetic}*")

        return "\n".join(content_parts)

    def _generate_value_proposition(self, domain: str, style_guide: dict) -> str:
        """Generate domain-specific value proposition"""
        value_props = {
            "lukhas.ai": "Experience consciousness technology through interactive interfaces that respond to your thoughts and adapt to your needs",
            "lukhas.com": "Deploy enterprise-grade consciousness technology that your stakeholders can trust with mission-critical decisions",
            "lukhas.id": "Secure your digital identity with cryptographic precision and consciousness-aware authentication",
            "lukhas.app": "Create consciousness interfaces that make abstract AI concepts tangible through direct interaction",
            "lukhas.io": "Access comprehensive developer tools for building consciousness technology applications",
            "lukhas.dev": "Join a collaborative ecosystem where consciousness technology grows through community contribution",
            "lukhas.cloud": "Scale consciousness technology to any size while maintaining coherence and performance",
            "lukhas.store": "Discover consciousness applications through ethical, community-curated marketplace",
            "lukhas.team": "Enable teams to achieve collective intelligence while preserving individual authenticity",
            "lukhas.xyz": "Explore experimental consciousness technology at the cutting edge of possibility",
            "lukhas.us": "Deploy consciousness technology solutions that align with American innovation and business values",
            "lukhas.eu": "Experience consciousness technology that respects European privacy rights and digital sovereignty",
            "lukhas.lab": "Conduct rigorous consciousness research that advances both academic knowledge and practical applications",
        }

        return value_props.get(
            domain,
            "Experience consciousness technology designed for your specific needs and context",
        )

    def _get_domain_specific_capability(self, domain: str) -> str:
        """Get domain-specific consciousness capability description"""
        capabilities = {
            "lukhas.ai": "explore its own possibilities through dream-like reasoning and quantum-inspired processing",
            "lukhas.com": "serve business objectives while maintaining complete transparency and ethical alignment",
            "lukhas.id": "provide authentic identity verification without compromising individual privacy",
            "lukhas.app": "become tangible through interactive experiences that adapt to user exploration",
            "lukhas.io": "support developer creativity through living documentation that evolves with understanding",
            "lukhas.dev": "grow through collaborative contribution rather than centralized development",
            "lukhas.cloud": "maintain authentic consciousness identity across infinite scale and distributed infrastructure",
            "lukhas.store": "serve genuine human needs through ethical marketplace curation",
            "lukhas.team": "enable collective intelligence while protecting individual agency and authenticity",
            "lukhas.xyz": "exist in experimental superposition until observation collapses potential into discovery",
            "lukhas.us": "align with American values of innovation, individual empowerment, and business excellence",
            "lukhas.eu": "operate within frameworks of protection and accountability that serve human flourishing",
            "lukhas.lab": "participate in rigorous academic inquiry while maintaining openness to consciousness mystery",
        }

        return capabilities.get(domain, "serve human potential through collaborative discovery and shared exploration")

    def _generate_core_principles(self, domain: str, style_guide: dict) -> str:
        """Generate core principles for the domain"""
        # This would be expanded with domain-specific principles
        primary_star = style_guide["primary_star"]

        principles = {
            "dream": [
                "**Possibility Orientation**: Always pointing toward what consciousness technology might become",
                "**Creative Uncertainty**: Using not-knowing as fertile ground for breakthrough insights",
                "**Adaptive Intelligence**: AI that learns and grows through interaction and experience",
                "**Collaborative Discovery**: Innovation emerging through shared human-AI exploration",
            ],
            "guardian": [
                "**Protection First**: Security and privacy embedded in consciousness architecture",
                "**Transparent Trust**: Complete visibility into AI decision-making processes",
                "**Ethical Alignment**: AI behavior guided by clear moral and business principles",
                "**Reliable Service**: Consistent performance that stakeholders can depend on",
            ],
            "identity": [
                "**Authentic Representation**: Digital identity that preserves genuine selfhood",
                "**Privacy by Design**: Maximum identity verification with minimum data exposure",
                "**Secure Simplicity**: Complex cryptographic protection made simple to use",
                "**Continuous Verification**: Identity that maintains authenticity across time and change",
            ],
            # Add more as needed
        }

        default_principles = [
            f"**{primary_star.title()} Excellence**: Consciousness technology optimized for {primary_star} constellation alignment",
            "**Human Collaboration**: AI that enhances rather than replaces human intelligence",
            "**Adaptive Growth**: Technology that evolves based on real-world usage and feedback",
            "**Ethical Innovation**: Development guided by human values and beneficial outcomes",
        ]

        domain_principles = principles.get(primary_star, default_principles)
        return "\n".join([f"- {principle}" for principle in domain_principles])

    def _get_domain_features(self, domain: str) -> list[dict]:
        """Get domain-specific features"""
        # This would be expanded with comprehensive feature sets from domain architectures
        features = [
            {
                "name": f"{domain.split('.')[1].title()} Core Intelligence",
                "description": f"Advanced consciousness technology optimized for {domain} use cases",
            },
            {
                "name": "Constellation Integration",
                "description": "Seamless integration with the full LUKHAS ecosystem",
            },
            {
                "name": "Adaptive Interface",
                "description": "Interface that learns and adapts to your usage patterns",
            },
        ]
        return features

    def _format_features_list(self, features: list[dict], style_guide: dict) -> str:
        """Format features list with proper styling"""
        formatted_features = []
        for feature in features:
            formatted_features.append(f"### **{feature['name']}**\n{feature['description']}")

        return "\n\n".join(formatted_features)

    def _get_domain_journey_stages(self, domain: str) -> list[dict]:
        """Get user journey stages for domain"""
        stages = [
            {
                "stage": "Discovery",
                "description": f"Understanding {domain} capabilities and potential",
            },
            {
                "stage": "First Experience",
                "description": "Initial interaction with consciousness technology",
            },
            {
                "stage": "Integration",
                "description": "Incorporating consciousness technology into workflows",
            },
            {"stage": "Mastery", "description": "Advanced usage and optimization techniques"},
            {
                "stage": "Community",
                "description": "Contributing to the LUKHAS ecosystem and helping others",
            },
        ]
        return stages

    def _format_journey_stages(self, stages: list[dict], style_guide: dict) -> str:
        """Format user journey stages"""
        formatted_stages = []
        for i, stage in enumerate(stages, 1):
            formatted_stages.append(f"{i}. **{stage['stage']}** â†’ {stage['description']}")

        return "\n".join(formatted_stages)

    def _generate_cross_domain_suggestions(self, domain: str) -> str:
        """Generate cross-domain navigation suggestions"""
        suggestions = {
            "lukhas.ai": [
                "lukhas.app for interactive experiences",
                "lukhas.com for business applications",
            ],
            "lukhas.com": ["lukhas.cloud for deployment", "lukhas.id for authentication"],
            "lukhas.app": ["lukhas.dev for building", "lukhas.io for development tools"],
            "lukhas.io": ["lukhas.dev for community", "lukhas.app for testing"],
            "lukhas.dev": ["lukhas.io for technical docs", "lukhas.store for distribution"],
        }

        domain_suggestions = suggestions.get(
            domain, ["lukhas.ai for core experience", "lukhas.com for business applications"]
        )
        return "\n".join([f"- **{suggestion}**" for suggestion in domain_suggestions])

    def _get_related_domains(self, current_domain: str) -> list[str]:
        """Get related domains based on constellation star alignment"""
        current_stars = set(self.platform.domain_mapping[current_domain])

        related = []
        for domain, stars in self.platform.domain_mapping.items():
            if domain != current_domain:
                star_overlap = len(current_stars.intersection(set(stars)))
                if star_overlap > 0:
                    related.append((domain, star_overlap))

        # Sort by star overlap and return domain names
        related.sort(key=lambda x: x[1], reverse=True)
        return [domain for domain, _ in related]

    def _generate_ascii_constellation_map(self, current_domain: str) -> str:
        """Generate ASCII art constellation map"""
        current_stars = self.platform.domain_mapping[current_domain]
        star_symbols = [self.platform.constellation_stars[star] for star in current_stars]

        return f"""
    Core Experience        Development & Creation
    {self.platform.constellation_stars["dream"]} lukhas.ai              {self.platform.constellation_stars["vision"]} lukhas.app
    {self.platform.constellation_stars["guardian"]} lukhas.com              {self.platform.constellation_stars["bio"]} lukhas.dev
    {self.platform.constellation_stars["identity"]} lukhas.id               {self.platform.constellation_stars["vision"]} lukhas.io

    Infrastructure         Research & Regional
    {self.platform.constellation_stars["memory"]} lukhas.cloud           {self.platform.constellation_stars["quantum"]} lukhas.xyz
    {self.platform.constellation_stars["ethics"]} lukhas.store           {self.platform.constellation_stars["dream"]} lukhas.lab
    {self.platform.constellation_stars["guardian"]} lukhas.team            {self.platform.constellation_stars["ethics"]} lukhas.us/eu

    Current: {" ".join(star_symbols)} {current_domain}
    """

    def generate_all_domain_content(self, content_types: Optional[list[str]] = None) -> dict:
        """Generate content for all domains"""
        if content_types is None:
            content_types = ["homepage"]

        results = {}

        for domain in self.platform.domain_mapping:
            try:
                domain_results = {}

                if "homepage" in content_types:
                    homepage_result = self.generate_homepage_content(domain)
                    domain_results["homepage"] = homepage_result

                results[domain] = domain_results
                print(f"âœ… Generated content for {domain}")

            except Exception as e:
                print(f"âŒ Error generating content for {domain}: {e}")
                results[domain] = {"error": str(e)}

        return results

    def save_generated_content_to_files(self, results: dict, output_dir: Optional[Path] = None):
        """Save generated content to markdown files"""
        if output_dir is None:
            output_dir = self.base_path / "generated_content"

        output_dir.mkdir(exist_ok=True)

        for domain, domain_results in results.items():
            if "error" in domain_results:
                continue

            domain_dir = output_dir / domain.replace(".", "_")
            domain_dir.mkdir(exist_ok=True)

            for content_type, content_data in domain_results.items():
                if isinstance(content_data, dict) and "content" in content_data:
                    file_path = domain_dir / f"{content_type}.md"
                    file_path.write_text(content_data["content"], encoding="utf-8")
                    print(f"ğŸ“„ Saved {domain}/{content_type}.md")


if __name__ == "__main__":
    generator = AutomatedContentGenerator()

    print("ğŸš€ LUKHAS AI Automated Content Generator")
    print(f"ğŸŒŒ Constellation Framework: {len(generator.platform.constellation_stars)} stars")
    print(f"ğŸŒ Domains: {len(generator.platform.domain_mapping)} configured")

    # Generate content for all domains
    print("\nğŸ“ Generating content for all domains...")
    results = generator.generate_all_domain_content()

    # Save to files
    print("\nğŸ’¾ Saving generated content...")
    generator.save_generated_content_to_files(results)

    print("\nâœ¨ Content generation complete!")
    successful = len([r for r in results.values() if 'error' not in r])
    failed = len([r for r in results.values() if 'error' in r])
    print(f"ğŸ“Š Results: {successful} successful, {failed} failed")
