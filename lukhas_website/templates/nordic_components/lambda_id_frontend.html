<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LUKHŒõS ŒõiD - Symbolic Identity Portal</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=IBM+Plex+Mono:wght@400;500&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <style>
        :root {
            --primary-bg: #0a0a0f;
            --secondary-bg: #1a1a2e;
            --accent-blue: #4a90e2;
            --accent-indigo: #6366f1;
            --accent-gold: #ffd700;
            --text-primary: #ffffff;
            --text-secondary: #a0a0b0;
            --glow-primary: rgba(74, 144, 226, 0.6);
            --glow-secondary: rgba(99, 102, 241, 0.4);
            --success: #10b981;
            --error: #ef4444;
            --warning: #f59e0b;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--primary-bg);
            color: var(--text-primary);
            overflow-x: hidden;
            min-height: 100vh;
            position: relative;
        }

        /* Particle Canvas Background */
        .particle-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 0;
        }

        /* Central Lambda Container */
        .lambda-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            text-align: center;
        }

        .lambda-logo {
            font-size: 6rem;
            font-weight: 700;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.3s ease;
            text-shadow: 0 0 30px var(--glow-primary);
            animation: breathe 4s ease-in-out infinite;
            position: relative;
            z-index: 11;
        }

        @keyframes breathe {
            0%, 100% { transform: scale(1); opacity: 0.9; }
            50% { transform: scale(1.05); opacity: 1; }
        }

        .lambda-logo:hover {
            transform: scale(1.1);
            color: var(--accent-blue);
            text-shadow: 0 0 50px var(--glow-primary);
        }

        /* Tier Indicator Ring */
        .tier-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 200px;
            border: 2px solid transparent;
            border-radius: 50%;
            opacity: 0;
            transition: all 0.5s ease;
        }

        .tier-ring.tier-1 { border-color: rgba(255, 255, 255, 0.3); }
        .tier-ring.tier-2 { border-color: rgba(74, 144, 226, 0.5); }
        .tier-ring.tier-3 { border-color: rgba(99, 102, 241, 0.7); }
        .tier-ring.tier-4 { border-color: rgba(255, 215, 0, 0.8); }
        .tier-ring.tier-5 { 
            border-color: rgba(255, 215, 0, 1);
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            animation: rotate 10s linear infinite;
        }

        @keyframes rotate {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            100% { transform: translate(-50%, -50%) rotate(360deg); }
        }

        .tier-ring.show {
            opacity: 1;
        }

        /* Main Container */
        .main-container {
            position: relative;
            z-index: 5;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2rem;
        }

        /* Login Interface */
        .login-interface {
            background: rgba(26, 26, 46, 0.9);
            border: 1px solid rgba(74, 144, 226, 0.3);
            border-radius: 20px;
            padding: 3rem;
            backdrop-filter: blur(20px);
            max-width: 500px;
            width: 100%;
            margin-top: 200px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            transition: all 0.5s ease;
        }

        .login-interface:hover {
            border-color: rgba(74, 144, 226, 0.6);
            transform: translateY(-5px);
        }

        .interface-title {
            font-size: 2rem;
            margin-bottom: 0.5rem;
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-indigo));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
        }

        .interface-subtitle {
            font-size: 1rem;
            color: var(--text-secondary);
            margin-bottom: 2rem;
            font-style: italic;
            text-align: center;
        }

        /* Form Controls */
        .form-control {
            background: rgba(10, 10, 15, 0.8);
            border: 1px solid rgba(74, 144, 226, 0.3);
            border-radius: 10px;
            color: var(--text-primary);
            padding: 1rem;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .form-control:focus {
            background: rgba(10, 10, 15, 0.9);
            border-color: var(--accent-blue);
            box-shadow: 0 0 20px var(--glow-primary);
            color: var(--text-primary);
        }

        .form-control::placeholder {
            color: var(--text-secondary);
            opacity: 0.7;
        }

        /* Tier Selector */
        .tier-selector {
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            margin-bottom: 2rem;
        }

        .tier-btn {
            padding: 0.5rem 1rem;
            background: rgba(74, 144, 226, 0.1);
            border: 1px solid rgba(74, 144, 226, 0.3);
            border-radius: 20px;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.8rem;
            font-family: 'IBM Plex Mono', monospace;
        }

        .tier-btn:hover, .tier-btn.active {
            background: rgba(74, 144, 226, 0.2);
            border-color: var(--accent-blue);
            transform: translateY(-2px);
        }

        .tier-btn.tier-5.active {
            background: rgba(255, 215, 0, 0.2);
            border-color: var(--accent-gold);
            color: var(--accent-gold);
        }

        /* Emoji Carousel */
        .emoji-carousel {
            display: none;
            margin: 1rem 0;
            padding: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            border: 1px solid rgba(74, 144, 226, 0.2);
        }

        .emoji-carousel.show {
            display: block;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .emoji-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .emoji-btn {
            background: rgba(74, 144, 226, 0.1);
            border: 1px solid rgba(74, 144, 226, 0.3);
            border-radius: 8px;
            padding: 0.5rem;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .emoji-btn:hover, .emoji-btn.selected {
            background: rgba(74, 144, 226, 0.3);
            border-color: var(--accent-blue);
            transform: scale(1.1);
        }

        /* Biometric Controls */
        .biometric-controls {
            display: none;
            margin: 1rem 0;
        }

        .biometric-controls.show {
            display: block;
            animation: slideIn 0.3s ease;
        }

        .biometric-btn {
            width: 100%;
            padding: 1rem;
            margin-bottom: 0.5rem;
            background: rgba(74, 144, 226, 0.1);
            border: 1px solid rgba(74, 144, 226, 0.3);
            border-radius: 10px;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .biometric-btn:hover {
            background: rgba(74, 144, 226, 0.2);
            transform: translateY(-2px);
        }

        .biometric-btn.active {
            background: rgba(16, 185, 129, 0.2);
            border-color: var(--success);
            color: var(--success);
        }

        /* Login Button */
        .login-btn {
            width: 100%;
            padding: 1rem;
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-indigo));
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 1.5rem;
            position: relative;
            overflow: hidden;
        }

        .login-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px var(--glow-primary);
        }

        .login-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .login-btn .loading-spinner {
            display: none;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255,255,255,0.3);
            border-top: 2px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 0.5rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* QR Glyph */
        .qr-glyph-container {
            text-align: center;
            margin-top: 2rem;
            opacity: 0;
            transform: scale(0.8);
            transition: all 0.5s ease;
        }

        .qr-glyph-container.show {
            opacity: 1;
            transform: scale(1);
        }

        .qr-glyph {
            width: 150px;
            height: 150px;
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-indigo));
            border-radius: 15px;
            margin: 0 auto 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            color: white;
            position: relative;
            overflow: hidden;
            cursor: pointer;
        }

        .qr-glyph::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255,255,255,0.1), transparent);
            animation: shimmer 3s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
            100% { transform: translateX(100%) translateY(100%) rotate(45deg); }
        }

        /* Status Messages */
        .status-message {
            text-align: center;
            padding: 1rem;
            border-radius: 10px;
            margin: 1rem 0;
            opacity: 0;
            transform: translateY(10px);
            transition: all 0.3s ease;
        }

        .status-message.show {
            opacity: 1;
            transform: translateY(0);
        }

        .status-message.success {
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid rgba(16, 185, 129, 0.3);
            color: var(--success);
        }

        .status-message.error {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: var(--error);
        }

        .status-message.warning {
            background: rgba(245, 158, 11, 0.1);
            border: 1px solid rgba(245, 158, 11, 0.3);
            color: var(--warning);
        }

        /* Entropy Meter */
        .entropy-meter {
            margin: 1rem 0;
        }

        .entropy-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
            font-family: 'IBM Plex Mono', monospace;
        }

        .entropy-bar {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
            position: relative;
        }

        .entropy-fill {
            height: 100%;
            background: linear-gradient(90deg, #ef4444, #f59e0b, #10b981, var(--accent-blue));
            width: 0%;
            transition: width 0.3s ease;
            position: relative;
        }

        .entropy-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: scan 2s infinite;
        }

        @keyframes scan {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        /* Welcome State */
        .welcome-state {
            display: none;
            text-align: center;
            animation: fadeIn 1s ease;
        }

        .welcome-state.show {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .welcome-title {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-indigo), var(--accent-gold));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .user-info {
            background: rgba(26, 26, 46, 0.8);
            border: 1px solid rgba(74, 144, 226, 0.3);
            border-radius: 15px;
            padding: 2rem;
            margin: 2rem 0;
        }

        .lambda-id-display {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.9rem;
            color: var(--text-secondary);
            background: rgba(0, 0, 0, 0.3);
            padding: 1rem;
            border-radius: 8px;
            word-break: break-all;
            margin: 1rem 0;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .lambda-logo {
                font-size: 4rem;
            }
            
            .tier-ring {
                width: 150px;
                height: 150px;
            }
            
            .login-interface {
                margin-top: 150px;
                padding: 2rem;
            }
            
            .emoji-grid {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        /* Debug Panel */
        .debug-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: var(--text-primary);
            padding: 1rem;
            border-radius: 10px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.8rem;
            z-index: 1000;
            max-width: 300px;
            border: 1px solid rgba(74, 144, 226, 0.3);
        }

        .debug-panel h4 {
            margin-bottom: 0.5rem;
            color: var(--accent-blue);
        }

        .debug-item {
            margin-bottom: 0.3rem;
        }
    </style>
</head>
<body>
    <!-- Particle Canvas -->
    <canvas class="particle-canvas" id="particleCanvas"></canvas>

    <!-- Central Lambda Symbol -->
    <div class="lambda-container">
        <div class="lambda-logo" id="lambdaLogo">Œõ</div>
        <div class="tier-ring" id="tierRing"></div>
    </div>

    <!-- Main Container -->
    <div class="main-container">
        <div class="login-interface" id="loginInterface">
            <h1 class="interface-title">LUKHŒõS ŒõiD</h1>
            <p class="interface-subtitle">Symbolic Identity Portal ‚Ä¢ This is not a login. This is a becoming.</p>

            <!-- Tier Selector -->
            <div class="tier-selector">
                <button class="tier-btn active" data-tier="1">T1</button>
                <button class="tier-btn" data-tier="2">T2</button>
                <button class="tier-btn" data-tier="3">T3</button>
                <button class="tier-btn" data-tier="4">T4</button>
                <button class="tier-btn tier-5" data-tier="5">T5</button>
            </div>

            <!-- Status Messages -->
            <div class="status-message" id="statusMessage"></div>

            <!-- Basic Login Form (T1-T3) -->
            <div class="basic-login" id="basicLogin">
                <div class="mb-3">
                    <label for="username" class="form-label">Username or Email</label>
                    <input type="text" id="username" class="form-control" placeholder="Enter your identity anchor">
                </div>
                <div class="mb-3">
                    <label for="password" class="form-label">Password</label>
                    <input type="password" id="password" class="form-control" placeholder="Enter your cognitive key">
                </div>
            </div>

            <!-- Emoji-Keyword Carousel (T2+) -->
            <div class="emoji-carousel" id="emojiCarousel">
                <label class="form-label">Symbolic Entropy Selector</label>
                <div class="emoji-grid" id="emojiGrid">
                    <!-- Emojis populated by JS -->
                </div>
                <input type="text" id="keywordInput" class="form-control" placeholder="Enter your symbolic keyword">
                <div class="entropy-meter">
                    <div class="entropy-label">Entropy Strength: <span id="entropyValue">0%</span></div>
                    <div class="entropy-bar">
                        <div class="entropy-fill" id="entropyFill"></div>
                    </div>
                </div>
            </div>

            <!-- Biometric Controls (T4+) -->
            <div class="biometric-controls" id="biometricControls">
                <button class="biometric-btn" id="faceIdBtn">
                    <span>üëÅÔ∏è</span> Face ID (Lidar)
                </button>
                <button class="biometric-btn" id="voiceIdBtn">
                    <span>üéôÔ∏è</span> Voice ID
                </button>
            </div>

            <!-- WebAuthn Button (T3+) -->
            <button class="biometric-btn" id="webauthnBtn" style="display: none;">
                <span>üîë</span> Use Device Security (WebAuthn)
            </button>

            <!-- Login Button -->
            <button class="login-btn" id="loginBtn">
                <span class="loading-spinner" id="loadingSpinner"></span>
                <span id="loginText">Enter Consciousness</span>
            </button>

            <!-- QR Glyph -->
            <div class="qr-glyph-container" id="qrGlyphContainer">
                <div class="qr-glyph" id="qrGlyph">‚üê</div>
                <div style="font-size: 0.9rem; color: var(--text-secondary);">Your Digital Crest ‚Ä¢ ŒõID Verified</div>
            </div>
        </div>

        <!-- Welcome State (Post-Login) -->
        <div class="welcome-state" id="welcomeState">
            <h1 class="welcome-title">Welcome to Consciousness</h1>
            <div class="user-info">
                <h3>Identity Verified</h3>
                <p><strong>Tier:</strong> <span id="userTier">Unknown</span></p>
                <p><strong>Lambda ID:</strong></p>
                <div class="lambda-id-display" id="lambdaIdDisplay">Generating...</div>
                <p style="font-style: italic; color: var(--text-secondary);">
                    "The glyph remembers you. Some memories choose to return. Others never left."
                </p>
            </div>
        </div>
    </div>

    <!-- Debug Panel -->
    <div class="debug-panel" id="debugPanel">
        <h4>ŒõiD Debug</h4>
        <div class="debug-item">Current Tier: <span id="debugTier">1</span></div>
        <div class="debug-item">Particles: <span id="debugParticles">0</span></div>
        <div class="debug-item">Auth State: <span id="debugAuth">Unauthenticated</span></div>
        <div class="debug-item">Lambda ID: <span id="debugLambdaId">None</span></div>
    </div>

    <script>
        // Global State Management
        class LambdaIDSystem {
            constructor() {
                this.currentTier = 1;
                this.isAuthenticated = false;
                this.selectedEmoji = null;
                this.biometricStatus = {
                    face: false,
                    voice: false,
                    webauthn: false
                };
                this.lambdaId = null;
                this.particles = null;
                this.canvas = null;
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.particleSystem = null;
                
                this.init();
            }

            async init() {
                this.initParticleSystem();
                this.initEventListeners();
                this.initEmojis();
                this.updateTierUI();
                this.startBreathingAnimation();
                
                // Initialize with T1 by default
                this.setTier(1);
            }

            // Particle System using Three.js
            initParticleSystem() {
                const canvas = document.getElementById('particleCanvas');
                this.canvas = canvas;
                
                // Scene setup
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.camera.position.z = 5;

                // Create particle geometry
                const particleCount = 1000;
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount; i++) {
                    // Random initial positions
                    positions[i * 3] = (Math.random() - 0.5) * 20;
                    positions[i * 3 + 1] = (Math.random() - 0.5) * 20;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 20;
                    
                    // Blue-ish colors
                    colors[i * 3] = 0.3 + Math.random() * 0.4; // R
                    colors[i * 3 + 1] = 0.6 + Math.random() * 0.4; // G
                    colors[i * 3 + 2] = 0.8 + Math.random() * 0.2; // B
                }

                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                const material = new THREE.PointsMaterial({
                    size: 0.05,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.7
                });

                this.particleSystem = new THREE.Points(geometry, material);
                this.scene.add(this.particleSystem);

                // Start animation loop
                this.animate();

                // Handle resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                if (this.particleSystem) {
                    // Slow rotation for the particle cloud
                    this.particleSystem.rotation.y += 0.001;
                    this.particleSystem.rotation.x += 0.0005;
                    
                    // Update particle positions for floating effect
                    const positions = this.particleSystem.geometry.attributes.position.array;
                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i + 1] += Math.sin(Date.now() * 0.001 + i) * 0.001;
                    }
                    this.particleSystem.geometry.attributes.position.needsUpdate = true;
                }
                
                this.renderer.render(this.scene, this.camera);
                
                // Update debug
                document.getElementById('debugParticles').textContent = this.particleSystem ? '1000' : '0';
            }

            // Morph particles to Lambda shape
            morphToLambda() {
                if (!this.particleSystem) return;
                
                const positions = this.particleSystem.geometry.attributes.position.array;
                const particleCount = positions.length / 3;
                
                // Define Lambda shape points (simplified)
                const lambdaPoints = this.generateLambdaPoints(200);
                
                for (let i = 0; i < particleCount; i++) {
                    const targetPoint = lambdaPoints[i % lambdaPoints.length];
                    const currentX = positions[i * 3];
                    const currentY = positions[i * 3 + 1];
                    const currentZ = positions[i * 3 + 2];
                    
                    // Smooth interpolation towards target
                    positions[i * 3] += (targetPoint.x - currentX) * 0.02;
                    positions[i * 3 + 1] += (targetPoint.y - currentY) * 0.02;
                    positions[i * 3 + 2] += (targetPoint.z - currentZ) * 0.02;
                }
                
                this.particleSystem.geometry.attributes.position.needsUpdate = true;
            }

            generateLambdaPoints(count) {
                const points = [];
                const scale = 2;
                
                // Generate points for Lambda shape
                for (let i = 0; i < count; i++) {
                    const t = (i / count) * Math.PI * 2;
                    let x, y;
                    
                    if (t < Math.PI) {
                        // Left arm of Lambda
                        x = -Math.cos(t * 0.5) * scale;
                        y = Math.sin(t * 0.5) * scale;
                    } else {
                        // Right arm of Lambda
                        x = Math.cos((t - Math.PI) * 0.5) * scale;
                        y = Math.sin((t - Math.PI) * 0.5) * scale;
                    }
                    
                    points.push({
                        x: x + (Math.random() - 0.5) * 0.2,
                        y: y + (Math.random() - 0.5) * 0.2,
                        z: (Math.random() - 0.5) * 0.5
                    });
                }
                
                return points;
            }

            // Event Listeners
            initEventListeners() {
                // Tier selection
                document.querySelectorAll('.tier-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const tier = parseInt(e.target.dataset.tier);
                        this.setTier(tier);
                    });
                });

                // Lambda logo click
                document.getElementById('lambdaLogo').addEventListener('click', () => {
                    this.animateLambda();
                });

                // Login button
                document.getElementById('loginBtn').addEventListener('click', () => {
                    this.attemptLogin();
                });

                // Biometric buttons
                document.getElementById('faceIdBtn').addEventListener('click', () => {
                    this.toggleBiometric('face');
                });

                document.getElementById('voiceIdBtn').addEventListener('click', () => {
                    this.toggleBiometric('voice');
                });

                document.getElementById('webauthnBtn').addEventListener('click', () => {
                    this.useWebAuthn();
                });

                // Input listeners for entropy calculation
                document.getElementById('keywordInput').addEventListener('input', () => {
                    this.calculateEntropy();
                });

                document.getElementById('username').addEventListener('input', () => {
                    this.calculateEntropy();
                });

                document.getElementById('password').addEventListener('input', () => {
                    this.calculateEntropy();
                });
            }

            // Initialize emoji grid
            initEmojis() {
                const emojis = [
                    'üåï', 'üß†', '‚ö°', 'üîÆ', 'üåü', 'üöÄ',
                    'üëÅÔ∏è', 'üé≠', 'üåä', 'üî•', '‚ùÑÔ∏è', 'üå∏',
                    'ü¶ã', 'üê∫', 'ü¶Ö', 'üêô', 'üå≤', 'üèîÔ∏è',
                    'üéØ', 'üíé', 'üóùÔ∏è', '‚öñÔ∏è', 'üî¨', 'üé®'
                ];

                const emojiGrid = document.getElementById('emojiGrid');
                emojis.forEach(emoji => {
                    const btn = document.createElement('button');
                    btn.className = 'emoji-btn';
                    btn.textContent = emoji;
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.emoji-btn').forEach(b => b.classList.remove('selected'));
                        btn.classList.add('selected');
                        this.selectedEmoji = emoji;
                        this.calculateEntropy();
                    });
                    emojiGrid.appendChild(btn);
                });
            }

            // Tier Management
            setTier(tier) {
                this.currentTier = tier;
                
                // Update UI
                document.querySelectorAll('.tier-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (parseInt(btn.dataset.tier) === tier) {
                        btn.classList.add('active');
                    }
                });

                this.updateTierUI();
                this.updateTierRing();
                this.updateDebug();
            }

            updateTierUI() {
                const emojiCarousel = document.getElementById('emojiCarousel');
                const biometricControls = document.getElementById('biometricControls');
                const webauthnBtn = document.getElementById('webauthnBtn');

                // Show/hide elements based on tier
                if (this.currentTier >= 2) {
                    emojiCarousel.classList.add('show');
                } else {
                    emojiCarousel.classList.remove('show');
                }

                if (this.currentTier >= 3) {
                    webauthnBtn.style.display = 'block';
                } else {
                    webauthnBtn.style.display = 'none';
                }

                if (this.currentTier >= 4) {
                    biometricControls.classList.add('show');
                } else {
                    biometricControls.classList.remove('show');
                }
            }

            updateTierRing() {
                const tierRing = document.getElementById('tierRing');
                tierRing.className = `tier-ring tier-${this.currentTier} show`;
            }

            // Authentication Methods
            async attemptLogin() {
                const username = document.getElementById('username').value;
                const password = document.getElementById('password').value;
                const keyword = document.getElementById('keywordInput').value;

                // Basic validation
                if (!username) {
                    this.showStatus('Please enter your username', 'error');
                    return;
                }

                if (this.currentTier >= 1 && !password) {
                    this.showStatus('Please enter your password', 'error');
                    return;
                }

                if (this.currentTier >= 2 && (!this.selectedEmoji || !keyword)) {
                    this.showStatus('Please select emoji and keyword for T2+', 'error');
                    return;
                }

                if (this.currentTier >= 4 && (!this.biometricStatus.face || !this.biometricStatus.voice)) {
                    this.showStatus('Please complete biometric verification for T4+', 'error');
                    return;
                }

                // Show loading
                this.setLoading(true);

                try {
                    // Generate Lambda ID
                    const lambdaId = await this.generateLambdaID(username, password, this.selectedEmoji, keyword);
                    
                    // Simulate authentication delay
                    await new Promise(resolve => setTimeout(resolve, 2000));
                    
                    // Success
                    this.lambdaId = lambdaId;
                    this.isAuthenticated = true;
                    await this.showSuccessSequence();
                    
                } catch (error) {
                    this.showStatus('Authentication failed: ' + error.message, 'error');
                    this.animateLambdaError();
                } finally {
                    this.setLoading(false);
                }
            }

            async generateLambdaID(username, password, emoji, keyword) {
                // Simulate SHA-3 hashing (using SHA-256 as substitute)
                const input = `${username}:${password}:${emoji || ''}:${keyword || ''}:${this.currentTier}:${Date.now()}`;
                
                // Create hash using crypto-js
                const hash = CryptoJS.SHA256(input).toString();
                return `ŒõID:${hash.substring(0, 16)}:T${this.currentTier}`;
            }

            async showSuccessSequence() {
                // Morph particles to Lambda shape
                this.morphToLambda();
                
                // Animate Lambda logo
                this.animateLambdaSuccess();
                
                // Show success message
                this.showStatus('Identity verified ‚Ä¢ Consciousness accessed', 'success');
                
                // Wait a moment
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Show QR Glyph
                document.getElementById('qrGlyphContainer').classList.add('show');
                
                // Generate and show QR pattern
                this.generateQRGlyph();
                
                // Wait another moment
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Transition to welcome state
                await this.showWelcomeState();
            }

            async showWelcomeState() {
                const loginInterface = document.getElementById('loginInterface');
                const welcomeState = document.getElementById('welcomeState');
                
                // Fade out login interface
                loginInterface.style.opacity = '0';
                loginInterface.style.transform = 'translateY(-50px)';
                
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Hide login interface and show welcome
                loginInterface.style.display = 'none';
                welcomeState.classList.add('show');
                
                // Update user info
                document.getElementById('userTier').textContent = `T${this.currentTier} - ${this.getTierName()}`;
                document.getElementById('lambdaIdDisplay').textContent = this.lambdaId;
                
                this.updateDebug();
            }

            getTierName() {
                const names = {
                    1: 'Basic Identity',
                    2: 'Enhanced Identity',
                    3: 'Passwordless Identity',
                    4: 'Biometric Identity',
                    5: 'Blockchain Identity'
                };
                return names[this.currentTier] || 'Unknown';
            }

            generateQRGlyph() {
                const glyphs = ['‚üê', '‚óà', '‚¨ü', '‚¨¢', '‚üÅ', '‚óä', '‚¨ß', '‚üê', '‚óê', '‚óë'];
                const randomGlyph = glyphs[Math.floor(Math.random() * glyphs.length)];
                document.getElementById('qrGlyph').textContent = randomGlyph;
                
                // Add click handler for QR interaction
                document.getElementById('qrGlyph').onclick = () => {
                    this.showStatus('QRGlyph encrypted with AES-256 ‚Ä¢ Ready for device pairing', 'success');
                };
            }

            // Biometric Methods
            toggleBiometric(type) {
                const btn = document.getElementById(`${type}IdBtn`);
                
                if (this.biometricStatus[type]) {
                    // Deactivate
                    this.biometricStatus[type] = false;
                    btn.classList.remove('active');
                } else {
                    // Activate (simulate)
                    this.simulateBiometric(type);
                }
            }

            async simulateBiometric(type) {
                const btn = document.getElementById(`${type}IdBtn`);
                btn.textContent = `${type === 'face' ? 'üëÅÔ∏è' : 'üéôÔ∏è'} Scanning...`;
                
                // Simulate scanning delay
                await new Promise(resolve => setTimeout(resolve, 1500));
                
                // Success
                this.biometricStatus[type] = true;
                btn.classList.add('active');
                btn.innerHTML = `<span>${type === 'face' ? 'üëÅÔ∏è' : 'üéôÔ∏è'}</span> ${type === 'face' ? 'Face' : 'Voice'} ID ‚úì`;
                
                this.showStatus(`${type === 'face' ? 'Face' : 'Voice'} biometric verified`, 'success');
            }

            async useWebAuthn() {
                if (!window.PublicKeyCredential) {
                    this.showStatus('WebAuthn not supported on this device', 'error');
                    return;
                }

                try {
                    // Simulate WebAuthn credential request
                    this.showStatus('Touch your device sensor or insert security key...', 'warning');
                    
                    // In a real implementation, you would use:
                    // const credential = await navigator.credentials.get({...});
                    
                    // Simulate delay
                    await new Promise(resolve => setTimeout(resolve, 2000));
                    
                    this.biometricStatus.webauthn = true;
                    this.showStatus('WebAuthn credential verified', 'success');
                    
                } catch (error) {
                    this.showStatus('WebAuthn failed: ' + error.message, 'error');
                }
            }

            // Animation Methods
            animateLambda() {
                const lambda = document.getElementById('lambdaLogo');
                lambda.style.transform = 'scale(1.2) rotateY(360deg)';
                lambda.style.transition = 'transform 0.6s ease';
                
                setTimeout(() => {
                    lambda.style.transform = 'scale(1) rotateY(0deg)';
                }, 600);
            }

            animateLambdaSuccess() {
                const lambda = document.getElementById('lambdaLogo');
                lambda.style.color = 'var(--success)';
                lambda.style.textShadow = '0 0 50px var(--success)';
                lambda.style.transform = 'scale(1.15)';
                
                setTimeout(() => {
                    lambda.style.color = 'var(--text-primary)';
                    lambda.style.textShadow = '0 0 30px var(--glow-primary)';
                    lambda.style.transform = 'scale(1)';
                }, 1000);
            }

            animateLambdaError() {
                const lambda = document.getElementById('lambdaLogo');
                lambda.style.color = 'var(--error)';
                lambda.style.animation = 'shake 0.5s ease-in-out';
                
                setTimeout(() => {
                    lambda.style.color = 'var(--text-primary)';
                    lambda.style.animation = 'breathe 4s ease-in-out infinite';
                }, 500);
            }

            startBreathingAnimation() {
                // Already handled by CSS animation
            }

            // Utility Methods
            calculateEntropy() {
                let entropy = 0;
                const username = document.getElementById('username').value;
                const password = document.getElementById('password').value;
                const keyword = document.getElementById('keywordInput').value;
                
                // Calculate based on inputs
                entropy += username.length * 2;
                entropy += password.length * 3;
                if (this.selectedEmoji) entropy += 25;
                entropy += keyword.length * 4;
                
                // Biometric bonuses
                if (this.biometricStatus.face) entropy += 30;
                if (this.biometricStatus.voice) entropy += 30;
                if (this.biometricStatus.webauthn) entropy += 40;
                
                // Tier multiplier
                entropy *= (1 + this.currentTier * 0.1);
                
                const entropyPercent = Math.min(100, entropy);
                document.getElementById('entropyFill').style.width = entropyPercent + '%';
                document.getElementById('entropyValue').textContent = Math.round(entropyPercent) + '%';
            }

            showStatus(message, type = 'info') {
                const statusEl = document.getElementById('statusMessage');
                statusEl.textContent = message;
                statusEl.className = `status-message ${type} show`;
                
                setTimeout(() => {
                    statusEl.classList.remove('show');
                }, 5000);
            }

            setLoading(loading) {
                const btn = document.getElementById('loginBtn');
                const spinner = document.getElementById('loadingSpinner');
                const text = document.getElementById('loginText');
                
                if (loading) {
                    btn.disabled = true;
                    spinner.style.display = 'inline-block';
                    text.textContent = 'Processing Consciousness...';
                } else {
                    btn.disabled = false;
                    spinner.style.display = 'none';
                    text.textContent = 'Enter Consciousness';
                }
            }

            updateDebug() {
                document.getElementById('debugTier').textContent = this.currentTier;
                document.getElementById('debugAuth').textContent = this.isAuthenticated ? 'Authenticated' : 'Unauthenticated';
                document.getElementById('debugLambdaId').textContent = this.lambdaId || 'None';
            }
        }

        // Add shake animation to CSS
        const style = document.createElement('style');
        style.textContent = `
            @keyframes shake {
                0%, 100% { transform: translateX(0); }
                25% { transform: translateX(-5px); }
                75% { transform: translateX(5px); }
            }
        `;
        document.head.appendChild(style);

        // Initialize the system when page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.lambdaID = new LambdaIDSystem();
        });
    </script>
</body>
</html>