#!/usr/bin/env python3
"""
Conformance Test Generator

Scans all module.manifest.json files in the repository and generates
pytest conformance tests that verify declared entrypoints are importable.

This transforms module manifests into executable contracts, ensuring that
what we declare is what we deliver.

Usage:
    python3 tools/generate_conformance_tests.py

Output:
    tests/conformance/test_contracts.py
"""

import json
import sys
from pathlib import Path
from typing import List, Tuple


def find_all_manifests(repo_root: Path) -> List[Path]:
    """Find all module.manifest.json files in the repository."""
    return list(repo_root.rglob("module.manifest.json"))


def extract_entrypoints(manifest_path: Path) -> List[Tuple[str, str, str]]:
    """
    Extract entrypoints from a manifest file.

    Returns:
        List of tuples: (module_name, function_name, manifest_path)
    """
    try:
        with open(manifest_path, "r", encoding="utf-8") as f:
            data = json.load(f)

        runtime = data.get("runtime", {})
        entrypoints = runtime.get("entrypoints", [])

        if not entrypoints:
            return []

        results = []
        for ep in entrypoints:
            # Entrypoint format: "module.path.to.thing" or "module.path:function"
            # We need to split into module path and attribute name

            if ":" in ep:
                # Explicit format: "module.path:function"
                module_path, attr_name = ep.split(":", 1)
            else:
                # Implicit format: "module.path.ClassName"
                # Split on the last dot
                parts = ep.rsplit(".", 1)
                if len(parts) == 2:
                    module_path, attr_name = parts
                else:
                    # Single element, treat as module with no attribute
                    module_path = ep
                    attr_name = None

            if attr_name:
                results.append((module_path, attr_name, str(manifest_path)))

        return results

    except Exception as e:
        print(f"Warning: Failed to parse {manifest_path}: {e}", file=sys.stderr)
        return []


def generate_test_file(test_cases: List[Tuple[str, str, str]], output_path: Path) -> None:
    """Generate the pytest test file."""

    # Sort test cases for deterministic output
    test_cases.sort(key=lambda x: (x[0], x[1]))

    # Build the test case list
    cases_str = "[\n"
    for module_path, attr_name, manifest_path in test_cases:
        # Create a readable test ID
        cases_str += f'    ("{module_path}", "{attr_name}", "{manifest_path}"),\n'
    cases_str += "]"

    test_content = f'''"""
Auto-generated conformance tests.

DO NOT EDIT THIS FILE MANUALLY.
Generated by: tools/generate_conformance_tests.py

These tests verify that all entrypoints declared in module.manifest.json
files are actually importable and accessible. This ensures that our module
registry represents executable truth, not just documentation.
"""

import importlib
import pytest


# Test cases: (module_path, attribute_name, source_manifest)
TEST_CASES = {cases_str}


@pytest.mark.parametrize("module_path,attr_name,manifest_path", TEST_CASES)
def test_entrypoint_importable(module_path: str, attr_name: str, manifest_path: str) -> None:
    """
    Verify that a declared entrypoint is importable and accessible.

    This test:
    1. Imports the module
    2. Verifies the attribute exists
    3. Provides clear error messages pointing to the source manifest
    """
    try:
        module = importlib.import_module(module_path)
    except ImportError as e:
        pytest.fail(
            f"Failed to import module '{{module_path}}' declared in {{manifest_path}}\\n"
            f"Error: {{e}}"
        )

    if not hasattr(module, attr_name):
        available = [name for name in dir(module) if not name.startswith("_")]
        pytest.fail(
            f"Module '{{module_path}}' has no attribute '{{attr_name}}'\\n"
            f"Declared in: {{manifest_path}}\\n"
            f"Available attributes: {{', '.join(sorted(available))}}"
        )


def test_conformance_test_generation() -> None:
    """Meta-test: Verify that conformance tests were actually generated."""
    assert len(TEST_CASES) > 0, (
        "No test cases were generated. This likely means:\\n"
        "1. No module manifests were found, or\\n"
        "2. No manifests declare entrypoints, or\\n"
        "3. The generator script has a bug.\\n"
        "Run: python3 tools/generate_conformance_tests.py"
    )
'''

    # Write the file
    output_path.parent.mkdir(parents=True, exist_ok=True)
    with open(output_path, "w", encoding="utf-8") as f:
        f.write(test_content)


def main() -> int:
    """Main entry point."""
    # Determine repository root
    script_path = Path(__file__).resolve()
    repo_root = script_path.parent.parent

    print(f"Scanning repository: {repo_root}")

    # Find all manifests
    manifests = find_all_manifests(repo_root)
    print(f"Found {len(manifests)} module manifests")

    if not manifests:
        print("Warning: No module manifests found", file=sys.stderr)
        return 1

    # Extract all entrypoints
    all_entrypoints = []
    for manifest_path in manifests:
        entrypoints = extract_entrypoints(manifest_path)
        all_entrypoints.extend(entrypoints)

    print(f"Extracted {len(all_entrypoints)} entrypoint declarations")

    if not all_entrypoints:
        print("Warning: No entrypoints found in any manifest", file=sys.stderr)
        # Still generate the file with zero test cases - this itself is a signal

    # Generate test file
    output_path = repo_root / "tests" / "conformance" / "test_contracts.py"
    generate_test_file(all_entrypoints, output_path)

    print(f"Generated: {output_path}")
    print(f"Test cases: {len(all_entrypoints)}")
    print()
    print("Next steps:")
    print("  1. Run: pytest tests/conformance/ -v")
    print("  2. Review any failures to identify broken contracts")
    print("  3. Fix entrypoints or update manifests accordingly")

    return 0


if __name__ == "__main__":
    sys.exit(main())
