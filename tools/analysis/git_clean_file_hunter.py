#!/usr/bin/env python3
"""
Git Clean File Hunter - Find files that were error-free in past commits
"""

import subprocess
import json
from collections import defaultdict
from pathlib import Path

def run_command(cmd):
    """Run shell command and return output"""
    try:
        result = subprocess.run(cmd, shell=True, capture_output=True, text=True, cwd="/Users/agi_dev/LOCAL-REPOS/Lukhas")
        return result.stdout.strip(), result.returncode
    except Exception as e:
        print(f"Error running command: {e}")
        return "", 1

def get_syntax_errors_for_commit(commit_hash):
    """Get syntax errors for a specific commit"""
    print(f"Analyzing commit {commit_hash}...")
    
    # Checkout the commit temporarily
    run_command(f"git checkout {commit_hash} --quiet")
    
    # Run ruff to get syntax errors
    output, returncode = run_command(".venv/bin/ruff check branding/ candidate/ tools/ products/ matriz/ next_gen/ lukhas/ --select=E999 --output-format=json --quiet")
    
    # Return to main
    run_command("git checkout main --quiet")
    
    if returncode != 0 or not output:
        return []
    
    try:
        errors = json.loads(output)
        return [error['filename'] for error in errors]
    except json.JSONDecodeError:
        return []

def find_clean_files_in_history():
    """Find files that were clean in previous commits but have errors now"""
    
    # Get current files with syntax errors
    output, _ = run_command(".venv/bin/ruff check branding/ candidate/ tools/ products/ matriz/ next_gen/ lukhas/ --select=E999 --output-format=json --quiet")
    
    if not output:
        print("No current syntax errors found")
        return
    
    try:
        current_errors = json.loads(output)
        current_error_files = set(error['filename'] for error in current_errors)
    except json.JSONDecodeError:
        print("Failed to parse current errors")
        return
    
    print(f"Found {len(current_error_files)} files with current syntax errors")
    
    # Get last 5 commits to analyze
    commit_output, _ = run_command("git log --oneline -5")
    commits = [line.split()[0] for line in commit_output.split('\n') if line]
    
    clean_file_opportunities = defaultdict(list)
    
    for commit in commits:
        print(f"\nAnalyzing commit {commit}...")
        error_files_in_commit = set(get_syntax_errors_for_commit(commit))
        
        # Find files that are currently broken but were clean in this commit
        clean_in_past = current_error_files - error_files_in_commit
        
        if clean_in_past:
            print(f"  Found {len(clean_in_past)} files that were clean in {commit}")
            for file_path in clean_in_past:
                clean_file_opportunities[file_path].append(commit)
    
    # Sort by most opportunities (files clean in multiple commits)
    sorted_opportunities = sorted(
        clean_file_opportunities.items(),
        key=lambda x: len(x[1]),
        reverse=True
    )
    
    print(f"\nüéØ CLEAN FILE RESTORATION OPPORTUNITIES:")
    print(f"Found {len(sorted_opportunities)} files that were clean in past commits")
    
    # Show top restoration candidates
    for file_path, commits in sorted_opportunities[:20]:
        print(f"  üìÅ {file_path}")
        print(f"     Clean in commits: {', '.join(commits)}")
        print(f"     Opportunities: {len(commits)}")
    
    # Create restoration script for top candidates
    with open("tools/analysis/clean_file_restoration_script.sh", "w") as f:
        f.write("#!/bin/bash\n")
        f.write("# Clean File Restoration Script\n")
        f.write("# Generated by git_clean_file_hunter.py\n\n")
        
        for file_path, commits in sorted_opportunities[:10]:
            most_recent_clean = commits[0]  # First is most recent
            f.write(f'echo "Restoring {file_path} from {most_recent_clean}..."\n')
            f.write(f'git checkout {most_recent_clean} -- "{file_path}"\n')
            f.write(f'python -c "import py_compile; py_compile.compile(\'{file_path}\', doraise=True)" && echo "‚úÖ Compiles" || echo "‚ùå Still broken"\n')
            f.write(f'\n')
        
        f.write('echo "Restoration complete! Check files and commit if successful."\n')
    
    print(f"\nüìù Created restoration script: tools/analysis/clean_file_restoration_script.sh")
    return sorted_opportunities

if __name__ == "__main__":
    find_clean_files_in_history()