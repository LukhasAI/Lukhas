---
status: wip
type: documentation
owner: unknown
module: visionary
redirect: false
moved_to: null
---

Absolutely—here’s a drop-in Dream Inbox writer that creates
memory/inbox/dreams/<trace_id>.json and works even if you don’t have any other inbox code yet. It’s capability-gated, safe by defauThat's it—you now have a minimal, capability-gated Dream Inbox that your simulation lane can write to immediately.

---

## MATADA Alignment Update (v1)

Writer extension: Persist matada_nodes alongside shards:

```json
{
  "trace_id": "...",
  "saved_ts": 1730000000000,
  "seed": {...},
  "shards": [...],
  "matada_nodes": [...],
  "version": 1,
  "schema_ref": "lukhas://schemas/matada_node_v1.json"
}
```

On validation failure: log and skip invalid nodes (do not block shard persistence). Enable DREAM_INBOX_VALIDATE=1 to enforce strict mode (fail the write).t, and atomic on write.

Files to add

memory/__init__.py

![Status: WIP](https://img.shields.io/badge/status-wip-yellow)

# memory/__init__.py

memory/inbox/__init__.py

# memory/inbox/__init__.py

memory/inbox/dreams/__init__.py

# memory/inbox/dreams/__init__.py

memory/inbox/dreams/writer.py

# memory/inbox/dreams/writer.py
from __future__ import annotations
import json, os, time, tempfile
from typing import Any, Dict, List, Optional

# ---- Errors ---------------------------------------------------------
class CapabilityError(RuntimeError): ...
class ValidationError(ValueError): ...

# Keep in sync with simulation/api.py to avoid import cycles
REQUIRED_SCOPE = "memory.inbox.dreams.write"

# ---- Helpers --------------------------------------------------------
def _require_scope(cap_token: Optional[Dict[str, Any]]) -> None:
    if not cap_token:
        raise CapabilityError("Missing capability token.")
    scopes = set(cap_token.get("scopes") or [])
    if REQUIRED_SCOPE not in scopes:
        raise CapabilityError(f"Missing required scope: {REQUIRED_SCOPE}")
    exp = float(cap_token.get("exp_ts", 0))
    if exp and exp <= time.time():
        raise CapabilityError("Capability token expired.")

def _ensure_dir(path: str) -> None:
    os.makedirs(path, exist_ok=True)

def _redact(obj: Any) -> Any:
    """
    Minimal best-effort redaction. Enable via DREAM_INBOX_REDACT=1.
    Removes obvious secrets-like keys; scrubs emails/phones with placeholders.
    """
    if os.getenv("DREAM_INBOX_REDACT", "0") not in ("1", "true", "True"):
        return obj

    import re
    EMAIL = re.compile(r"\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}\b", re.I)
    PHONE = re.compile(r"\b(\+?\d{1,3})?[-.\s]?\(?\d{2,4}\)?[-.\s]?\d{3,4}[-.\s]?\d{3,4}\b")

    def scrub(x: Any) -> Any:
        if isinstance(x, dict):
            cleaned = {}
            for k, v in x.items():
                kl = (k or "").lower()
                if any(s in kl for s in ("password", "secret", "token", "apikey", "api_key", "auth", "bearer")):
                    cleaned[k] = "***REDACTED***"
                else:
                    cleaned[k] = scrub(v)
            return cleaned
        if isinstance(x, list):
            return [scrub(v) for v in x]
        if isinstance(x, str):
            s = EMAIL.sub("[email]", x)
            s = PHONE.sub("[phone]", s)
            return s
        return x

    return scrub(obj)

def _safe_seed_snapshot(seed: Dict[str, Any]) -> Dict[str, Any]:
    """
    Persist only what we need from the seed to reconstruct intent without secrets.
    """
    minimal = {
        "goal": seed.get("goal", ""),
        "ul_tags": list((seed.get("ul_tags") or [])[:20]),
        "constraints": {
            "flags": ((seed.get("constraints") or {}).get("flags") or {})
        },
    }
    return _redact(minimal)

def _merge_existing(path: str, new_shards: List[Dict[str, Any]], seed_snap: Dict[str, Any]) -> Dict[str, Any]:
    if not os.path.exists(path):
        return {
            "trace_id": new_shards[0].get("trace_id", ""),
            "saved_ts": int(time.time() * 1000),
            "seed": seed_snap,
            "shards": new_shards,
            "version": 1
        }
    try:
        with open(path, "r", encoding="utf-8") as fh:
            data = json.load(fh)
        # append shards (idempotency: de-dup by (trace_id, index, timestamp))
        seen = {(s.get("trace_id"), s.get("index"), s.get("timestamp")) for s in data.get("shards", [])}
        for shard in new_shards:
            key = (shard.get("trace_id"), shard.get("index"), shard.get("timestamp"))
            if key not in seen:
                data.setdefault("shards", []).append(shard)
        data["saved_ts"] = int(time.time() * 1000)
        # Update seed snapshot if absent
        data.setdefault("seed", seed_snap)
        return data
    except Exception:
        # If corrupt, start fresh but keep a .corrupt backup
        try:
            os.replace(path, path + ".corrupt")
        except Exception:
            pass
        return {
            "trace_id": new_shards[0].get("trace_id", ""),
            "saved_ts": int(time.time() * 1000),
            "seed": seed_snap,
            "shards": new_shards,
            "version": 1
        }

def _atomic_write(dest_path: str, payload: Dict[str, Any]) -> int:
    dir_name = os.path.dirname(dest_path)
    _ensure_dir(dir_name)
    s = json.dumps(payload, ensure_ascii=False, separators=(",", ":"), indent=2)
    with tempfile.NamedTemporaryFile("w", encoding="utf-8", dir=dir_name, delete=False) as tmp:
        tmp.write(s)
        tmp_path = tmp.name
    os.replace(tmp_path, dest_path)  # atomic on same fs
    return len(s.encode("utf-8"))

# ---- Public API -----------------------------------------------------
def persist_dream_shards(*, seed: Dict[str, Any], result: Dict[str, Any], cap_token: Dict[str, Any],
                         base_dir: Optional[str] = None) -> Dict[str, Any]:
    """
    Persist dream shards to memory/inbox/dreams/<trace_id>.json (or base_dir).
    Returns {path, bytes, shards_written}.
    """
    _require_scope(cap_token)

    trace_id = (result or {}).get("trace_id")
    shards   = (result or {}).get("shards")
    if not trace_id or not isinstance(trace_id, str):
        raise ValidationError("result.trace_id missing or invalid")
    if not isinstance(shards, list) or not shards:
        raise ValidationError("result.shards must be a non-empty list")

    base = base_dir or os.getenv("DREAM_INBOX_DIR", os.path.join("memory", "inbox", "dreams"))
    _ensure_dir(base)
    out_path = os.path.join(base, f"{trace_id}.json")

    seed_snap = _safe_seed_snapshot(seed or {})
    payload   = _merge_existing(out_path, _redact(shards), seed_snap)
    nbytes    = _atomic_write(out_path, payload)

    return {"path": out_path, "bytes": nbytes, "shards_written": len(shards)}


⸻

How it plugs into what you already have
	•	Your updated consciousness/simulation/api.py already calls:

persist_dream_shards(seed=seed, result=result_payload, cap_token=cap_token)

This writer satisfies that import and persists to disk safely.

	•	Capability gating: it requires the scope memory.inbox.dreams.write. Your existing cap_token from the simulation flow already carries scopes—just include that one for collection.
	•	Redaction (optional): set DREAM_INBOX_REDACT=1 to mask emails/phones and scrub obvious secret-looking keys from the stored seed/shards.
	•	Custom location (optional): set DREAM_INBOX_DIR=/absolute/or/relative/path if you don’t want the default memory/inbox/dreams/.

⸻

Sanity check (manual)

After copy-pasting the files, you can quickly sanity-write a shard from a Python shell:

from memory.inbox.dreams.writer import persist_dream_shards

cap = {"scopes": ["memory.inbox.dreams.write"], "exp_ts": 9999999999}
seed = {"goal": "Plan a safe trip to Tokyo", "ul_tags": ["ΛSIM","ΛTR"], "constraints": {"flags": {}}}
result = {"trace_id": "LT-12345-abc1", "shards": [{"trace_id":"LT-12345-abc1","index":0,"timestamp":1723549800000,"proposal":{"summary":"Sample"}}]}

print(persist_dream_shards(seed=seed, result=result, cap_token=cap))
# -> {'path': 'memory/inbox/dreams/LT-12345-abc1.json', 'bytes':  ... , 'shards_written': 1}

That’s it—you now have a minimal, capability-gated Dream Inbox that your simulation lane can write to immediately.
