---
status: wip
type: documentation
owner: unknown
module: visionary
redirect: false
moved_to: null
---

Epicâ€”letâ€™s wire â€œDreamsâ€ end-to-end without breaking the clean layering you just set up. Below are drop-in files you can paste into your repo:
	â€¢	a tiny compatibility bridge that forwards any legacy dream_bridge_adapter calls to the new consciousness.simulation.api
	â€¢	a Memory Inbox writer that persists dream_shard artifacts behind a capability token (defaults to in-memory; optional FS sink via env flag)
	â€¢	optional canary tests to keep CI honest

Iâ€™ve kept everything dependency-light, deterministic, and zero side-effects by default.

â¸»

1) Compatibility Bridge (legacy â†’ new API)

Path: adapters/dream_bridge_adapter.py

"""
Compatibility adapter: forwards legacy dream bridge calls into the new
sandboxed Simulation lane (consciousness.simulation.api).

Notes:
- No direct adapter usage inside the simulation lane.
- Optional persistence to Memory Inbox is gated by a capability token.
"""

from __future__ import annotations
import logging
from typing import Dict, Any, Optional

from consciousness.simulation import api as sim_api

log = logging.getLogger("lukhas.adapters.dream_bridge_adapter")

class BridgePolicyViolation(RuntimeError): ...

async def dream(
    seed: Dict[str, Any],
    *,
    persist: bool = False,
    cap_token: Optional[Dict[str, Any]] = None,
) -> Dict[str, Any]:
    """
    Legacy-compatible entrypoint.

    Args:
        seed: DreamSeed (goal/context/constraints) as defined by sim_api.
        persist: If True, forward dream_shards to Memory Inbox (requires capability).
        cap_token: Capability token dict with scopes & exp_ts for authorization.

    Returns:
        DreamResult as produced by sim_api.collect
    """
    try:
        job_id = await sim_api.schedule(seed)
    except sim_api.PolicyViolation as e:
        raise BridgePolicyViolation(str(e)) from e

    result = await sim_api.collect(job_id)

    # Optional persistence to Memory Inbox (write-only)
    if persist:
        try:
            from memory.inbox.dreams.writer import persist_dream_shards
            persist_dream_shards(seed=seed, result=result, cap_token=cap_token)
        except Exception as e:
            # Never block the caller; log and continue.
            log.warning("Memory inbox persistence failed: %s", e, exc_info=False)

    return result


â¸»

2) Memory Inbox Writer (capability-gated)

2.1 Package layout

memory/
  inbox/
    __init__.py
    dreams/
      __init__.py
      writer.py

Path: memory/inbox/__init__.py

"""Memory inbox entrypoint (write-only sinks)."""

Path: memory/inbox/dreams/__init__.py

"""Dreams inbox: persist advisory 'dream_shard' artifacts."""

Path: memory/inbox/dreams/writer.py

from __future__ import annotations
import json, os, time, re
from typing import Dict, Any, List, Optional, TypedDict

class CapabilityError(RuntimeError): ...
class PersistenceError(RuntimeError): ...

# ---- Capability model (minimal, test-friendly) ----

class CapabilityToken(TypedDict, total=False):
    token_id: str
    scopes: List[str]
    exp_ts: float           # epoch seconds
    issued_ts: float        # optional, for auditing
    # signature: str        # (future) if/when you add signing

REQUIRED_SCOPE = "memory.inbox.dreams.write"

def verify_capability(token: Optional[Dict[str, Any]]) -> None:
    if not token:
        raise CapabilityError("Missing capability token.")
    scopes = set(token.get("scopes") or [])
    if REQUIRED_SCOPE not in scopes:
        raise CapabilityError(f"Missing required scope: {REQUIRED_SCOPE}")
    exp_ts = float(token.get("exp_ts") or 0)
    if exp_ts <= time.time():
        raise CapabilityError("Capability token expired.")

# ---- Redaction helpers ----

_REDACT_KEYS = {"email", "phone", "ssn", "passport", "address", "user_id"}
def _redact_seed(seed: Dict[str, Any]) -> Dict[str, Any]:
    """Shallow redaction for seed.context; extend as needed."""
    ctx = dict(seed.get("context") or {})
    for k in list(ctx.keys()):
        if k.lower() in _REDAC_KEYS or re.search(r"(email|phone|token|secret|pwd)", k, re.I):
            ctx[k] = "[REDACTED]"
    out = dict(seed)
    out["context"] = ctx
    return out

# ---- Persistence strategy ----

# Default to in-memory sink for tests/CI. Optional FS sink if enabled via env.
#   MEMORY_INBOX_FS_ENABLED=true
#   MEMORY_INBOX_ROOT=/absolute/or/relative/path   (default: var/memory_inbox)
_INMEMORY: List[Dict[str, Any]] = []

def _fs_enabled() -> bool:
    return os.getenv("MEMORY_INBOX_FS_ENABLED", "false").lower() in ("1","true","yes","on")

def _root_dir() -> str:
    return os.getenv("MEMORY_INBOX_ROOT", "var/memory_inbox")

def _safe_name(s: str) -> str:
    return re.sub(r"[^A-Za-z0-9._-]+", "-", s)[:80]

def _ensure_dir(path: str) -> None:
    os.makedirs(path, exist_ok=True)

def persist_dream_shards(
    *,
    seed: Dict[str, Any],
    result: Dict[str, Any],
    cap_token: Optional[Dict[str, Any]],
) -> None:
    """
    Write-only persistence of advisory dream shards.
    Never stores raw PII; seed is redacted. Does not read back data.

    Raises:
        CapabilityError if token invalid/missing
        PersistenceError on disk write failures
    """
    verify_capability(cap_token)

    trace_id = str(result.get("trace_id") or "LT-unknown")
    ts = int(time.time())
    redacted_seed = _redact_seed(seed)

    artifacts = []
    for idx, shard in enumerate(result.get("shards") or []):
        artifacts.append({
            "kind": "dream_shard",
            "trace_id": trace_id,
            "timestamp": ts,
            "index": idx,
            "proposal": shard.get("proposal"),
            "risks": shard.get("risks"),
            "scores": shard.get("scores"),
            "ul_tags": (shard.get("proposal") or {}).get("ul_tags"),
            "seed_meta": {
                "goal": redacted_seed.get("goal"),
                "context_keys": sorted((redacted_seed.get("context") or {}).keys()),
                "constraints": {
                    # copy only budgets/safe flags; omit consent details
                    "budgets": ((redacted_seed.get("constraints") or {}).get("budgets") or {}),
                    "flags": ((redacted_seed.get("constraints") or {}).get("flags") or {}),
                },
            },
        })

    # In-memory sink (always)
    _INMEMORY.extend(artifacts)

    # Optional filesystem sink
    if _fs_enabled():
        root = _root_dir()
        path = os.path.join(root, "dreams", _safe_name(trace_id))
        try:
            _ensure_dir(path)
            fname = f"{ts}_{_safe_name(trace_id)}.json"
            with open(os.path.join(path, fname), "w", encoding="utf-8") as f:
                json.dump({"artifacts": artifacts}, f, ensure_ascii=False, indent=2)
        except Exception as e:
            raise PersistenceError(f"FS persistence failed: {e}") from e

def _debug_inmemory_dump() -> List[Dict[str, Any]]:
    """Tests-only helper: returns a copy of current in-memory artifacts."""
    return list(_INMEMORY)

ðŸ”’ Why capability-gated?
The inbox is write-only and requires memory.inbox.dreams.write. This keeps â€œDreamsâ€ decoupled from adapters and ensures only explicitly authorized flows can persist artifacts.

â¸»

3) (Optional) Canary Tests

These keep layering tight (simulation must not import adapters) and verify the bridge + inbox behavior.

Path: tests/adapters/test_dream_bridge_adapter.py

import os, asyncio, time
from adapters.dream_bridge_adapter import dream, BridgePolicyViolation
from consciousness.simulation import api as sim_api

os.environ["SIMULATION_ENABLED"] = "true"

def run(coro): return asyncio.get_event_loop().run_until_complete(coro)

def seed(consented=True):
    scopes = ["simulation.read_context"] if consented else []
    return {
        "goal": "Assess Î›ID onboarding scenarios",
        "context": {"tenant": "demo", "email": "user@example.com"},
        "constraints": {
            "budgets": {"tokens": 500, "seconds": 0.5},
            "consent": {"scopes": scopes},
            "flags": {},
        },
    }

def cap_token(valid=True):
    now = time.time()
    return {
        "token_id": "cap-test-1",
        "scopes": ["memory.inbox.dreams.write"] if valid else [],
        "exp_ts": now + 3600 if valid else now - 10,
        "issued_ts": now - 5,
    }

def test_bridge_happy_path_no_persist():
    res = run(dream(seed()))
    assert "shards" in res and len(res["shards"]) == 3

def test_bridge_persist_with_capability():
    from memory.inbox.dreams.writer import _debug_inmemory_dump
    before = len(_debug_inmemory_dump())
    res = run(dream(seed(), persist=True, cap_token=cap_token(True)))
    after = len(_debug_inmemory_dump())
    assert after > before
    assert res["trace_id"].startswith("LT-")

def test_bridge_denies_without_consent():
    try:
        run(dream(seed(consented=False)))
        assert False, "Expected BridgePolicyViolation"
    except BridgePolicyViolation:
        pass

def test_bridge_persist_denied_without_scope():
    from memory.inbox.dreams.writer import _debug_inmemory_dump, CapabilityError
    before = len(_debug_inmemory_dump())
    try:
        run(dream(seed(), persist=True, cap_token=cap_token(valid=False)))
    except Exception as e:
        # CapabilityError bubbles from writer; bridge logs & continues for safety
        # depending on your preference, you can let it bubbleâ€”here we allow bubble in test
        assert e.__class__.__name__ in ("CapabilityError", "BridgePolicyViolation")
    finally:
        after = len(_debug_inmemory_dump())
        assert after == before  # nothing written

Path: tests/memory/test_dreams_writer.py

import time
from memory.inbox.dreams.writer import (
    persist_dream_shards, _debug_inmemory_dump, CapabilityError
)

def cap():
    now = time.time()
    return {"token_id": "ok", "scopes": ["memory.inbox.dreams.write"], "exp_ts": now + 60}

def test_writer_redacts_seed_and_writes_inmemory():
    seed = {
        "goal": "Improve welcome flow",
        "context": {"email": "user@x.com", "tenant": "demo"},
        "constraints": {"budgets": {"tokens": 100, "seconds": 0.1}, "flags": {}},
    }
    result = {"trace_id": "LT-abc12345", "shards": [{"proposal": {"ul_tags": ["Î›SIM"]}, "risks": [], "scores": {}}]}
    before = len(_debug_inmemory_dump())
    persist_dream_shards(seed=seed, result=result, cap_token=cap())
    after = len(_debug_inmemory_dump())
    assert after == before + 1


â¸»

4) Usage patterns (callers)

Anywhere you previously used a legacy bridge, switch to:

# Option A: go straight to the new lane
from consciousness.simulation import api as sim_api

seed = {
    "goal": "Evaluate onboarding flow for new Î›ID users",
    "context": {"tenant": "demo"},
    "constraints": {
        "budgets": {"tokens": 1500, "seconds": 1.0, "max_rollouts": 3},
        "consent": {"scopes": ["simulation.read_context"]},
        "flags": {},
    },
}

job_id = await sim_api.schedule(seed)
result = await sim_api.collect(job_id)
# Optional persistence in the calling layer:
from memory.inbox.dreams.writer import persist_dream_shards
persist_dream_shards(seed=seed, result=result, cap_token=cap_token_dict)

# Option B: keep legacy call-sites; the adapter forwards & (optionally) persists
from adapters.dream_bridge_adapter import dream
result = await dream(seed, persist=True, cap_token=cap_token_dict)

Default safety: Simulation lane stays side-effect free. Only the calling layer decides whether to persist, and only with a valid capability.

â¸»

5) CI/Config quick notes
	â€¢	Keep SIMULATION_ENABLED=false by default in prod; enable in CI for tests:
	â€¢	e.g. in CI before tests: export SIMULATION_ENABLED=true
	â€¢	(Optional) Enable FS sink locally:
	â€¢	export MEMORY_INBOX_FS_ENABLED=true
	â€¢	export MEMORY_INBOX_ROOT=var/memory_inbox
	â€¢	No adapters are imported from consciousness/simulation/* â€” tests enforce this.

â¸»

If you want, I can also add a tiny inbox reader for admins only (separate capability like memory.inbox.dreams.read_admin) to aid debugging, but I kept this out to honor the write-only posture you asked for.

---

## MATADA Alignment Update (v1)

The compatibility bridge MUST passthrough matada_nodes from simulation.api.collect(). If persist=True, forward both shards and matada_nodes to the Dream Inbox writer. Adapters DO NOT transform nodes.
