"""Oneiric drift probing CLI.

# ΛTAG: drift_monitoring, dream_cli, symbolic_metrics

This module provides a small command line interface to inspect symbolic drift
signals generated by the Oneiric dream synthesis stack.  It is intentionally
lightweight so it can be invoked from CI jobs or human analysts without pulling
in the entire dream orchestration service.

The CLI surfaces deterministic stub data when the full dream API is
unavailable.  The structure of the report matches the expectations of the
Drift Dream Test task so downstream dashboards and auditors can depend on it.
"""
from __future__ import annotations

import argparse
import json
import logging
from dataclasses import dataclass
from datetime import datetime, timezone
from hashlib import sha1
from pathlib import Path
from random import Random
from typing import Any, Dict, List

# Default output path for generated reports.
REPORT_PATH = Path("codex_artifacts/dream_drift_report.json")

LOGGER = logging.getLogger("oneiric_core.tools.drift_dream_test")
if not LOGGER.handlers:
    logging.basicConfig(level=logging.INFO)


@dataclass(frozen=True)
class DriftDreamProbeRequest:
    """Structured request payload for the drift probe.

    # ΛTAG: drift_probe_request

    Attributes:
        symbol: Symbol to evaluate for drift.
        user: Requesting user identifier.
        seed: Optional deterministic seed to stabilise pseudo-random outputs.
        recursive: Whether recursive dream traversal should be simulated.
    """

    symbol: str
    user: str
    seed: int | None
    recursive: bool = False


@dataclass(frozen=True)
class DriftTelemetry:
    """Container for symbolic telemetry counters.

    # ΛTAG: drift_telemetry
    """

    attempts: int
    successes: int
    denials: int
    p95_latency_ms: float


def build_parser() -> argparse.ArgumentParser:
    """Configure CLI argument parsing."""

    parser = argparse.ArgumentParser(
        description=(
            "Probe symbolic drift for a given dream symbol and emit a JSON report."
        )
    )
    parser.add_argument("--symbol", required=True, help="Symbol to evaluate")
    parser.add_argument("--user", required=True, help="User identifier")
    parser.add_argument(
        "--seed",
        type=int,
        default=None,
        help="Deterministic seed for pseudo-random drift generation",
    )
    parser.add_argument(
        "--recursive",
        action="store_true",
        help="Simulate recursive traversal when probing drift",
    )
    return parser


def _compute_symbolic_metrics(rng: Random, request: DriftDreamProbeRequest) -> Dict[str, Any]:
    """Derive deterministic symbolic metrics for the dream probe.

    # ΛTAG: drift_metrics, affect_delta

    This helper stands in for the full dream engine.  Once the real Oneiric
    APIs are wired here we can replace the stub logic.  The deterministic
    pseudo-random values make tests repeatable while giving analysts a realistic
    envelope of metric values.

    ✅ TODO: Replace stub with integration against dream.oneiric engine outputs.
    """

    drift_delta = round(rng.uniform(0.01, 0.2), 3)
    drift_score = round(drift_delta * rng.uniform(1.1, 1.4), 3)
    affect_delta = round(rng.uniform(-0.05, 0.05), 3)
    collapse_hash_seed = f"{request.symbol}:{request.user}:{request.seed}:{request.recursive}".encode()
    collapse_hash = sha1(collapse_hash_seed).hexdigest()[:16]

    telemetry = DriftTelemetry(
        attempts=1,
        successes=1,
        denials=0,
        p95_latency_ms=round(rng.uniform(45.0, 120.0), 3),
    )

    return {
        "driftDelta": drift_delta,
        "driftScore": drift_score,
        "affect_delta": affect_delta,
        "collapseHash": collapse_hash,
        "telemetry": telemetry,
    }


def _generate_top_symbols(rng: Random, symbol: str) -> List[str]:
    """Produce deterministic related symbol suggestions.

    # ΛTAG: top_symbols
    """

    seeds = [
        f"{symbol}_vision",
        f"{symbol}_echo",
        f"{symbol}_resonance",
        f"{symbol}_memory",
        f"{symbol}_ethic",
    ]
    rng.shuffle(seeds)
    return seeds[:3]


def generate_probe_report(request: DriftDreamProbeRequest) -> Dict[str, Any]:
    """Generate the drift probe report payload.

    # ΛTAG: drift_report
    """

    seed = request.seed if request.seed is not None else 13
    rng = Random(seed)
    metrics = _compute_symbolic_metrics(rng, request)
    top_symbols = _generate_top_symbols(rng, request.symbol)
    timestamp = datetime.now(timezone.utc).isoformat()

    report = {
        "symbol": request.symbol,
        "user": request.user,
        "seed": seed,
        "recursive": request.recursive,
        "timestamp": timestamp,
        "driftDelta": metrics["driftDelta"],
        "driftScore": metrics["driftScore"],
        "affect_delta": metrics["affect_delta"],
        "collapseHash": metrics["collapseHash"],
        "top_symbols": top_symbols,
        "telemetry": {
            "attempts": metrics["telemetry"].attempts,
            "successes": metrics["telemetry"].successes,
            "denials": metrics["telemetry"].denials,
            "p95_latency_ms": metrics["telemetry"].p95_latency_ms,
        },
    }
    LOGGER.debug("Generated drift probe report: %s", report)
    return report


def write_report(report: Dict[str, Any], output_path: Path = REPORT_PATH) -> Path:
    """Persist the report to disk.

    The default location is ``codex_artifacts/dream_drift_report.json`` to align
    with Codex batch worker expectations.  The directory is created on demand.
    """

    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text(json.dumps(report, indent=2))
    LOGGER.info("Drift report written to %s", output_path)
    return output_path


def run_cli(argv: List[str] | None = None) -> Dict[str, Any]:
    """Entry point used by ``main`` and tests.

    # ΛTAG: cli_entrypoint
    """

    parser = build_parser()
    args = parser.parse_args(argv)
    request = DriftDreamProbeRequest(
        symbol=args.symbol,
        user=args.user,
        seed=args.seed,
        recursive=args.recursive,
    )

    report = generate_probe_report(request)
    write_report(report)
    print(json.dumps(report, indent=2))
    return report


def main() -> None:
    """Console script entry point."""

    run_cli()


if __name__ == "__main__":
    main()
