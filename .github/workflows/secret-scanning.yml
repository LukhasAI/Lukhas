name: ğŸ” Secret Scanning

on:
  pull_request:
    types: [opened, synchronize, reopened]
  push:
    branches: [main]
  schedule:
    - cron: "37 3 * * *"  # nightly 03:37 UTC

permissions:
  contents: read
  security-events: write
  actions: read

concurrency:
  group: secret-scan-${{ github.ref }}-${{ github.workflow }}
  cancel-in-progress: true

jobs:
  gitleaks:
    name: ğŸ” GitLeaks Secret Detection
    runs-on: ubuntu-latest
    timeout-minutes: 8
    permissions:
      contents: read
      security-events: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for comprehensive scanning

      - name: Install GitLeaks
        run: |
          GITLEAKS_VERSION="8.18.4"
          wget -q "https://github.com/gitleaks/gitleaks/releases/download/v${GITLEAKS_VERSION}/gitleaks_${GITLEAKS_VERSION}_linux_x64.tar.gz"
          tar -xzf "gitleaks_${GITLEAKS_VERSION}_linux_x64.tar.gz"
          sudo mv gitleaks /usr/local/bin/
          gitleaks version

      - name: Create GitLeaks config
        run: |
          cat > .gitleaks.toml << 'EOF'
          # LUKHAS AI Secret Scanning Configuration
          title = "LUKHAS AI GitLeaks Configuration"

          [[rules]]
          id = "generic-api-key"
          description = "Generic API Key"
          regex = '''(?i)(api_key|apikey|api-key)\s*[:=]\s*['"][a-zA-Z0-9]{20,}['"]'''
          tags = ["key", "API"]

          [[rules]]
          id = "openai-api-key"
          description = "OpenAI API Key"
          regex = '''sk-[a-zA-Z0-9]{48}'''
          tags = ["key", "OpenAI"]

          [[rules]]
          id = "anthropic-api-key"
          description = "Anthropic API Key"
          regex = '''sk-ant-[a-zA-Z0-9\-]{95}'''
          tags = ["key", "Anthropic"]

          [[rules]]
          id = "google-api-key"
          description = "Google API Key"
          regex = '''AIza[0-9A-Za-z\-_]{35}'''
          tags = ["key", "Google"]

          [[rules]]
          id = "aws-access-key"
          description = "AWS Access Key"
          regex = '''AKIA[0-9A-Z]{16}'''
          tags = ["key", "AWS"]

          [[rules]]
          id = "aws-secret-key"
          description = "AWS Secret Key"
          regex = '''(?i)aws_secret_access_key\s*[:=]\s*['"][a-zA-Z0-9/+=]{40}['"]'''
          tags = ["secret", "AWS"]

          [[rules]]
          id = "github-token"
          description = "GitHub Token"
          regex = '''ghp_[a-zA-Z0-9]{36}'''
          tags = ["key", "GitHub"]

          [[rules]]
          id = "github-oauth"
          description = "GitHub OAuth"
          regex = '''gho_[a-zA-Z0-9]{36}'''
          tags = ["key", "GitHub"]

          [[rules]]
          id = "jwt-token"
          description = "JWT Token"
          regex = '''eyJ[a-zA-Z0-9\-_]+\.eyJ[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+'''
          tags = ["token", "JWT"]

          [[rules]]
          id = "private-key"
          description = "Private Key"
          regex = '''-----BEGIN PRIVATE KEY-----'''
          tags = ["key", "Private"]

          [[rules]]
          id = "ssh-private-key"
          description = "SSH Private Key"
          regex = '''-----BEGIN (RSA|DSA|EC|OPENSSH) PRIVATE KEY-----'''
          tags = ["key", "SSH"]

          [[rules]]
          id = "password-in-code"
          description = "Password in Code"
          regex = '''(?i)(password|passwd|pwd)\s*[:=]\s*['"][^'"\s]{8,}['"]'''
          tags = ["password"]

          # Allowlisted paths that commonly contain test data or examples
          [allowlist]
          paths = [
            '''tests/.*test.*\.py''',
            '''examples/.*''',
            '''docs/.*''',
            '''.*\.md''',
            '''.*\.rst''',
            '''\.github/.*''',
            '''scripts/.*''',
          ]

          # Allowlisted regexes for common false positives
          regexes = [
            '''sk-FAKE-KEY-.*''',
            '''example_api_key''',
            '''your_api_key_here''',
            '''placeholder.*''',
            '''test.*key.*''',
            '''mock.*''',
            '''dummy.*''',
            '''\$\{.*\}''',  # Template variables
          ]
          EOF

      - name: Run GitLeaks scan
        run: |
          echo "ğŸ” Scanning for secrets in LUKHAS AI repository..."

          # Scan current state
          gitleaks detect --config .gitleaks.toml --verbose --report-format json --report-path gitleaks-report.json || GITLEAKS_EXIT_CODE=$?

          # Also scan git history if on main branch
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            echo "ğŸ“œ Performing historical scan on main branch..."
            gitleaks detect --config .gitleaks.toml --verbose --log-level debug --log-opts="--all" || true
          fi

          # Check if secrets were found
          if [ -f gitleaks-report.json ] && [ -s gitleaks-report.json ]; then
            echo "âš ï¸  Secrets detected! Review the report below:"
            cat gitleaks-report.json | jq '.' || cat gitleaks-report.json
            exit 1
          else
            echo "âœ… No secrets detected in scan"
          fi

      - name: Upload GitLeaks report
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: gitleaks-report-${{ github.run_id }}
          path: gitleaks-report.json
          retention-days: 30

      - name: Upload SARIF results to GitHub Security
        if: failure() && github.event_name == 'push'
        run: |
          # Convert JSON to SARIF if secrets found
          if [ -f gitleaks-report.json ] && [ -s gitleaks-report.json ]; then
            echo "Converting GitLeaks report to SARIF format..."
            cat > convert-to-sarif.py << 'EOF'
          import json
          import sys
          from datetime import datetime

          def convert_to_sarif(gitleaks_json):
              with open(gitleaks_json, 'r') as f:
                  findings = json.load(f)

              if not findings:
                  return None

              sarif = {
                  "version": "2.1.0",
                  "$schema": "https://json.schemastore.org/sarif-2.1.0.json",
                  "runs": [{
                      "tool": {
                          "driver": {
                              "name": "GitLeaks",
                              "informationUri": "https://github.com/gitleaks/gitleaks",
                              "version": "8.18.4"
                          }
                      },
                      "results": []
                  }]
              }

              for finding in findings:
                  result = {
                      "ruleId": finding.get("RuleID", "secret-detected"),
                      "message": {
                          "text": f"Secret detected: {finding.get('Description', 'Unknown secret type')}"
                      },
                      "locations": [{
                          "physicalLocation": {
                              "artifactLocation": {
                                  "uri": finding.get("File", "unknown")
                              },
                              "region": {
                                  "startLine": finding.get("StartLine", 1),
                                  "startColumn": finding.get("StartColumn", 1),
                                  "endLine": finding.get("EndLine", 1),
                                  "endColumn": finding.get("EndColumn", 1)
                              }
                          }
                      }],
                      "level": "error"
                  }
                  sarif["runs"][0]["results"].append(result)

              return sarif

          if __name__ == "__main__":
              sarif_data = convert_to_sarif("gitleaks-report.json")
              if sarif_data:
                  with open("gitleaks.sarif", "w") as f:
                      json.dump(sarif_data, f, indent=2)
                  print("SARIF file created: gitleaks.sarif")
              else:
                  print("No findings to convert")
          EOF

            python convert-to-sarif.py

            if [ -f gitleaks.sarif ]; then
              echo "ğŸ“¤ Uploading SARIF to GitHub Security tab..."
              # Note: This requires the security-events: write permission
              curl -X POST \
                -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                -H "Accept: application/vnd.github.v3+json" \
                "https://api.github.com/repos/${{ github.repository }}/code-scanning/sarifs" \
                -d @gitleaks.sarif || echo "Failed to upload SARIF"
            fi
          fi

  pattern-scan:
    name: ğŸ” Custom Pattern Scanning
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: LUKHAS-specific secret patterns
        run: |
          echo "ğŸ” Scanning for LUKHAS-specific sensitive patterns..."

          # Check for potential consciousness keys or tokens
          if rg -i "consciousness.*(?:key|token|secret)" --type py .; then
            echo "âš ï¸  Found potential consciousness-related secrets"
            exit 1
          fi

          # Check for Lambda ID keys
          if rg -i "lambda.*id.*(?:key|secret)" --type py .; then
            echo "âš ï¸  Found potential Lambda ID secrets"
            exit 1
          fi

          # Check for hard-coded guardian tokens
          if rg -i "guardian.*(?:token|key)" --type py .; then
            echo "âš ï¸  Found potential Guardian system secrets"
            exit 1
          fi

          # Check for MATRIZ access tokens
          if rg -i "matriz.*(?:token|key|secret)" --type py .; then
            echo "âš ï¸  Found potential MATRIZ secrets"
            exit 1
          fi

          # Check for constellation framework secrets
          if rg -i "constellation.*(?:key|secret)" --type py .; then
            echo "âš ï¸  Found potential Constellation framework secrets"
            exit 1
          fi

          # Look for suspicious base64 strings that might be keys
          if rg "['\"][A-Za-z0-9+/]{40,}={0,2}['\"]" --type py . | rg -v "test|example|mock|fake"; then
            echo "âš ï¸  Found potential base64-encoded secrets"
            exit 1
          fi

          echo "âœ… No LUKHAS-specific sensitive patterns detected"

  audit-env-files:
    name: ğŸŒ Environment File Audit
    runs-on: ubuntu-latest
    timeout-minutes: 3
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check for exposed environment files
        run: |
          echo "ğŸ” Auditing environment and configuration files..."

          # Find .env files that might contain secrets
          if find . -name "*.env*" -not -path "./.git/*" -not -path "./venv/*" -not -path "./.venv/*"; then
            echo "âš ï¸  Found environment files - ensure they don't contain secrets"
            find . -name "*.env*" -not -path "./.git/*" -exec head -5 {} \;
          fi

          # Check for config files with potential secrets
          config_files=$(find . -name "config.json" -o -name "settings.json" -o -name "credentials.json" -not -path "./.git/*")
          if [ -n "$config_files" ]; then
            echo "âš ï¸  Found configuration files that may contain secrets:"
            echo "$config_files"

            # Check if they contain secret-like patterns
            for file in $config_files; do
              if rg -i "(?:api_key|password|secret|token)" "$file" 2>/dev/null; then
                echo "ğŸš¨ File $file contains potential secrets!"
                exit 1
              fi
            done
          fi

          echo "âœ… Environment file audit completed"

  summary:
    name: ğŸ›¡ï¸ Secret Scanning Summary
    runs-on: ubuntu-latest
    needs: [gitleaks, pattern-scan, audit-env-files]
    if: always()
    steps:
      - name: Security scanning summary
        run: |
          echo "ğŸ” LUKHAS AI Secret Scanning Results"
          echo "=================================="
          echo "GitLeaks: ${{ needs.gitleaks.result }}"
          echo "Pattern Scan: ${{ needs.pattern-scan.result }}"
          echo "Env Audit: ${{ needs.audit-env-files.result }}"

          if [ "${{ needs.gitleaks.result }}" = "failure" ] || [ "${{ needs.pattern-scan.result }}" = "failure" ] || [ "${{ needs.audit-env-files.result }}" = "failure" ]; then
            echo "ğŸš¨ Security issues detected! Review the failed jobs above."
            exit 1
          else
            echo "âœ… All security scans passed successfully"
          fi