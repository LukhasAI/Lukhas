name: ğŸ“Š Test Coverage Gates

on:
  pull_request:
    types: [opened, synchronize, reopened]
  push:
    branches: [main]
  schedule:
    - cron: "23 5 * * *"  # nightly 05:23 UTC

permissions:
  contents: read
  pull-requests: write
  checks: write

concurrency:
  group: coverage-${{ github.ref }}-${{ github.workflow }}
  cancel-in-progress: true

jobs:
  coverage-analysis:
    name: ğŸ“ˆ Coverage Analysis
    runs-on: ubuntu-latest
    timeout-minutes: 15
    env:
      LUKHAS_COVERAGE_THRESHOLD: 75
      LUKHAS_CRITICAL_THRESHOLD: 85
    steps:
      - name: Checkout code
        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332
        with:
          fetch-depth: 0  # Need history for coverage comparison

      - name: Setup Python
        uses: actions/setup-python@82c7e631bb3cdc910f68e0081d67478d79c6982d
        with:
          python-version: "3.11"

      - uses: actions/cache@0c45773b623bea8c8e75f6c82b208c3cf94ea4f9
        with:
          path: ~/.cache/pip
          key: pip-coverage-${{ runner.os }}-${{ hashFiles('requirements*.txt', 'pyproject.toml') }}-v1
          restore-keys: |
            pip-coverage-${{ runner.os }}-

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -e '.[dev]'
          pip install pytest-xdist pytest-cov coverage[toml]

      - name: Run comprehensive test suite
        run: |
          echo "ğŸ§ª Running comprehensive test suite for coverage analysis..."

          # Run all tests with coverage (excluding slow/enterprise tests)
          coverage run --branch --source=lukhas,consciousness,governance,identity,memoria,matriz -m pytest \
            -x --tb=short --disable-warnings \
            -m "not enterprise and not cloud and not bench" \
            --maxfail=5

          echo "âœ… Test suite completed"

      - name: Generate coverage reports
        run: |
          echo "ğŸ“Š Generating coverage reports..."

          # Text report for CI logs
          coverage report --show-missing --skip-covered

          # XML report for tools
          coverage xml -o coverage.xml

          # HTML report for artifact
          coverage html -d coverage-html

          # JSON report for analysis
          coverage json -o coverage.json

          # Extract key metrics
          TOTAL_COVERAGE=$(coverage report --format=total)
          echo "TOTAL_COVERAGE=$TOTAL_COVERAGE" >> $GITHUB_ENV

          # Get uncovered lines count
          UNCOVERED_LINES=$(coverage report --format=json | python3 -c "
          import sys, json
          data = json.load(sys.stdin)
          total_missing = sum(f['summary']['missing_lines'] for f in data['files'].values())
          print(total_missing)
          ")
          echo "UNCOVERED_LINES=$UNCOVERED_LINES" >> $GITHUB_ENV

          echo "ğŸ“ˆ Total Coverage: $TOTAL_COVERAGE%"
          echo "ğŸ“‰ Uncovered Lines: $UNCOVERED_LINES"

      - name: Analyze coverage by module
        run: |
          echo "ğŸ” Analyzing coverage by LUKHAS module..."

          python3 - <<'EOF'
          import json
          import sys

          with open('coverage.json', 'r') as f:
              data = json.load(f)

          print("## ğŸ“Š Coverage by Module")
          print("| Module | Coverage | Missing Lines | Status |")
          print("|--------|----------|---------------|--------|")

          modules = {
              'consciousness/': 'Consciousness',
              'identity/': 'Identity',
              'governance/': 'Governance',
              'memory/': 'Memory',
              'core/': 'Core',
              'consciousness/': 'Consciousness',
              'governance/': 'Governance',
              'identity/': 'Identity',
              'memoria/': 'Memory',
              'matriz/': 'MATRIZ'
          }

          total_summary = {'covered': 0, 'missing': 0}

          for module_path, module_name in modules.items():
              module_files = {k: v for k, v in data['files'].items() if k.startswith(module_path)}

              if not module_files:
                  print(f"| {module_name} | N/A | N/A | âšª No Files |")
                  continue

              covered = sum(f['summary']['covered_lines'] for f in module_files.values())
              missing = sum(f['summary']['missing_lines'] for f in module_files.values())
              total = covered + missing

              if total > 0:
                  coverage_pct = round((covered / total) * 100, 1)

                  if coverage_pct >= 85:
                      status = "ğŸŸ¢ Excellent"
                  elif coverage_pct >= 75:
                      status = "ğŸŸ¡ Good"
                  elif coverage_pct >= 60:
                      status = "ğŸŸ  Needs Work"
                  else:
                      status = "ğŸ”´ Critical"

                  print(f"| {module_name} | {coverage_pct}% | {missing} | {status} |")

                  total_summary['covered'] += covered
                  total_summary['missing'] += missing
              else:
                  print(f"| {module_name} | N/A | N/A | âšª Empty |")

          # Overall summary
          total_lines = total_summary['covered'] + total_summary['missing']
          if total_lines > 0:
              overall_pct = round((total_summary['covered'] / total_lines) * 100, 1)
              print(f"| **Overall** | **{overall_pct}%** | **{total_summary['missing']}** | - |")

          print(f"\nğŸ“Š **Total Coverage: {overall_pct}%**")
          print(f"ğŸ“ˆ Covered Lines: {total_summary['covered']}")
          print(f"ğŸ“‰ Missing Lines: {total_summary['missing']}")
          EOF

      - name: Coverage threshold enforcement
        run: |
          echo "ğŸ¯ Enforcing coverage thresholds..."

          THRESHOLD=${LUKHAS_COVERAGE_THRESHOLD}
          CRITICAL_THRESHOLD=${LUKHAS_CRITICAL_THRESHOLD}

          echo "ğŸ“Š Current Coverage: $TOTAL_COVERAGE%"
          echo "ğŸ¯ Required Threshold: $THRESHOLD%"
          echo "â­ Critical Threshold: $CRITICAL_THRESHOLD%"

          # Check thresholds
          if [ "$TOTAL_COVERAGE" -lt "$THRESHOLD" ]; then
            echo "ğŸš¨ Coverage $TOTAL_COVERAGE% below required $THRESHOLD% threshold"
            echo "COVERAGE_GATE_FAILED=true" >> $GITHUB_ENV

            if [ "$TOTAL_COVERAGE" -lt 50 ]; then
              echo "ğŸ’¥ CRITICAL: Coverage below 50% - immediate action required"
              exit 1
            fi
          else
            echo "âœ… Coverage meets $THRESHOLD% threshold"
            echo "COVERAGE_GATE_FAILED=false" >> $GITHUB_ENV

            if [ "$TOTAL_COVERAGE" -ge "$CRITICAL_THRESHOLD" ]; then
              echo "â­ EXCELLENT: Coverage exceeds $CRITICAL_THRESHOLD% critical threshold"
            fi
          fi

      - name: Compare with main branch
        if: github.event_name == 'pull_request'
        run: |
          echo "ğŸ“Š Comparing coverage with main branch..."

          # Try to get main branch coverage
          git fetch origin main:main || true

          if git show main:coverage.json > main-coverage.json 2>/dev/null; then
            MAIN_COVERAGE=$(python3 -c "
            import json
            with open('main-coverage.json') as f:
                data = json.load(f)
            print(int(round(data['totals']['percent_covered'])))
            ")

            COVERAGE_DIFF=$((TOTAL_COVERAGE - MAIN_COVERAGE))

            echo "ğŸ“ˆ Main Branch Coverage: $MAIN_COVERAGE%"
            echo "ğŸ“Š Current Coverage: $TOTAL_COVERAGE%"
            echo "ğŸ“‰ Coverage Difference: $COVERAGE_DIFF%"

            if [ "$COVERAGE_DIFF" -lt -5 ]; then
              echo "ğŸš¨ Coverage decreased by more than 5% from main"
              echo "COVERAGE_REGRESSION=true" >> $GITHUB_ENV
            elif [ "$COVERAGE_DIFF" -gt 5 ]; then
              echo "ğŸ‰ Coverage improved by more than 5% from main"
              echo "COVERAGE_IMPROVEMENT=true" >> $GITHUB_ENV
            else
              echo "ğŸ“Š Coverage change within acceptable range"
              echo "COVERAGE_STABLE=true" >> $GITHUB_ENV
            fi
          else
            echo "âš ï¸  Could not compare with main branch coverage"
          fi

      - name: Generate coverage badge
        run: |
          echo "ğŸ·ï¸  Generating coverage badge..."

          # Create badge data
          if [ "$TOTAL_COVERAGE" -ge 90 ]; then
            COLOR="brightgreen"
          elif [ "$TOTAL_COVERAGE" -ge 75 ]; then
            COLOR="green"
          elif [ "$TOTAL_COVERAGE" -ge 60 ]; then
            COLOR="yellow"
          elif [ "$TOTAL_COVERAGE" -ge 40 ]; then
            COLOR="orange"
          else
            COLOR="red"
          fi

          # Create shields.io badge URL
          BADGE_URL="https://img.shields.io/badge/Coverage-${TOTAL_COVERAGE}%25-${COLOR}"
          echo "COVERAGE_BADGE_URL=$BADGE_URL" >> $GITHUB_ENV

          echo "ğŸ·ï¸  Badge URL: $BADGE_URL"

      - name: Upload coverage reports
        uses: actions/upload-artifact@834a144ee995460fba8ed112a2fc961b36a5ec5a
        with:
          name: coverage-reports-${{ github.run_id }}
          path: |
            coverage.xml
            coverage.json
            coverage-html/
          retention-days: 30

      - name: Upload to Codecov
        if: always()
        uses: codecov/codecov-action@v4
        with:
          files: coverage.xml
          fail_ci_if_error: false
          verbose: true

      - name: Comment PR with coverage
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const coverage = process.env.TOTAL_COVERAGE;
            const uncovered = process.env.UNCOVERED_LINES;
            const threshold = process.env.LUKHAS_COVERAGE_THRESHOLD;
            const failed = process.env.COVERAGE_GATE_FAILED === 'true';
            const regression = process.env.COVERAGE_REGRESSION === 'true';
            const improvement = process.env.COVERAGE_IMPROVEMENT === 'true';

            let emoji = 'ğŸ“Š';
            let status = 'meets threshold';

            if (failed) {
              emoji = 'ğŸš¨';
              status = 'below threshold';
            } else if (improvement) {
              emoji = 'ğŸ‰';
              status = 'improved significantly';
            } else if (regression) {
              emoji = 'âš ï¸';
              status = 'decreased from main';
            }

            const body = `
            ## ${emoji} Test Coverage Report

            **Current Coverage: ${coverage}%** (${status})

            - ğŸ“Š Coverage Threshold: ${threshold}%
            - ğŸ“ˆ Covered Lines: ${Number(coverage) * 100 / 100}%
            - ğŸ“‰ Uncovered Lines: ${uncovered}
            - ğŸ¯ Status: ${failed ? 'âŒ Below Threshold' : 'âœ… Passes'}

            ${regression ? 'âš ï¸ **Warning:** Coverage decreased from main branch' : ''}
            ${improvement ? 'ğŸ‰ **Great:** Coverage improved significantly!' : ''}

            <details>
            <summary>ğŸ“Š View detailed coverage report</summary>

            See the full coverage report in the [workflow artifacts](${context.payload.pull_request.html_url}/checks).

            </details>

            ${failed ? '**Action Required:** Add tests to increase coverage above ' + threshold + '%' : ''}
            `;

            // Update or create comment
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.data.find(comment =>
              comment.user.type === 'Bot' && comment.body.includes('Test Coverage Report')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }

  critical-file-coverage:
    name: ğŸ¯ Critical File Coverage
    runs-on: ubuntu-latest
    timeout-minutes: 8
    needs: [coverage-analysis]
    steps:
      - name: Checkout code
        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332

      - name: Setup Python
        uses: actions/setup-python@82c7e631bb3cdc910f68e0081d67478d79c6982d
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -e '.[dev]'
          pip install coverage

      - name: Download coverage data
        uses: actions/download-artifact@fa0a91b85d4f404e444e00e005971372dc801d16
        with:
          name: coverage-reports-${{ github.run_id }}

      - name: Analyze critical file coverage
        run: |
          echo "ğŸ¯ Analyzing coverage for critical LUKHAS files..."

          python3 - <<'EOF'
          import json

          with open('coverage.json', 'r') as f:
              data = json.load(f)

          # Define critical files that must have high coverage
          critical_files = [
              'core/',
              'consciousness/__init__.py',
              'governance/auth_integration_system.py',
              'identity/lambda_id.py',
              'memoria/fold_manager.py'
          ]

          print("## ğŸ¯ Critical File Coverage Analysis")
          print("| File | Coverage | Missing | Status |")
          print("|------|----------|---------|--------|")

          critical_issues = []

          for file_path, file_data in data['files'].items():
              is_critical = any(critical in file_path for critical in critical_files)

              if is_critical:
                  summary = file_data['summary']
                  total_lines = summary['covered_lines'] + summary['missing_lines']

                  if total_lines > 0:
                      coverage_pct = round((summary['covered_lines'] / total_lines) * 100, 1)

                      if coverage_pct < 85:
                          status = "ğŸš¨ CRITICAL"
                          critical_issues.append(f"{file_path}: {coverage_pct}%")
                      elif coverage_pct < 90:
                          status = "âš ï¸ Needs Work"
                      else:
                          status = "âœ… Good"

                      print(f"| `{file_path}` | {coverage_pct}% | {summary['missing_lines']} | {status} |")

          if critical_issues:
              print(f"\nğŸš¨ **Critical Coverage Issues Found:**")
              for issue in critical_issues:
                  print(f"- {issue}")
              print(f"\n**Action Required:** Critical files must have >85% coverage")
              exit(1)
          else:
              print(f"\nâœ… All critical files meet coverage requirements")
          EOF

  summary:
    name: ğŸ“‹ Coverage Gates Summary
    runs-on: ubuntu-latest
    needs: [coverage-analysis, critical-file-coverage]
    if: always()
    steps:
      - name: Coverage gates summary
        run: |
          echo "ğŸ“Š LUKHAS AI Coverage Gates Results"
          echo "================================="
          echo "Coverage Analysis: ${{ needs.coverage-analysis.result }}"
          echo "Critical Files: ${{ needs.critical-file-coverage.result }}"

          if [ "${{ needs.coverage-analysis.result }}" = "failure" ] || [ "${{ needs.critical-file-coverage.result }}" = "failure" ]; then
            echo "ğŸš¨ Coverage gates failed! Review test coverage and add missing tests."
            exit 1
          else
            echo "âœ… All coverage gates passed successfully"
          fi