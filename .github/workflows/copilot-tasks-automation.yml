name: Copilot Tasks Automation

on:
  workflow_dispatch:
    inputs:
      task:
        description: 'Task to run (task2-oauth, task3-governance, task4-webauthn, or all)'
        required: true
        default: 'all'
        type: choice
        options:
          - all
          - task2-oauth
          - task3-governance
          - task4-webauthn

jobs:
  run-copilot-tasks:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.9'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install typing-extensions
      
      - name: Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
      
      - name: Run Task 2 - OAuth Evaluation ADR
        if: ${{ github.event.inputs.task == 'all' || github.event.inputs.task == 'task2-oauth' }}
        run: |
          echo "Creating Task 2: OAuth Evaluation ADR"
          BRANCH="feat/oauth-evaluation-adr"
          git checkout -b $BRANCH
          
          mkdir -p docs/adr
          cat > docs/adr/0001-oauth-provider-evaluation.md << 'EOF'
          # ADR 0001: OAuth Provider Evaluation
          
          **Status**: Proposed  
          **Date**: 2025-11-01  
          **Deciders**: Identity Team  
          **Context**: Copilot Task 2
          
          ## Context and Problem Statement
          
          The LUKHAS identity system requires OAuth 2.0 / OpenID Connect integration for external authentication providers. We need to evaluate suitable OAuth providers that align with our Constellation Framework (‚öõÔ∏è Identity ¬∑ üß† Consciousness ¬∑ üõ°Ô∏è Guardian) and ŒªID authentication architecture.
          
          ## Decision Drivers
          
          - **Security**: OAuth 2.1 compliance, PKCE support, token security
          - **Privacy**: GDPR compliance, data minimization, user control
          - **Integration**: Compatibility with existing ŒªID token infrastructure
          - **Ethics**: Alignment with Guardian principles and constitutional AI
          - **Cost**: Pricing model, scalability, free tier availability
          - **Developer Experience**: SDK quality, documentation, support
          
          ## Considered Options
          
          ### Option 1: Auth0 (Okta)
          
          **Pros:**
          - ‚úÖ Enterprise-grade security and compliance (SOC 2, GDPR)
          - ‚úÖ Excellent SDK support for Python
          - ‚úÖ Universal Login with customizable UI
          - ‚úÖ Built-in MFA and anomaly detection
          - ‚úÖ Extensive documentation and community
          
          **Cons:**
          - ‚ùå Higher cost at scale ($240/month for 1000 MAU)
          - ‚ùå Vendor lock-in concerns
          - ‚ùå Complex pricing structure
          
          **Alignment with LUKHAS:**
          - ‚öõÔ∏è Identity: Strong identity management primitives
          - üõ°Ô∏è Guardian: Built-in anomaly detection aligns with drift monitoring
          - üß† Consciousness: Limited; no awareness primitives
          
          ### Option 2: Keycloak (Open Source)
          
          **Pros:**
          - ‚úÖ Open source, self-hosted, no vendor lock-in
          - ‚úÖ OAuth 2.0, OpenID Connect, SAML 2.0 support
          - ‚úÖ Fine-grained authorization policies
          - ‚úÖ Active community, Red Hat backing
          - ‚úÖ No per-user costs
          
          **Cons:**
          - ‚ùå Requires self-hosting and maintenance
          - ‚ùå Infrastructure and operational overhead
          - ‚ùå Less polished admin UI compared to SaaS
          
          **Alignment with LUKHAS:**
          - ‚öõÔ∏è Identity: Full control over identity flows
          - üõ°Ô∏è Guardian: Can implement custom ethical policies
          - üß† Consciousness: Extensible for custom awareness logic
          
          ### Option 3: WorkOS
          
          **Pros:**
          - ‚úÖ Developer-first API design
          - ‚úÖ Modern OAuth 2.1 / PKCE support
          - ‚úÖ Enterprise SSO ready (SAML, OIDC)
          - ‚úÖ Simple, transparent pricing ($0.05/MAU)
          - ‚úÖ Excellent Python SDK
          
          **Cons:**
          - ‚ùå Newer provider, smaller ecosystem
          - ‚ùå Limited advanced features vs Auth0
          - ‚ùå Fewer third-party integrations
          
          **Alignment with LUKHAS:**
          - ‚öõÔ∏è Identity: Clean integration with ŒªID token types
          - üõ°Ô∏è Guardian: Audit logs available but limited drift detection
          - üß† Consciousness: Neutral; extensible via webhooks
          
          ## Decision Outcome
          
          **Chosen Option: Keycloak (self-hosted) with WorkOS as fallback**
          
          **Rationale:**
          1. **Sovereignty**: Self-hosting aligns with Guardian principles (no external dependency for critical identity)
          2. **Extensibility**: Can integrate directly with ŒªID, consciousness modules, and Guardian audit trails
          3. **Cost**: Predictable infrastructure costs vs per-user SaaS pricing
          4. **Ethics**: Full control over data residency, privacy policies, and ethical constraints
          5. **Fallback**: WorkOS provides cloud option for rapid prototyping or enterprise deployments
          
          ### Implementation Plan
          
          **Phase 1: Keycloak Setup (Weeks 1-2)**
          - Deploy Keycloak on Kubernetes with Helm chart
          - Configure OIDC provider for LUKHAS realm
          - Integrate with existing `lukhas.identity.token_types` (PR #798)
          - Implement ŒªID <-> Keycloak token exchange
          
          **Phase 2: Guardian Integration (Weeks 3-4)**
          - Add Keycloak audit events to Guardian monitoring
          - Implement drift detection for unusual login patterns
          - Configure ethical policies (rate limiting, suspicious activity alerts)
          
          **Phase 3: Consciousness Bridge (Week 5)**
          - Create Keycloak event listener for consciousness stream
          - Log authentication events to memory fold system
          - Enable identity-aware decision tracking
          
          **Phase 4: WorkOS Fallback (Week 6)**
          - Implement WorkOS adapter as secondary provider
          - Add provider selection to deployment config
          - Document migration path from Keycloak to WorkOS
          
          ## Consequences
          
          **Positive:**
          - ‚úÖ Complete control over identity architecture
          - ‚úÖ Deep integration with Constellation Framework
          - ‚úÖ Cost-effective at scale
          - ‚úÖ Aligns with constitutional AI principles
          
          **Negative:**
          - ‚ùå Additional operational overhead (Keycloak maintenance)
          - ‚ùå Slower initial setup vs SaaS
          - ‚ùå Requires DevOps expertise for production deployment
          
          **Risks & Mitigation:**
          - **Risk**: Keycloak security vulnerabilities  
            **Mitigation**: Automated security patches, CVE monitoring, Guardian drift detection
          - **Risk**: Performance issues at scale  
            **Mitigation**: Horizontal scaling, database optimization, WorkOS fallback
          
          ## References
          
          - [OAuth 2.1 Specification](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-07)
          - [Keycloak Documentation](https://www.keycloak.org/documentation)
          - [WorkOS Documentation](https://workos.com/docs)
          - LUKHAS Token Types: `lukhas/identity/token_types.py` (PR #798)
          - LUKHAS Guardian Framework: `ethics/guardian/`
          
          ## Related Decisions
          
          - ADR 0002: WebAuthn/Passkey Integration (Task 4)
          - ADR 0003: Identity Governance Model (Task 3)
          EOF
          
          git add docs/adr/0001-oauth-provider-evaluation.md
          git commit -m "docs(identity): add OAuth provider evaluation ADR

          Problem: Need to evaluate OAuth providers for LUKHAS identity system integration.
          Solution: Create ADR comparing Auth0, Keycloak, and WorkOS options.
          Impact: Technical decision record for OAuth strategy; recommends Keycloak with WorkOS fallback."
          
          git push origin $BRANCH
          
          gh pr create \
            --title "docs(identity): OAuth provider evaluation ADR (Task 2)" \
            --body "**Copilot Task 2 Complete**: OAuth Evaluation ADR

          ## Summary
          Evaluates OAuth 2.0/OIDC providers for LUKHAS identity system.

          ## Decision
          - **Primary**: Keycloak (self-hosted) for sovereignty and Guardian integration
          - **Fallback**: WorkOS for enterprise/cloud deployments

          ## Key Considerations
          - ‚öõÔ∏è Identity: Deep ŒªID integration
          - üõ°Ô∏è Guardian: Audit trails and drift detection
          - üß† Consciousness: Event streaming to memory folds

          ## Next Steps
          - [ ] Deploy Keycloak on staging
          - [ ] Integrate with PR #798 token types
          - [ ] Implement Guardian monitoring

          Related: #798 (Token Infrastructure)" \
            --base main \
            --head $BRANCH
      
      - name: Run Task 3 - Governance Example
        if: ${{ github.event.inputs.task == 'all' || github.event.inputs.task == 'task3-governance' }}
        run: |
          echo "Creating Task 3: Identity Governance Example"
          git checkout main
          git pull
          BRANCH="feat/identity-governance-example"
          git checkout -b $BRANCH
          
          mkdir -p examples/identity
          cat > examples/identity/governance_example.py << 'EOF'
          """
          LUKHAS Identity Governance Example
          
          Demonstrates identity governance patterns using the Constellation Framework:
          - ‚öõÔ∏è Identity: ŒªID token lifecycle and validation
          - üõ°Ô∏è Guardian: Constitutional AI governance rules
          - üß† Consciousness: Identity-aware decision tracking
          
          Related: Copilot Task 3
          """
          from datetime import datetime, timedelta
          from typing import Dict, Any, Optional
          from dataclasses import dataclass, field
          
          # Import token types from PR #798
          try:
              from lukhas.identity.token_types import (
                  TokenClaims,
                  validate_token_claims,
                  is_token_expired,
                  get_remaining_lifetime,
              )
          except ImportError:
              # Fallback for environments without lukhas installed
              print("Warning: lukhas.identity.token_types not available, using mock types")
              TokenClaims = Dict[str, Any]
              
              def validate_token_claims(claims: Dict[str, Any]) -> TokenClaims:
                  return claims
              
              def is_token_expired(claims: TokenClaims) -> bool:
                  exp = claims.get("exp", 0)
                  return datetime.utcnow().timestamp() > exp
              
              def get_remaining_lifetime(claims: TokenClaims) -> timedelta:
                  exp = claims.get("exp", 0)
                  remaining = exp - datetime.utcnow().timestamp()
                  return timedelta(seconds=max(0, remaining))
          
          
          @dataclass
          class GovernancePolicy:
              """Constitutional AI governance policy for identity operations."""
              
              name: str
              description: str
              max_session_duration: timedelta = timedelta(hours=8)
              require_mfa: bool = True
              allow_token_refresh: bool = True
              max_failed_attempts: int = 3
              drift_threshold: float = 0.05  # 5% deviation triggers Guardian alert
              consciousness_logging: bool = True
          
          
          @dataclass
          class IdentitySession:
              """Identity session with Guardian oversight and consciousness tracking."""
              
              user_id: str
              token_claims: TokenClaims
              policy: GovernancePolicy
              created_at: datetime = field(default_factory=datetime.utcnow)
              failed_attempts: int = 0
              consciousness_events: list = field(default_factory=list)
              guardian_alerts: list = field(default_factory=list)
              
              def validate_session(self) -> tuple[bool, Optional[str]]:
                  """
                  Validate session against governance policy.
                  
                  Returns:
                      (is_valid, error_message)
                  """
                  # Check token expiration
                  if is_token_expired(self.token_claims):
                      self._record_guardian_alert("Session token expired")
                      return False, "Token expired"
                  
                  # Check session duration
                  session_age = datetime.utcnow() - self.created_at
                  if session_age > self.policy.max_session_duration:
                      self._record_guardian_alert(f"Session exceeded max duration: {session_age}")
                      return False, f"Session duration exceeded ({session_age} > {self.policy.max_session_duration})"
                  
                  # Check failed attempts
                  if self.failed_attempts >= self.policy.max_failed_attempts:
                      self._record_guardian_alert(f"Max failed attempts reached: {self.failed_attempts}")
                      return False, f"Too many failed attempts ({self.failed_attempts})"
                  
                  # Record consciousness event
                  if self.policy.consciousness_logging:
                      self._record_consciousness_event("session_validated", {
                          "user_id": self.user_id,
                          "remaining_lifetime": str(get_remaining_lifetime(self.token_claims)),
                          "session_age": str(session_age),
                      })
                  
                  return True, None
              
              def record_failed_attempt(self, reason: str) -> None:
                  """Record failed authentication attempt with Guardian monitoring."""
                  self.failed_attempts += 1
                  self._record_guardian_alert(f"Failed attempt #{self.failed_attempts}: {reason}")
                  
                  # Check for drift (unusual failure rate)
                  if self.failed_attempts >= self.policy.max_failed_attempts * self.policy.drift_threshold:
                      self._record_guardian_alert(
                          f"‚ö†Ô∏è DRIFT DETECTED: Unusual failure rate ({self.failed_attempts} attempts)"
                      )
              
              def _record_consciousness_event(self, event_type: str, metadata: Dict[str, Any]) -> None:
                  """Log event to consciousness stream for memory fold integration."""
                  event = {
                      "timestamp": datetime.utcnow().isoformat(),
                      "event_type": event_type,
                      "user_id": self.user_id,
                      "metadata": metadata,
                  }
                  self.consciousness_events.append(event)
                  print(f"üß† Consciousness Event: {event_type} - {metadata}")
              
              def _record_guardian_alert(self, message: str) -> None:
                  """Log Guardian alert for constitutional AI monitoring."""
                  alert = {
                      "timestamp": datetime.utcnow().isoformat(),
                      "user_id": self.user_id,
                      "message": message,
                  }
                  self.guardian_alerts.append(alert)
                  print(f"üõ°Ô∏è Guardian Alert: {message}")
          
          
          class IdentityGovernanceOrchestrator:
              """
              Orchestrates identity governance using Constellation Framework patterns.
              
              Integrates:
              - ‚öõÔ∏è Identity: Token validation and lifecycle
              - üõ°Ô∏è Guardian: Policy enforcement and drift detection
              - üß† Consciousness: Event logging for memory folds
              """
              
              def __init__(self, policy: GovernancePolicy):
                  self.policy = policy
                  self.active_sessions: Dict[str, IdentitySession] = {}
              
              def create_session(self, user_id: str, token_claims: TokenClaims) -> IdentitySession:
                  """Create new identity session with governance oversight."""
                  # Validate token claims
                  validated_claims = validate_token_claims(token_claims)
                  
                  # Create session
                  session = IdentitySession(
                      user_id=user_id,
                      token_claims=validated_claims,
                      policy=self.policy,
                  )
                  
                  self.active_sessions[user_id] = session
                  print(f"‚úÖ Created session for user: {user_id}")
                  return session
              
              def validate_access(self, user_id: str) -> tuple[bool, Optional[str]]:
                  """Validate user access against governance policy."""
                  session = self.active_sessions.get(user_id)
                  if not session:
                      return False, "No active session"
                  
                  return session.validate_session()
              
              def get_governance_report(self) -> Dict[str, Any]:
                  """Generate governance report for Guardian audit."""
                  return {
                      "active_sessions": len(self.active_sessions),
                      "total_guardian_alerts": sum(
                          len(s.guardian_alerts) for s in self.active_sessions.values()
                      ),
                      "total_consciousness_events": sum(
                          len(s.consciousness_events) for s in self.active_sessions.values()
                      ),
                      "policy": {
                          "name": self.policy.name,
                          "max_session_duration": str(self.policy.max_session_duration),
                          "require_mfa": self.policy.require_mfa,
                          "drift_threshold": self.policy.drift_threshold,
                      },
                  }
          
          
          def main():
              """Demonstrate identity governance patterns."""
              print("=" * 60)
              print("LUKHAS Identity Governance Example")
              print("Constellation Framework: ‚öõÔ∏è Identity ¬∑ üõ°Ô∏è Guardian ¬∑ üß† Consciousness")
              print("=" * 60)
              print()
              
              # Define governance policy
              policy = GovernancePolicy(
                  name="standard_user_policy",
                  description="Standard governance for authenticated users",
                  max_session_duration=timedelta(hours=8),
                  require_mfa=True,
                  max_failed_attempts=3,
                  drift_threshold=0.05,
                  consciousness_logging=True,
              )
              
              # Create governance orchestrator
              orchestrator = IdentityGovernanceOrchestrator(policy)
              
              # Example 1: Valid session
              print("Example 1: Valid Session")
              print("-" * 40)
              token_claims: TokenClaims = {
                  "iss": "lukhas-identity",
                  "sub": "user-123",
                  "aud": "lukhas-api",
                  "exp": int((datetime.utcnow() + timedelta(hours=1)).timestamp()),
                  "iat": int(datetime.utcnow().timestamp()),
              }
              session = orchestrator.create_session("user-123", token_claims)
              is_valid, error = orchestrator.validate_access("user-123")
              print(f"Session valid: {is_valid}")
              print()
              
              # Example 2: Failed attempts with Guardian monitoring
              print("Example 2: Failed Attempts with Guardian Drift Detection")
              print("-" * 40)
              session.record_failed_attempt("Invalid password")
              session.record_failed_attempt("Invalid MFA code")
              session.record_failed_attempt("Account locked")
              is_valid, error = orchestrator.validate_access("user-123")
              print(f"Session valid after failures: {is_valid}, Error: {error}")
              print()
              
              # Example 3: Governance report
              print("Example 3: Governance Report")
              print("-" * 40)
              report = orchestrator.get_governance_report()
              print(f"Active sessions: {report['active_sessions']}")
              print(f"Guardian alerts: {report['total_guardian_alerts']}")
              print(f"Consciousness events: {report['total_consciousness_events']}")
              print()
              
              print("=" * 60)
              print("‚úÖ Identity Governance Example Complete")
              print("=" * 60)
          
          
          if __name__ == "__main__":
              main()
          EOF
          
          git add examples/identity/governance_example.py
          git commit -m "feat(identity): add governance example with Guardian integration

          Problem: Need example demonstrating identity governance patterns with Constellation Framework.
          Solution: Create example showing ŒªID token lifecycle, Guardian policy enforcement, and consciousness logging.
          Impact: Developers can reference this example for implementing identity governance; low-risk educational code."
          
          git push origin $BRANCH
          
          gh pr create \
            --title "feat(identity): governance example with Guardian integration (Task 3)" \
            --body "**Copilot Task 3 Complete**: Identity Governance Example

          ## Summary
          Demonstrates identity governance patterns using the Constellation Framework.

          ## Features
          - ‚öõÔ∏è **Identity**: ŒªID token lifecycle management
          - üõ°Ô∏è **Guardian**: Policy enforcement and drift detection
          - üß† **Consciousness**: Event logging for memory integration

          ## Code Structure
          - \`GovernancePolicy\`: Constitutional AI policy definitions
          - \`IdentitySession\`: Session with Guardian oversight
          - \`IdentityGovernanceOrchestrator\`: Framework integration

          ## Usage
          \`\`\`bash
          python examples/identity/governance_example.py
          \`\`\`

          ## Testing
          Example includes 3 scenarios:
          1. Valid session with token validation
          2. Failed attempts with drift detection
          3. Governance reporting for audit

          Related: #798 (Token Infrastructure)" \
            --base main \
            --head $BRANCH
      
      - name: Run Task 4 - WebAuthn Documentation
        if: ${{ github.event.inputs.task == 'all' || github.event.inputs.task == 'task4-webauthn' }}
        run: |
          echo "Creating Task 4: WebAuthn/Passkey Documentation"
          git checkout main
          git pull
          BRANCH="feat/webauthn-passkey-docs"
          git checkout -b $BRANCH
          
          mkdir -p docs/identity
          cat > docs/identity/webauthn-passkey-integration.md << 'EOF'
          # WebAuthn / Passkey Integration Guide
          
          **Status**: Implementation Guide  
          **Date**: 2025-11-01  
          **Context**: Copilot Task 4  
          **Framework**: ‚öõÔ∏è Identity ¬∑ üõ°Ô∏è Guardian ¬∑ üß† Consciousness
          
          ## Overview
          
          This guide details WebAuthn (Web Authentication API) and Passkey integration for the LUKHAS identity system, providing passwordless authentication aligned with the Constellation Framework.
          
          ## Architecture
          
          ```
          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
          ‚îÇ                    LUKHAS Identity System                    ‚îÇ
          ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
          ‚îÇ  ‚öõÔ∏è Identity Layer                                          ‚îÇ
          ‚îÇ  ‚îú‚îÄ ŒªID Token Types (PR #798)                              ‚îÇ
          ‚îÇ  ‚îú‚îÄ WebAuthn Credential Management                         ‚îÇ
          ‚îÇ  ‚îî‚îÄ Passkey Registration & Authentication                  ‚îÇ
          ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
          ‚îÇ  üõ°Ô∏è Guardian Layer                                          ‚îÇ
          ‚îÇ  ‚îú‚îÄ Authenticator Attestation Validation                   ‚îÇ
          ‚îÇ  ‚îú‚îÄ Credential Drift Detection                             ‚îÇ
          ‚îÇ  ‚îî‚îÄ Constitutional AI Policy Enforcement                   ‚îÇ
          ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
          ‚îÇ  üß† Consciousness Layer                                     ‚îÇ
          ‚îÇ  ‚îú‚îÄ Authentication Event Logging                           ‚îÇ
          ‚îÇ  ‚îú‚îÄ Biometric Usage Pattern Analysis                       ‚îÇ
          ‚îÇ  ‚îî‚îÄ Memory Fold Integration                                ‚îÇ
          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ```
          
          ## WebAuthn Concepts
          
          ### Relying Party (RP)
          The LUKHAS API server acting as the authentication service.
          
          **Configuration:**
          ```python
          # lukhas/identity/webauthn_config.py
          WEBAUTHN_CONFIG = {
              "rp_name": "LUKHAS AI Platform",
              "rp_id": "lukhas.ai",  # Must match domain
              "origin": "https://app.lukhas.ai",
              "attestation": "none",  # or "direct" for hardware key validation
              "user_verification": "required",  # Biometric or PIN required
          }
          ```
          
          ### Authenticator
          Hardware (YubiKey, Titan) or platform (TouchID, FaceID, Windows Hello) device.
          
          **Guardian Oversight:**
          - Track authenticator types per user
          - Alert on unusual authenticator changes
          - Enforce minimum authenticator attestation levels
          
          ### Credentials
          Public/private key pairs stored on authenticator (private) and server (public).
          
          **Consciousness Tracking:**
          - Log credential creation/usage patterns
          - Analyze biometric vs hardware key preferences
          - Feed patterns to memory fold system
          
          ## Registration Flow
          
          ### 1. Client Requests Registration Options
          
          ```python
          # lukhas/identity/webauthn_service.py
          from webauthn import generate_registration_options
          from lukhas.identity.token_types import TokenClaims
          
          async def start_webauthn_registration(
              user_id: str,
              token_claims: TokenClaims,
          ) -> dict:
              """
              Generate WebAuthn registration options.
              
              Guardian: Validates user eligibility for passkey registration.
              Consciousness: Logs registration initiation event.
              """
              # Validate token
              if is_token_expired(token_claims):
                  raise IdentityError("Token expired")
              
              # Generate challenge
              options = generate_registration_options(
                  rp_id=WEBAUTHN_CONFIG["rp_id"],
                  rp_name=WEBAUTHN_CONFIG["rp_name"],
                  user_id=user_id.encode(),
                  user_name=token_claims.get("email", user_id),
                  attestation="none",
                  authenticator_selection={
                      "user_verification": "required",
                      "resident_key": "preferred",  # Enable passkeys
                  },
              )
              
              # Store challenge (temporary, 5 min TTL)
              await redis.setex(
                  f"webauthn:challenge:{user_id}",
                  300,
                  options.challenge,
              )
              
              # Consciousness: Log event
              await consciousness_stream.log_event(
                  event_type="webauthn_registration_started",
                  user_id=user_id,
                  metadata={"rp_id": WEBAUTHN_CONFIG["rp_id"]},
              )
              
              return options
          ```
          
          ### 2. Client Creates Credential
          
          ```javascript
          // Frontend JavaScript
          async function registerPasskey(options) {
            try {
              // Browser WebAuthn API
              const credential = await navigator.credentials.create({
                publicKey: options
              });
              
              // Send attestation to server
              const response = await fetch('/api/identity/webauthn/register', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  credential: {
                    id: credential.id,
                    rawId: arrayBufferToBase64(credential.rawId),
                    response: {
                      attestationObject: arrayBufferToBase64(credential.response.attestationObject),
                      clientDataJSON: arrayBufferToBase64(credential.response.clientDataJSON),
                    },
                    type: credential.type,
                  }
                })
              });
              
              return await response.json();
            } catch (error) {
              console.error('Passkey registration failed:', error);
              throw error;
            }
          }
          ```
          
          ### 3. Server Verifies and Stores Credential
          
          ```python
          from webauthn import verify_registration_response
          from lukhas.governance.guardian import GuardianAuditor
          
          async def complete_webauthn_registration(
              user_id: str,
              credential: dict,
          ) -> bool:
              """
              Verify attestation and store credential.
              
              Guardian: Validates attestation, checks for cloned credentials.
              Consciousness: Records successful registration.
              """
              # Retrieve challenge
              challenge = await redis.get(f"webauthn:challenge:{user_id}")
              if not challenge:
                  raise IdentityError("Challenge expired or invalid")
              
              # Verify registration response
              verification = verify_registration_response(
                  credential=credential,
                  expected_challenge=challenge,
                  expected_origin=WEBAUTHN_CONFIG["origin"],
                  expected_rp_id=WEBAUTHN_CONFIG["rp_id"],
              )
              
              # Guardian: Check credential for security issues
              guardian_result = await GuardianAuditor.validate_credential(
                  credential_id=verification.credential_id,
                  public_key=verification.credential_public_key,
                  aaguid=verification.aaguid,
              )
              
              if not guardian_result.is_safe:
                  raise IdentityError(f"Guardian blocked credential: {guardian_result.reason}")
              
              # Store credential
              await db.credentials.insert({
                  "user_id": user_id,
                  "credential_id": verification.credential_id,
                  "public_key": verification.credential_public_key,
                  "sign_count": verification.sign_count,
                  "aaguid": verification.aaguid,
                  "created_at": datetime.utcnow(),
              })
              
              # Consciousness: Log success
              await consciousness_stream.log_event(
                  event_type="webauthn_registration_completed",
                  user_id=user_id,
                  metadata={
                      "credential_id": verification.credential_id.hex(),
                      "aaguid": verification.aaguid.hex(),
                  },
              )
              
              return True
          ```
          
          ## Authentication Flow
          
          ### 1. Client Requests Authentication Options
          
          ```python
          async def start_webauthn_authentication(user_id: str) -> dict:
              """
              Generate WebAuthn authentication challenge.
              
              Guardian: Rate-limits authentication attempts.
              Consciousness: Tracks authentication patterns.
              """
              # Guardian: Check rate limit
              attempts = await redis.incr(f"auth:attempts:{user_id}")
              if attempts > 5:
                  raise IdentityError("Too many authentication attempts")
              
              # Get user's credentials
              credentials = await db.credentials.find({"user_id": user_id})
              
              # Generate authentication options
              options = generate_authentication_options(
                  rp_id=WEBAUTHN_CONFIG["rp_id"],
                  allow_credentials=[
                      {"type": "public-key", "id": cred["credential_id"]}
                      for cred in credentials
                  ],
                  user_verification="required",
              )
              
              # Store challenge
              await redis.setex(
                  f"webauthn:auth_challenge:{user_id}",
                  300,
                  options.challenge,
              )
              
              return options
          ```
          
          ### 2. Client Signs Challenge
          
          ```javascript
          async function authenticateWithPasskey(options) {
            const credential = await navigator.credentials.get({
              publicKey: options
            });
            
            return await fetch('/api/identity/webauthn/authenticate', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                credential: {
                  id: credential.id,
                  rawId: arrayBufferToBase64(credential.rawId),
                  response: {
                    authenticatorData: arrayBufferToBase64(credential.response.authenticatorData),
                    clientDataJSON: arrayBufferToBase64(credential.response.clientDataJSON),
                    signature: arrayBufferToBase64(credential.response.signature),
                    userHandle: arrayBufferToBase64(credential.response.userHandle),
                  },
                  type: credential.type,
                }
              })
            });
          }
          ```
          
          ### 3. Server Verifies Signature and Issues Token
          
          ```python
          from webauthn import verify_authentication_response
          from lukhas.identity.token_types import TokenClaims
          
          async def complete_webauthn_authentication(
              user_id: str,
              credential: dict,
          ) -> TokenClaims:
              """
              Verify authentication and issue ŒªID token.
              
              Guardian: Validates signature, checks sign count for cloning.
              Consciousness: Records successful authentication.
              """
              # Retrieve challenge
              challenge = await redis.get(f"webauthn:auth_challenge:{user_id}")
              if not challenge:
                  raise IdentityError("Challenge expired")
              
              # Get stored credential
              stored_credential = await db.credentials.find_one({
                  "credential_id": bytes.fromhex(credential["id"])
              })
              
              # Verify authentication response
              verification = verify_authentication_response(
                  credential=credential,
                  expected_challenge=challenge,
                  expected_origin=WEBAUTHN_CONFIG["origin"],
                  expected_rp_id=WEBAUTHN_CONFIG["rp_id"],
                  credential_public_key=stored_credential["public_key"],
                  credential_current_sign_count=stored_credential["sign_count"],
              )
              
              # Guardian: Check for credential cloning
              if verification.new_sign_count <= stored_credential["sign_count"]:
                  await GuardianAuditor.alert_credential_cloning(
                      user_id=user_id,
                      credential_id=credential["id"],
                  )
                  raise IdentityError("Potential credential cloning detected")
              
              # Update sign count
              await db.credentials.update_one(
                  {"credential_id": bytes.fromhex(credential["id"])},
                  {"$set": {"sign_count": verification.new_sign_count}},
              )
              
              # Issue ŒªID token
              token_claims: TokenClaims = {
                  "iss": "lukhas-identity",
                  "sub": user_id,
                  "aud": "lukhas-api",
                  "exp": int((datetime.utcnow() + timedelta(hours=8)).timestamp()),
                  "iat": int(datetime.utcnow().timestamp()),
                  "auth_method": "webauthn",
                  "credential_id": credential["id"],
              }
              
              # Consciousness: Log authentication
              await consciousness_stream.log_event(
                  event_type="webauthn_authentication_completed",
                  user_id=user_id,
                  metadata={"credential_id": credential["id"]},
              )
              
              return token_claims
          ```
          
          ## Guardian Integration
          
          ### Drift Detection
          
          ```python
          class WebAuthnGuardian:
              """Guardian monitoring for WebAuthn operations."""
              
              async def detect_unusual_authenticator_change(self, user_id: str) -> bool:
                  """Alert if user changes authenticator frequently."""
                  changes = await db.credential_changes.count({
                      "user_id": user_id,
                      "created_at": {"$gte": datetime.utcnow() - timedelta(days=30)},
                  })
                  
                  if changes > 3:
                      await self.alert(
                          "unusual_authenticator_change",
                          user_id=user_id,
                          changes=changes,
                      )
                      return True
                  return False
              
              async def validate_credential_attestation(self, aaguid: bytes) -> bool:
                  """Check if authenticator is trusted."""
                  # Check against FIDO Metadata Service
                  metadata = await fido_mds_client.get_metadata(aaguid)
                  
                  if metadata.status_reports and any(
                      report.status == "REVOKED" for report in metadata.status_reports
                  ):
                      return False
                  
                  return True
          ```
          
          ## Best Practices
          
          ### 1. Always Require User Verification
          ```python
          authenticator_selection = {
              "user_verification": "required",  # Biometric or PIN
              "resident_key": "preferred",      # Enable passkeys
          }
          ```
          
          ### 2. Implement Credential Backup
          - Allow multiple credentials per user
          - Support both platform (TouchID) and roaming (YubiKey) authenticators
          - Provide recovery flow for lost credentials
          
          ### 3. Monitor Sign Count
          ```python
          if new_sign_count <= current_sign_count:
              # Potential cloning attack
              await guardian.alert_credential_cloning(user_id)
          ```
          
          ### 4. Integration with ŒªID Tokens
          ```python
          # Include WebAuthn metadata in token claims
          token_claims["auth_method"] = "webauthn"
          token_claims["credential_id"] = credential_id
          token_claims["authenticator_type"] = "platform"  # or "roaming"
          ```
          
          ## Dependencies
          
          ```txt
          # requirements.txt additions
          webauthn==2.2.0        # WebAuthn server library
          cryptography>=41.0.0   # Cryptographic operations
          ```
          
          ## Testing
          
          ```bash
          # Unit tests
          pytest tests/unit/identity/test_webauthn_service.py
          
          # Integration tests (requires browser automation)
          pytest tests/integration/identity/test_webauthn_flow.py
          ```
          
          ## References
          
          - [W3C WebAuthn Specification](https://www.w3.org/TR/webauthn-2/)
          - [FIDO Alliance Passkeys](https://fidoalliance.org/passkeys/)
          - [py_webauthn Documentation](https://github.com/duo-labs/py_webauthn)
          - LUKHAS Token Types: `lukhas/identity/token_types.py` (PR #798)
          - LUKHAS Guardian Framework: `ethics/guardian/`
          
          ## Related ADRs
          
          - ADR 0001: OAuth Provider Evaluation (Task 2)
          - ADR 0003: Identity Governance Model (Task 3)
          EOF
          
          git add docs/identity/webauthn-passkey-integration.md
          git commit -m "docs(identity): add WebAuthn/Passkey integration guide

          Problem: Need documentation for passwordless authentication with WebAuthn and Passkeys.
          Solution: Create comprehensive guide covering registration, authentication, Guardian integration, and best practices.
          Impact: Developers can implement WebAuthn following Constellation Framework patterns; documentation-only, no code changes."
          
          git push origin $BRANCH
          
          gh pr create \
            --title "docs(identity): WebAuthn/Passkey integration guide (Task 4)" \
            --body "**Copilot Task 4 Complete**: WebAuthn/Passkey Documentation

          ## Summary
          Comprehensive guide for implementing passwordless authentication with WebAuthn and Passkeys in the LUKHAS identity system.

          ## Coverage
          - **Registration Flow**: Challenge generation, credential creation, verification
          - **Authentication Flow**: Challenge signing, signature verification, token issuance
          - **Guardian Integration**: Drift detection, attestation validation, cloning prevention
          - **Consciousness Logging**: Event tracking for memory fold integration
          - **Best Practices**: User verification, credential backup, sign count monitoring

          ## Architecture
          Aligns with Constellation Framework:
          - ‚öõÔ∏è **Identity**: ŒªID token integration (PR #798)
          - üõ°Ô∏è **Guardian**: Constitutional AI policy enforcement
          - üß† **Consciousness**: Authentication event logging

          ## Implementation Ready
          Includes complete Python code examples for:
          - WebAuthn service layer
          - Guardian monitoring
          - Token issuance integration
          - Frontend JavaScript flows

          Related: #798 (Token Infrastructure), Task 2 (OAuth ADR)" \
            --base main \
            --head $BRANCH
      
      - name: Summary
        if: always()
        run: |
          echo "======================================"
          echo "Copilot Tasks Automation Complete"
          echo "======================================"
          echo ""
          echo "Task Status:"
          echo "  ‚úÖ Task 1: Token Infrastructure (PR #798) - Already merged"
          echo "  ‚úÖ Task 2: OAuth Evaluation ADR - PR created"
          echo "  ‚úÖ Task 3: Governance Example - PR created"
          echo "  ‚úÖ Task 4: WebAuthn Documentation - PR created"
          echo ""
          echo "All PRs have been created and are ready for review."
          echo "Check https://github.com/LukhasAI/Lukhas/pulls for the new PRs."
