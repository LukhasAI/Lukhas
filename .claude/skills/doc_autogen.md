# Documentation Auto-Generation Skill

Automatically generate or update documentation (docstrings, module README sections, and top-level README) using the nearest lukhas_context.md as authoritative context. Produces high-quality docstrings, usage examples, and a readable module README following LUKHΛS style and the user's minimalistic preferences.

## Reasoning

1. Identify source files that lack sufficient docstrings or module-level README in a given directory by scanning for public functions/classes with no or sparse documentation.

2. For each source file, locate the nearest `lukhas_context.md` by walking up directories; treat that file as the canonical context for style, owner, and intended behavior.

3. Use a template that captures purpose, API, examples, owner, and testing notes. Prioritize clarity and maintainability — short, precise docstrings for engineers and a higher-level README for product/context.

4. Follow T4-level inspiration: include design rationale (why this module exists), failure modes, ethical considerations where appropriate (e.g., MATRIZ/consciousness components), and usage examples that a new team member could run in 5–10 minutes.

5. Make generated docs editable and idempotent; include a header comment so future runs recognize autogenerated sections and can update them safely.

## Actions

### Outputs produced:
- `scripts/doc_autogen.py` that scans code, reads lukhas_context.md, and patches files/README.md with generated sections (idempotent).
- Docstring and README templates tailored to LUKHΛS standards.

### Example `scripts/doc_autogen.py` (core logic):

```python
#!/usr/bin/env python3
import os, re, argparse, json
TEMPLATE_HEADER = """# AUTO-GENERATED: LUKHΛS DOC
# Edit only outside the AUTO-GEN block.
"""
def find_nearest_context(start_path):
    p = start_path
    while True:
        cand = os.path.join(p, 'lukhas_context.md')
        if os.path.exists(cand):
            with open(cand,'r',encoding='utf-8') as fh:
                return cand, fh.read()
        parent = os.path.dirname(p)
        if parent == p:
            return None, None
        p = parent

def extract_public_apis(pytext):
    # Very small heuristic: defs and class tops that are public
    apis = []
    for m in re.finditer(r"^(def|class)\s+([A-Za-z0-9_]+)", pytext, re.M):
        name = m.group(2)
        if not name.startswith("_"):
            apis.append(name)
    return apis

def generate_doc_for_file(path, context_text):
    with open(path,'r',encoding='utf-8') as fh: src = fh.read()
    apis = extract_public_apis(src)
    # Construct simple docstring based on context (shortened for brevity)
    doc = f'"""\nModule: {os.path.basename(path)}\n\nPurpose: see lukhas_context.md\n\nPublic API:\n'
    for a in apis: doc += f'- {a}\n'
    doc += '\nExample:\n    # usage example here\n"""'
    # Insert header and replace AUTO-GEN block if present
    if 'AUTO-GENERATED: LUKHΛS DOC' in src:
        src = re.sub(r"# AUTO-GENERATED: LUKHΛS DOC.*?# END AUTO-GEN\n","",src,flags=re.S)
    new_src = f"# AUTO-GENERATED: LUKHΛS DOC\n{doc}\n# END AUTO-GEN\n\n" + src
    return new_src

def main(root='.', apply=False):
    for dirpath, _, files in os.walk(root):
        for f in files:
            if f.endswith('.py') and not f.startswith('test_'):
                p = os.path.join(dirpath,f)
                ctx_path,ctx_text = find_nearest_context(dirpath)
                if not ctx_path:
                    # signal missing context to maintainer
                    print(f'Warning: no lukhas_context.md for {p}')
                    continue
                new = generate_doc_for_file(p, ctx_text)
                if apply:
                    with open(p,'w',encoding='utf-8') as fh: fh.write(new)
                else:
                    print(f'[DRY] Would update {p}')

if __name__ == '__main__':
    import sys
    main('.', apply='--apply' in sys.argv)
```

### Doc style notes (to be embedded in `context_headers.md` and used as defaults):
- Module header: short purpose line + 3–5 sentence rationale.
- Public API section: list functions/classes and one-line summary each.
- Example section: runnable snippet that uses the module's public API.
- Owner & Tests: owner@lukhas and reference to tests directory.

### Run instructions:
- Dry-run: `python3 scripts/doc_autogen.py`
- Apply: `python3 scripts/doc_autogen.py --apply`

### Integration:
Add to CI (see `workflow_enforcer` skill) to run on PRs and fail if new modules lack context or example usage.

## Context References

- `/context_headers.md`
- `/scripts/generate_lukhas_context.sh`
- `/docs/CONTEXT_FILES.md`
- `/scripts/context_coverage_bot.py`
