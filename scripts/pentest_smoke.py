#!/usr/bin/env python3
"""
LUKHAS Security - Penetration Testing Framework
==============================================

Automated penetration testing and security validation framework with T4/0.01% excellence.
Provides comprehensive security testing across all LUKHAS components.

Key Features:
- Automated vulnerability scanning
- Authentication bypass testing
- Authorization escalation tests
- Input validation testing
- API security testing
- Network security assessment
- Guardian system testing
- Compliance validation
- Performance benchmarking

Constellation Framework: üõ°Ô∏è Guardian Excellence - Security Validation
"""

import concurrent.futures
import json
import logging
import os
import sys
import time
from dataclasses import dataclass, field
from datetime import datetime, timezone
from enum import Enum
from typing import Any, Dict, List, Optional
from urllib.parse import urljoin

import requests
import urllib3

# Suppress SSL warnings for testing
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

logger = logging.getLogger(__name__)


class TestSeverity(Enum):
    """Test result severity levels."""

    INFO = "info"
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class TestCategory(Enum):
    """Security test categories."""

    AUTHENTICATION = "authentication"
    AUTHORIZATION = "authorization"
    INPUT_VALIDATION = "input_validation"
    INJECTION = "injection"
    CRYPTOGRAPHY = "cryptography"
    SESSION_MANAGEMENT = "session_management"
    CONFIGURATION = "configuration"
    NETWORK = "network"
    API_SECURITY = "api_security"
    GUARDIAN = "guardian"


@dataclass
class TestResult:
    """Individual test result."""

    test_id: str
    name: str
    category: TestCategory
    severity: TestSeverity
    status: str  # PASS, FAIL, SKIP, ERROR
    description: str
    details: str = ""
    evidence: Dict[str, Any] = field(default_factory=dict)
    remediation: str = ""
    execution_time_ms: float = 0.0
    timestamp: datetime = field(default_factory=lambda: datetime.now(timezone.utc))


@dataclass
class TestSuite:
    """Test suite configuration."""

    name: str
    description: str
    tests: List[str] = field(default_factory=list)
    target_url: Optional[str] = None
    credentials: Optional[Dict[str, str]] = None
    headers: Dict[str, str] = field(default_factory=dict)
    timeout: int = 30
    parallel: bool = True


@dataclass
class PenTestReport:
    """Penetration test report."""

    test_run_id: str
    start_time: datetime
    end_time: Optional[datetime] = None
    target_info: Dict[str, Any] = field(default_factory=dict)
    test_results: List[TestResult] = field(default_factory=list)
    summary: Dict[str, Any] = field(default_factory=dict)
    recommendations: List[str] = field(default_factory=list)


class SecurityTester:
    """Base class for security tests."""

    def __init__(self, name: str, category: TestCategory, description: str):
        self.name = name
        self.category = category
        self.description = description

    def run(self, target: str, context: Dict[str, Any]) -> TestResult:
        """Run security test."""
        start_time = time.perf_counter()

        try:
            result = self.execute_test(target, context)
        except Exception as e:
            result = TestResult(
                test_id=self.name.lower().replace(" ", "_"),
                name=self.name,
                category=self.category,
                severity=TestSeverity.HIGH,
                status="ERROR",
                description=self.description,
                details=f"Test execution error: {str(e)}",
            )

        result.execution_time_ms = (time.perf_counter() - start_time) * 1000
        return result

    def execute_test(self, target: str, context: Dict[str, Any]) -> TestResult:
        """Execute the actual test - to be implemented by subclasses."""
        raise NotImplementedError


class SQLInjectionTester(SecurityTester):
    """Test for SQL injection vulnerabilities."""

    def __init__(self):
        super().__init__("SQL Injection Test", TestCategory.INJECTION, "Test for SQL injection vulnerabilities")
        self.payloads = [
            "' OR '1'='1",
            "' OR '1'='1' --",
            "' OR '1'='1' /*",
            "admin'--",
            "admin'/*",
            "' UNION SELECT NULL--",
            "' UNION SELECT 1,2,3--",
            "'; DROP TABLE users; --",
            "1' AND (SELECT COUNT(*) FROM users) > 0 --",
        ]

    def execute_test(self, target: str, context: Dict[str, Any]) -> TestResult:
        vulnerabilities_found = []

        session = requests.Session()
        session.verify = False
        session.timeout = 30

        # Test common endpoints
        test_endpoints = ["/api/auth/login", "/api/users/search", "/api/data/query", "/login", "/search"]

        for endpoint in test_endpoints:
            url = urljoin(target, endpoint)

            for payload in self.payloads:
                try:
                    # Test GET parameters
                    response = session.get(url, params={"q": payload, "id": payload})
                    if self._detect_sql_error(response.text):
                        vulnerabilities_found.append(
                            {
                                "endpoint": endpoint,
                                "method": "GET",
                                "payload": payload,
                                "response_snippet": response.text[:200],
                            }
                        )

                    # Test POST data
                    response = session.post(url, data={"username": payload, "password": payload})
                    if self._detect_sql_error(response.text):
                        vulnerabilities_found.append(
                            {
                                "endpoint": endpoint,
                                "method": "POST",
                                "payload": payload,
                                "response_snippet": response.text[:200],
                            }
                        )

                except Exception:
                    continue

        if vulnerabilities_found:
            return TestResult(
                test_id="sql_injection",
                name=self.name,
                category=self.category,
                severity=TestSeverity.CRITICAL,
                status="FAIL",
                description=self.description,
                details=f"Found {len(vulnerabilities_found)} potential SQL injection vulnerabilities",
                evidence={"vulnerabilities": vulnerabilities_found},
                remediation="Use parameterized queries and input validation",
            )
        else:
            return TestResult(
                test_id="sql_injection",
                name=self.name,
                category=self.category,
                severity=TestSeverity.INFO,
                status="PASS",
                description=self.description,
                details="No SQL injection vulnerabilities detected",
            )

    def _detect_sql_error(self, response_text: str) -> bool:
        """Detect SQL error messages in response."""
        sql_errors = [
            "sql syntax",
            "mysql_fetch",
            "ora-",
            "microsoft ole db",
            "postgresql error",
            "sqlite_",
            "sybase message",
            "db2 sql error",
            "unknown column",
            "table doesn't exist",
            "duplicate entry",
        ]

        response_lower = response_text.lower()
        return any(error in response_lower for error in sql_errors)


class XSSTester(SecurityTester):
    """Test for Cross-Site Scripting vulnerabilities."""

    def __init__(self):
        super().__init__("XSS Test", TestCategory.INJECTION, "Test for XSS vulnerabilities")
        self.payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "javascript:alert('XSS')",
            "<svg onload=alert('XSS')>",
            "'\"><script>alert('XSS')</script>",
            "<iframe src=javascript:alert('XSS')>",
            "<body onload=alert('XSS')>",
            "<input onfocus=alert('XSS') autofocus>",
            "<select onfocus=alert('XSS') autofocus>",
            "<textarea onfocus=alert('XSS') autofocus>",
        ]

    def execute_test(self, target: str, context: Dict[str, Any]) -> TestResult:
        vulnerabilities_found = []

        session = requests.Session()
        session.verify = False
        session.timeout = 30

        # Test common endpoints
        test_endpoints = ["/api/users/profile", "/api/posts/create", "/api/comments/add", "/search", "/profile"]

        for endpoint in test_endpoints:
            url = urljoin(target, endpoint)

            for payload in self.payloads:
                try:
                    # Test reflected XSS
                    response = session.get(url, params={"q": payload, "message": payload})
                    if payload in response.text:
                        vulnerabilities_found.append(
                            {"endpoint": endpoint, "type": "reflected", "payload": payload, "method": "GET"}
                        )

                    # Test stored XSS via POST
                    response = session.post(url, data={"content": payload, "comment": payload})
                    # Check if payload might be stored (status codes indicating success)
                    if response.status_code in [200, 201, 204]:
                        # Follow up with GET to check if stored
                        check_response = session.get(url)
                        if payload in check_response.text:
                            vulnerabilities_found.append(
                                {"endpoint": endpoint, "type": "stored", "payload": payload, "method": "POST"}
                            )

                except Exception:
                    continue

        if vulnerabilities_found:
            return TestResult(
                test_id="xss_test",
                name=self.name,
                category=self.category,
                severity=TestSeverity.HIGH,
                status="FAIL",
                description=self.description,
                details=f"Found {len(vulnerabilities_found)} potential XSS vulnerabilities",
                evidence={"vulnerabilities": vulnerabilities_found},
                remediation="Implement proper input validation and output encoding",
            )
        else:
            return TestResult(
                test_id="xss_test",
                name=self.name,
                category=self.category,
                severity=TestSeverity.INFO,
                status="PASS",
                description=self.description,
                details="No XSS vulnerabilities detected",
            )


class AuthenticationBypassTester(SecurityTester):
    """Test for authentication bypass vulnerabilities."""

    def __init__(self):
        super().__init__(
            "Authentication Bypass Test", TestCategory.AUTHENTICATION, "Test for authentication bypass vulnerabilities"
        )

    def execute_test(self, target: str, context: Dict[str, Any]) -> TestResult:
        vulnerabilities_found = []

        session = requests.Session()
        session.verify = False
        session.timeout = 30

        # Test common authentication endpoints
        auth_endpoints = ["/api/auth/login", "/api/auth/verify", "/login", "/authenticate"]

        bypass_tests = [
            # SQL injection authentication bypass
            {"username": "admin'--", "password": "anything"},
            {"username": "admin' OR '1'='1'--", "password": ""},
            {"username": "' OR '1'='1", "password": "' OR '1'='1"},
            # NoSQL injection
            {"username": {"$ne": None}, "password": {"$ne": None}},
            {"username": {"$regex": ".*"}, "password": {"$regex": ".*"}},
            # Common default credentials
            {"username": "admin", "password": "admin"},
            {"username": "admin", "password": "password"},
            {"username": "admin", "password": "123456"},
            {"username": "root", "password": "root"},
            {"username": "test", "password": "test"},
            # Empty/null bypass attempts
            {"username": "", "password": ""},
            {"username": None, "password": None},
        ]

        for endpoint in auth_endpoints:
            url = urljoin(target, endpoint)

            for test_data in bypass_tests:
                try:
                    response = session.post(url, json=test_data)

                    # Check for successful authentication indicators
                    if self._is_auth_success(response):
                        vulnerabilities_found.append(
                            {
                                "endpoint": endpoint,
                                "test_data": str(test_data),
                                "status_code": response.status_code,
                                "response_size": len(response.text),
                            }
                        )

                except Exception:
                    continue

        # Test JWT manipulation
        jwt_vulns = self._test_jwt_vulnerabilities(target, context)
        vulnerabilities_found.extend(jwt_vulns)

        if vulnerabilities_found:
            severity = TestSeverity.CRITICAL if len(vulnerabilities_found) > 2 else TestSeverity.HIGH
            return TestResult(
                test_id="auth_bypass",
                name=self.name,
                category=self.category,
                severity=severity,
                status="FAIL",
                description=self.description,
                details=f"Found {len(vulnerabilities_found)} authentication bypass vulnerabilities",
                evidence={"vulnerabilities": vulnerabilities_found},
                remediation="Implement proper authentication validation and rate limiting",
            )
        else:
            return TestResult(
                test_id="auth_bypass",
                name=self.name,
                category=self.category,
                severity=TestSeverity.INFO,
                status="PASS",
                description=self.description,
                details="No authentication bypass vulnerabilities detected",
            )

    def _is_auth_success(self, response: requests.Response) -> bool:
        """Check if response indicates successful authentication."""
        # Common success indicators
        success_indicators = [
            response.status_code == 200,
            "token" in response.text.lower(),
            "success" in response.text.lower(),
            "welcome" in response.text.lower(),
            "dashboard" in response.text.lower(),
            len(response.text) > 500,  # Successful auth usually returns more content
        ]

        return any(success_indicators)

    def _test_jwt_vulnerabilities(self, target: str, context: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Test for JWT-related vulnerabilities."""
        vulnerabilities = []

        # Mock JWT for testing
        mock_jwt_header = {"alg": "HS256", "typ": "JWT"}
        mock_jwt_payload = {"sub": "admin", "iat": int(time.time()), "exp": int(time.time()) + 3600}

        # Test algorithm confusion (HS256 -> RS256)
        try:
            import base64
            import json

            header_b64 = base64.urlsafe_b64encode(json.dumps(mock_jwt_header).encode()).decode().rstrip("=")
            payload_b64 = base64.urlsafe_b64encode(json.dumps(mock_jwt_payload).encode()).decode().rstrip("=")

            # Test with no signature
            malicious_jwt = f"{header_b64}.{payload_b64}."

            # Test with various endpoints
            test_endpoints = ["/api/protected", "/api/admin", "/dashboard"]

            session = requests.Session()
            session.verify = False

            for endpoint in test_endpoints:
                url = urljoin(target, endpoint)
                headers = {"Authorization": f"Bearer {malicious_jwt}"}

                try:
                    response = session.get(url, headers=headers)
                    if response.status_code == 200:
                        vulnerabilities.append({"type": "jwt_no_signature", "endpoint": endpoint, "jwt": malicious_jwt})
                except Exception as e:
                    continue

        except Exception:
            pass  # JWT testing optional

        return vulnerabilities


class PrivilegeEscalationTester(SecurityTester):
    """Test for privilege escalation vulnerabilities."""

    def __init__(self):
        super().__init__(
            "Privilege Escalation Test", TestCategory.AUTHORIZATION, "Test for privilege escalation vulnerabilities"
        )

    def execute_test(self, target: str, context: Dict[str, Any]) -> TestResult:
        vulnerabilities_found = []

        session = requests.Session()
        session.verify = False
        session.timeout = 30

        # Test endpoints that might have privilege escalation issues
        test_cases = [
            # Parameter tampering
            {"endpoint": "/api/users/profile", "params": {"user_id": "1"}},  # Try to access admin
            {"endpoint": "/api/users/profile", "params": {"user_id": "admin"}},
            {"endpoint": "/api/admin/users", "params": {}},  # Direct admin access
            # Role manipulation
            {"endpoint": "/api/users/update", "data": {"role": "admin"}},
            {"endpoint": "/api/users/update", "data": {"permissions": ["admin", "read", "write"]}},
            # Path traversal in APIs
            {"endpoint": "/api/files/../../admin/config", "params": {}},
            {"endpoint": "/api/data/../../../etc/passwd", "params": {}},
        ]

        for test_case in test_cases:
            url = urljoin(target, test_case["endpoint"])

            try:
                # Test GET request
                response = session.get(url, params=test_case.get("params", {}))
                if self._is_privilege_escalation(response):
                    vulnerabilities_found.append(
                        {
                            "endpoint": test_case["endpoint"],
                            "method": "GET",
                            "params": test_case.get("params", {}),
                            "status_code": response.status_code,
                        }
                    )

                # Test POST request if data provided
                if "data" in test_case:
                    response = session.post(url, json=test_case["data"])
                    if self._is_privilege_escalation(response):
                        vulnerabilities_found.append(
                            {
                                "endpoint": test_case["endpoint"],
                                "method": "POST",
                                "data": test_case["data"],
                                "status_code": response.status_code,
                            }
                        )

            except Exception:
                continue

        # Test horizontal privilege escalation
        horizontal_vulns = self._test_horizontal_escalation(target)
        vulnerabilities_found.extend(horizontal_vulns)

        if vulnerabilities_found:
            return TestResult(
                test_id="privilege_escalation",
                name=self.name,
                category=self.category,
                severity=TestSeverity.HIGH,
                status="FAIL",
                description=self.description,
                details=f"Found {len(vulnerabilities_found)} privilege escalation vulnerabilities",
                evidence={"vulnerabilities": vulnerabilities_found},
                remediation="Implement proper access control and authorization checks",
            )
        else:
            return TestResult(
                test_id="privilege_escalation",
                name=self.name,
                category=self.category,
                severity=TestSeverity.INFO,
                status="PASS",
                description=self.description,
                details="No privilege escalation vulnerabilities detected",
            )

    def _is_privilege_escalation(self, response: requests.Response) -> bool:
        """Check if response indicates privilege escalation."""
        escalation_indicators = [
            "admin" in response.text.lower(),
            "root" in response.text.lower(),
            "password" in response.text.lower(),
            "config" in response.text.lower(),
            response.status_code == 200,
            len(response.text) > 100,  # Got some content back
        ]

        return any(escalation_indicators) and response.status_code != 403

    def _test_horizontal_escalation(self, target: str) -> List[Dict[str, Any]]:
        """Test for horizontal privilege escalation (access other users' data)."""
        vulnerabilities = []

        session = requests.Session()
        session.verify = False

        # Test user ID manipulation
        user_endpoints = ["/api/users/{}/profile", "/api/users/{}/data", "/api/accounts/{}", "/profile?user_id={}"]

        test_user_ids = ["1", "2", "admin", "0", "-1", "999999"]

        for endpoint_template in user_endpoints:
            for user_id in test_user_ids:
                endpoint = endpoint_template.format(user_id)
                url = urljoin(target, endpoint)

                try:
                    response = session.get(url)
                    if response.status_code == 200 and len(response.text) > 50:
                        vulnerabilities.append(
                            {
                                "type": "horizontal_escalation",
                                "endpoint": endpoint,
                                "user_id": user_id,
                                "status_code": response.status_code,
                            }
                        )
                except Exception as e:
                    continue

        return vulnerabilities


class GuardianTester(SecurityTester):
    """Test Guardian system security controls."""

    def __init__(self):
        super().__init__("Guardian System Test", TestCategory.GUARDIAN, "Test Guardian system security controls")

    def execute_test(self, target: str, context: Dict[str, Any]) -> TestResult:
        test_results = []

        # Test Guardian bypass attempts
        bypass_attempts = [
            # Direct Guardian endpoint access
            {"endpoint": "/api/guardian/override", "method": "POST"},
            {"endpoint": "/api/guardian/disable", "method": "POST"},
            {"endpoint": "/api/guardian/status", "method": "GET"},
            # Guardian configuration tampering
            {"endpoint": "/api/config/guardian", "method": "PUT", "data": {"enabled": False}},
            {"endpoint": "/api/settings/security", "method": "POST", "data": {"guardian_active": False}},
        ]

        session = requests.Session()
        session.verify = False

        guardian_accessible = False
        bypass_possible = False

        for attempt in bypass_attempts:
            url = urljoin(target, attempt["endpoint"])

            try:
                if attempt["method"] == "GET":
                    response = session.get(url)
                elif attempt["method"] == "POST":
                    response = session.post(url, json=attempt.get("data", {}))
                elif attempt["method"] == "PUT":
                    response = session.put(url, json=attempt.get("data", {}))
                else:
                    continue

                # Check if Guardian endpoints are accessible
                if response.status_code in [200, 201, 204]:
                    guardian_accessible = True
                    test_results.append(
                        {
                            "endpoint": attempt["endpoint"],
                            "method": attempt["method"],
                            "status_code": response.status_code,
                            "accessible": True,
                        }
                    )

                # Check for bypass indicators
                if "guardian" in response.text.lower() and "disabled" in response.text.lower():
                    bypass_possible = True

            except Exception:
                continue

        # Test Guardian decision tampering
        decision_tampering = self._test_guardian_decision_tampering(target)
        if decision_tampering:
            bypass_possible = True
            test_results.extend(decision_tampering)

        if bypass_possible:
            return TestResult(
                test_id="guardian_test",
                name=self.name,
                category=self.category,
                severity=TestSeverity.CRITICAL,
                status="FAIL",
                description=self.description,
                details="Guardian system bypass or tampering possible",
                evidence={"test_results": test_results},
                remediation="Secure Guardian endpoints and validate decision integrity",
            )
        elif guardian_accessible:
            return TestResult(
                test_id="guardian_test",
                name=self.name,
                category=self.category,
                severity=TestSeverity.MEDIUM,
                status="FAIL",
                description=self.description,
                details="Guardian system endpoints are accessible",
                evidence={"test_results": test_results},
                remediation="Restrict access to Guardian system endpoints",
            )
        else:
            return TestResult(
                test_id="guardian_test",
                name=self.name,
                category=self.category,
                severity=TestSeverity.INFO,
                status="PASS",
                description=self.description,
                details="Guardian system appears properly secured",
            )

    def _test_guardian_decision_tampering(self, target: str) -> List[Dict[str, Any]]:
        """Test for Guardian decision tampering vulnerabilities."""
        vulnerabilities = []

        # Test decision replay attacks
        decision_endpoints = ["/api/guardian/decide", "/api/security/validate", "/api/auth/check"]

        session = requests.Session()
        session.verify = False

        for endpoint in decision_endpoints:
            url = urljoin(target, endpoint)

            # Try to replay a decision
            mock_decision = {
                "decision": "allow",
                "user_id": "admin",
                "action": "admin_access",
                "timestamp": int(time.time()) - 3600,  # Old timestamp
            }

            try:
                response = session.post(url, json=mock_decision)
                if response.status_code == 200:
                    vulnerabilities.append(
                        {"type": "decision_replay", "endpoint": endpoint, "tampered_decision": mock_decision}
                    )
            except Exception as e:
                continue

        return vulnerabilities


class PenetrationTestFramework:
    """Comprehensive penetration testing framework."""

    def __init__(
        self, target_url: str, output_dir: str = "./pentest_results", parallel_tests: bool = True, max_workers: int = 10
    ):

        self.target_url = target_url.rstrip("/")
        self.output_dir = output_dir
        self.parallel_tests = parallel_tests
        self.max_workers = max_workers

        # Initialize test suite
        self.testers = [
            SQLInjectionTester(),
            XSSTester(),
            AuthenticationBypassTester(),
            PrivilegeEscalationTester(),
            GuardianTester(),
        ]

        # Ensure output directory exists
        os.makedirs(output_dir, exist_ok=True)

        logger.info(f"Initialized penetration testing framework for {target_url}")

    def run_tests(self, test_suite: Optional[TestSuite] = None) -> PenTestReport:
        """Run penetration tests."""
        start_time = datetime.now(timezone.utc)
        test_run_id = f"pentest_{int(start_time.timestamp())}"

        logger.info(f"Starting penetration test run: {test_run_id}")

        # Create report
        report = PenTestReport(
            test_run_id=test_run_id,
            start_time=start_time,
            target_info={"url": self.target_url, "test_suite": test_suite.name if test_suite else "default"},
        )

        # Prepare context
        context = {"target_url": self.target_url, "test_suite": test_suite, "session": requests.Session()}

        # Run tests
        if self.parallel_tests:
            results = self._run_tests_parallel(context)
        else:
            results = self._run_tests_sequential(context)

        report.test_results = results
        report.end_time = datetime.now(timezone.utc)

        # Generate summary
        report.summary = self._generate_summary(results)
        report.recommendations = self._generate_recommendations(results)

        # Save report
        self._save_report(report)

        logger.info(f"Penetration test completed: {len(results)} tests run")
        return report

    def _run_tests_sequential(self, context: Dict[str, Any]) -> List[TestResult]:
        """Run tests sequentially."""
        results = []

        for tester in self.testers:
            logger.info(f"Running test: {tester.name}")
            result = tester.run(self.target_url, context)
            results.append(result)

            # Log result
            status_color = "‚úì" if result.status == "PASS" else "‚úó"
            logger.info(f"{status_color} {tester.name}: {result.status} ({result.execution_time_ms:.1f}ms)")

        return results

    def _run_tests_parallel(self, context: Dict[str, Any]) -> List[TestResult]:
        """Run tests in parallel."""
        results = []

        with concurrent.futures.ThreadPoolExecutor(max_workers=self.max_workers) as executor:
            # Submit all tests
            future_to_tester = {
                executor.submit(tester.run, self.target_url, context): tester for tester in self.testers
            }

            # Collect results
            for future in concurrent.futures.as_completed(future_to_tester):
                tester = future_to_tester[future]
                try:
                    result = future.result()
                    results.append(result)

                    status_color = "‚úì" if result.status == "PASS" else "‚úó"
                    logger.info(f"{status_color} {tester.name}: {result.status} ({result.execution_time_ms:.1f}ms)")

                except Exception as e:
                    logger.error(f"Test {tester.name} failed with exception: {e}")

        return sorted(results, key=lambda r: r.timestamp)

    def _generate_summary(self, results: List[TestResult]) -> Dict[str, Any]:
        """Generate test summary."""
        summary = {
            "total_tests": len(results),
            "passed": len([r for r in results if r.status == "PASS"]),
            "failed": len([r for r in results if r.status == "FAIL"]),
            "errors": len([r for r in results if r.status == "ERROR"]),
            "skipped": len([r for r in results if r.status == "SKIP"]),
            "severity_breakdown": {},
            "category_breakdown": {},
            "avg_execution_time_ms": sum(r.execution_time_ms for r in results) / len(results) if results else 0,
        }

        # Severity breakdown
        for severity in TestSeverity:
            summary["severity_breakdown"][severity.value] = len([r for r in results if r.severity == severity])

        # Category breakdown
        for category in TestCategory:
            summary["category_breakdown"][category.value] = len([r for r in results if r.category == category])

        return summary

    def _generate_recommendations(self, results: List[TestResult]) -> List[str]:
        """Generate security recommendations."""
        recommendations = []

        # High/Critical findings
        critical_findings = [r for r in results if r.severity == TestSeverity.CRITICAL and r.status == "FAIL"]
        high_findings = [r for r in results if r.severity == TestSeverity.HIGH and r.status == "FAIL"]

        if critical_findings:
            recommendations.append("‚ö†Ô∏è CRITICAL: Address critical security vulnerabilities immediately")

        if high_findings:
            recommendations.append("üìã HIGH: Prioritize fixing high-severity vulnerabilities")

        # Specific recommendations
        failed_categories = set(r.category for r in results if r.status == "FAIL")

        if TestCategory.INJECTION in failed_categories:
            recommendations.append("üõ°Ô∏è Implement comprehensive input validation and parameterized queries")

        if TestCategory.AUTHENTICATION in failed_categories:
            recommendations.append("üîê Strengthen authentication mechanisms and implement rate limiting")

        if TestCategory.AUTHORIZATION in failed_categories:
            recommendations.append("üîë Review and strengthen access control mechanisms")

        if TestCategory.GUARDIAN in failed_categories:
            recommendations.append("‚ö° Secure Guardian system endpoints and validate decision integrity")

        # General recommendations
        recommendations.extend(
            [
                "üìä Conduct regular security assessments",
                "üîÑ Implement automated security testing in CI/CD pipeline",
                "üìö Provide security training for development team",
                "üìã Establish incident response procedures",
            ]
        )

        return recommendations

    def _save_report(self, report: PenTestReport):
        """Save penetration test report."""
        # JSON report
        json_file = os.path.join(self.output_dir, f"{report.test_run_id}.json")
        with open(json_file, "w") as f:
            json.dump(self._report_to_dict(report), f, indent=2, default=str)

        # HTML report
        html_file = os.path.join(self.output_dir, f"{report.test_run_id}.html")
        self._generate_html_report(report, html_file)

        logger.info(f"Reports saved: {json_file}, {html_file}")

    def _report_to_dict(self, report: PenTestReport) -> Dict[str, Any]:
        """Convert report to dictionary."""
        return {
            "test_run_id": report.test_run_id,
            "start_time": report.start_time.isoformat(),
            "end_time": report.end_time.isoformat() if report.end_time else None,
            "target_info": report.target_info,
            "summary": report.summary,
            "recommendations": report.recommendations,
            "test_results": [
                {
                    "test_id": r.test_id,
                    "name": r.name,
                    "category": r.category.value,
                    "severity": r.severity.value,
                    "status": r.status,
                    "description": r.description,
                    "details": r.details,
                    "evidence": r.evidence,
                    "remediation": r.remediation,
                    "execution_time_ms": r.execution_time_ms,
                    "timestamp": r.timestamp.isoformat(),
                }
                for r in report.test_results
            ],
        }

    def _generate_html_report(self, report: PenTestReport, html_file: str):
        """Generate HTML report."""
        html_content = f"""
<!DOCTYPE html>
<html>
<head>
    <title>LUKHAS Penetration Test Report - {report.test_run_id}</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 40px; }}
        .header {{ background: #2c3e50; color: white; padding: 20px; margin: -40px -40px 20px -40px; }}
        .summary {{ background: #ecf0f1; padding: 15px; margin: 20px 0; border-radius: 5px; }}
        .test-result {{ margin: 20px 0; padding: 15px; border-left: 4px solid #bdc3c7; }}
        .test-pass {{ border-left-color: #27ae60; }}
        .test-fail {{ border-left-color: #e74c3c; }}
        .test-error {{ border-left-color: #f39c12; }}
        .severity-critical {{ color: #e74c3c; font-weight: bold; }}
        .severity-high {{ color: #e67e22; font-weight: bold; }}
        .severity-medium {{ color: #f39c12; }}
        .severity-low {{ color: #3498db; }}
        .severity-info {{ color: #7f8c8d; }}
    </style>
</head>
<body>
    <div class="header">
        <h1>üõ°Ô∏è LUKHAS Penetration Test Report</h1>
        <p>Test Run: {report.test_run_id}</p>
        <p>Target: {report.target_info.get('url', 'N/A')}</p>
        <p>Date: {report.start_time.strftime('%Y-%m-%d %H:%M:%S UTC')}</p>
    </div>

    <div class="summary">
        <h2>üìä Summary</h2>
        <p><strong>Total Tests:</strong> {report.summary['total_tests']}</p>
        <p><strong>Passed:</strong> {report.summary['passed']} |
           <strong>Failed:</strong> {report.summary['failed']} |
           <strong>Errors:</strong> {report.summary['errors']}</p>
        <p><strong>Average Execution Time:</strong> {report.summary['avg_execution_time_ms']:.1f}ms</p>
    </div>

    <div class="recommendations">
        <h2>üìã Recommendations</h2>
        <ul>
"""
        for rec in report.recommendations:
            html_content += f"<li>{rec}</li>\n"

        html_content += """
        </ul>
    </div>

    <div class="test-results">
        <h2>üß™ Test Results</h2>
"""

        for result in report.test_results:
            status_class = f"test-{result.status.lower()}"
            severity_class = f"severity-{result.severity.value}"

            html_content += f"""
        <div class="test-result {status_class}">
            <h3>{result.name} <span class="{severity_class}">({result.severity.value.upper()})</span></h3>
            <p><strong>Status:</strong> {result.status}</p>
            <p><strong>Category:</strong> {result.category.value}</p>
            <p><strong>Description:</strong> {result.description}</p>
            <p><strong>Details:</strong> {result.details}</p>
            <p><strong>Execution Time:</strong> {result.execution_time_ms:.1f}ms</p>
            {f'<p><strong>Remediation:</strong> {result.remediation}</p>' if result.remediation else ''}
        </div>
"""

        html_content += """
    </div>
</body>
</html>
"""

        with open(html_file, "w") as f:
            f.write(html_content)


def main():
    """Main function for command-line usage."""
    import argparse

    parser = argparse.ArgumentParser(description="LUKHAS Penetration Testing Framework")
    parser.add_argument("target", help="Target URL to test")
    parser.add_argument("--output", "-o", default="./pentest_results", help="Output directory for reports")
    parser.add_argument("--parallel", action="store_true", default=True, help="Run tests in parallel")
    parser.add_argument("--workers", type=int, default=10, help="Number of parallel workers")
    parser.add_argument("--verbose", "-v", action="store_true", help="Verbose output")

    args = parser.parse_args()

    # Setup logging
    log_level = logging.DEBUG if args.verbose else logging.INFO
    logging.basicConfig(level=log_level, format="%(asctime)s - %(levelname)s - %(message)s")

    # Run penetration tests
    framework = PenetrationTestFramework(
        target_url=args.target, output_dir=args.output, parallel_tests=args.parallel, max_workers=args.workers
    )

    try:
        report = framework.run_tests()

        print(f"\nüéØ Penetration Test Results for {args.target}")
        print("=" * 60)
        print(f"üìä Total Tests: {report.summary['total_tests']}")
        print(f"‚úÖ Passed: {report.summary['passed']}")
        print(f"‚ùå Failed: {report.summary['failed']}")
        print(f"‚ö†Ô∏è  Errors: {report.summary['errors']}")
        print(f"‚è±Ô∏è  Avg Time: {report.summary['avg_execution_time_ms']:.1f}ms")

        # Show critical/high severity results
        critical_high = [
            r
            for r in report.test_results
            if r.severity in [TestSeverity.CRITICAL, TestSeverity.HIGH] and r.status == "FAIL"
        ]

        if critical_high:
            print("\nüö® Critical/High Severity Issues Found:")
            for result in critical_high:
                print(f"  - {result.name}: {result.details}")

        print(f"\nüìÑ Reports saved to: {args.output}")

    except KeyboardInterrupt:
        print("\n‚ö†Ô∏è  Test interrupted by user")
        sys.exit(1)
    except Exception as e:
        print(f"\n‚ùå Test failed: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
