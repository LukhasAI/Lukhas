#!/usr/bin/env python3
"""
LUKHAS Documentation Generation Tool

Generates SITE_MAP.md and refreshes canonical indices.
"""

import json
from collections import defaultdict
from pathlib import Path
from typing import Dict, List

# Constants
DOCS_ROOT = Path(__file__).parent.parent / "docs"
INVENTORY_DIR = DOCS_ROOT / "_inventory"
MANIFEST_PATH = INVENTORY_DIR / "docs_manifest.json"
OUTPUT_DIR = DOCS_ROOT / "_generated"
SITEMAP_PATH = OUTPUT_DIR / "SITE_MAP.md"


def load_manifest() -> Dict:
    """Load the documentation manifest."""
    with open(MANIFEST_PATH, 'r', encoding='utf-8') as f:
        return json.load(f)


def build_directory_tree(docs: List[Dict]) -> Dict:
    """Build hierarchical directory tree from document list."""
    tree = {}

    for doc in docs:
        # Skip redirect stubs
        if doc.get('redirect'):
            continue

        # Parse path
        path = Path(doc['path'])
        parts = path.parts[1:]  # Skip 'docs'

        # Build tree
        current = tree
        for part in parts[:-1]:  # All but the file
            if part not in current:
                current[part] = {}
            current = current[part]

        # Add file
        filename = parts[-1] if parts else path.name
        if '_files' not in current:
            current['_files'] = []
        current['_files'].append({
            'name': filename,
            'title': doc['title'],
            'path': doc['path'],
            'type': doc['type'],
            'status': doc['status'],
        })

    return tree


def render_tree(tree: Dict, indent: int = 0, path_prefix: str = "") -> List[str]:
    """Render directory tree as markdown list."""
    lines = []
    indent_str = "  " * indent

    # Sort directories first, then files
    dirs = sorted([k for k in tree.keys() if k != '_files'])
    files = tree.get('_files', [])

    # Render directories
    for dir_name in dirs:
        lines.append(f"{indent_str}- **{dir_name}/**")
        subpath = f"{path_prefix}/{dir_name}" if path_prefix else dir_name
        lines.extend(render_tree(tree[dir_name], indent + 1, subpath))

    # Render files
    for file_info in sorted(files, key=lambda f: f['name']):
        rel_path = file_info['path'].replace('docs/', '')
        title = file_info['title']
        doc_type = file_info['type']
        status = file_info['status']

        # Add status badge
        badge = ""
        if status == 'wip':
            badge = " üöß"
        elif status == 'deprecated':
            badge = " ‚ö†Ô∏è"

        lines.append(f"{indent_str}- [{title}]({rel_path}){badge} `{doc_type}`")

    return lines


def generate_site_map(manifest: Dict):
    """Generate SITE_MAP.md."""
    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)

    docs = manifest['documents']
    tree = build_directory_tree(docs)

    content = [
        "# LUKHAS Documentation Site Map",
        "",
        f"**Generated:** {manifest['generated_at']}",
        f"**Total Documents:** {manifest['total_documents']}",
        "",
        "This is an automatically generated hierarchical view of all documentation.",
        "",
        "## Legend",
        "",
        "- üöß = Work in Progress",
        "- ‚ö†Ô∏è = Deprecated",
        "- `type` = Document classification",
        "",
        "## Documentation Tree",
        "",
    ]

    content.extend(render_tree(tree))

    content.append("")
    content.append("---")
    content.append("")
    content.append("*This file is automatically generated. Do not edit manually.*")
    content.append(f"*Run `python3 scripts/docs_generate.py` to regenerate.*")
    content.append("")

    with open(SITEMAP_PATH, 'w', encoding='utf-8') as f:
        f.write('\n'.join(content))

    print(f"‚úÖ Site map written to {SITEMAP_PATH}")


def update_documentation_index(manifest: Dict):
    """
    Update docs/reference/DOCUMENTATION_INDEX.md with new links
    while preserving existing structure.
    """
    index_path = DOCS_ROOT / "reference" / "DOCUMENTATION_INDEX.md"

    if not index_path.exists():
        print(f"‚ö†Ô∏è  {index_path} not found, skipping update")
        return

    with open(index_path, 'r', encoding='utf-8') as f:
        existing_content = f.read()

    # Parse documents by type
    docs_by_type = defaultdict(list)
    for doc in manifest['documents']:
        if doc.get('redirect'):
            continue
        if doc['status'] == 'deprecated':
            continue
        docs_by_type[doc['type']].append(doc)

    # Build sections
    sections = {
        'Architecture': docs_by_type['architecture'],
        'API': docs_by_type['api'],
        'Guides': docs_by_type['guide'],
        'Reports': docs_by_type['report'],
        'ADRs': docs_by_type['adr'],
    }

    # Append new links section (non-destructive)
    new_section = [
        "",
        "---",
        "",
        "## Auto-Generated Index",
        "",
        "*The following sections are automatically generated.*",
        "",
    ]

    for section_name, docs in sections.items():
        if not docs:
            continue

        new_section.append(f"### {section_name}")
        new_section.append("")

        for doc in sorted(docs, key=lambda d: d['title'])[:20]:  # Limit to 20
            rel_path = doc['path'].replace('docs/', '')
            title = doc['title']
            new_section.append(f"- [{title}]({rel_path})")

        new_section.append("")

    # Check if auto-generated section exists
    if "## Auto-Generated Index" in existing_content:
        # Replace existing auto-generated section
        parts = existing_content.split("## Auto-Generated Index")
        updated_content = parts[0] + '\n'.join(new_section)
    else:
        # Append to end
        updated_content = existing_content + '\n'.join(new_section)

    with open(index_path, 'w', encoding='utf-8') as f:
        f.write(updated_content)

    print(f"‚úÖ Updated {index_path}")


def update_main_index(manifest: Dict):
    """
    Update docs/INDEX.md with key links and metrics.
    """
    index_path = DOCS_ROOT / "INDEX.md"

    if not index_path.exists():
        print(f"‚ö†Ô∏è  {index_path} not found, skipping update")
        return

    with open(index_path, 'r', encoding='utf-8') as f:
        existing_content = f.read()

    # Build metrics section
    metrics = manifest['metrics']
    metrics_section = [
        "",
        "---",
        "",
        "## Documentation Metrics",
        "",
        f"**Total Documents:** {manifest['total_documents']}",
        f"**Last Updated:** {manifest['generated_at']}",
        "",
        "**By Type:**",
        "",
    ]

    for doc_type, count in sorted(metrics['by_type'].items(), key=lambda x: -x[1])[:10]:
        metrics_section.append(f"- {doc_type}: {count}")

    metrics_section.append("")
    metrics_section.append("**Key Resources:**")
    metrics_section.append("")
    metrics_section.append("- [Complete Documentation Index](reference/DOCUMENTATION_INDEX.md)")
    metrics_section.append("- [Site Map](_generated/SITE_MAP.md)")
    metrics_section.append("- [Redirects](_generated/REDIRECTS.md)")
    metrics_section.append("")

    # Replace or append
    if "## Documentation Metrics" in existing_content:
        parts = existing_content.split("## Documentation Metrics")
        updated_content = parts[0] + '\n'.join(metrics_section)
    else:
        updated_content = existing_content + '\n'.join(metrics_section)

    with open(index_path, 'w', encoding='utf-8') as f:
        f.write(updated_content)

    print(f"‚úÖ Updated {index_path}")


def main():
    """Main generation workflow."""
    print("=" * 80)
    print("LUKHAS Documentation Generation Tool")
    print("=" * 80)
    print()

    # Load manifest
    print(f"üìÇ Loading manifest from {MANIFEST_PATH}...")
    manifest = load_manifest()

    # Generate site map
    print(f"üó∫Ô∏è  Generating site map...")
    generate_site_map(manifest)

    # Update indices
    print(f"üìö Updating documentation indices...")
    update_documentation_index(manifest)
    update_main_index(manifest)

    print()
    print("=" * 80)
    print("GENERATION SUMMARY")
    print("=" * 80)
    print(f"‚úÖ Site map: {SITEMAP_PATH}")
    print(f"‚úÖ Documentation index updated")
    print(f"‚úÖ Main index updated")
    print()
    print("=" * 80)
    print(f"‚úÖ Phase 3 Complete")
    print("=" * 80)


if __name__ == "__main__":
    main()
