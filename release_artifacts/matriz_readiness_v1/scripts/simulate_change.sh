#!/usr/bin/env bash
# simulate_change.sh
# T4-safe simulate/apply script for destructive repo operations.
#
# Usage:
#   ./simulate_change.sh --simulate <action> [args...]
#   ./simulate_change.sh --apply <action> [args...]   # requires explicit consent and is disallowed under dry_run=true
#
# Actions:
#   move <old_path> <new_path>        -> git mv (create patch)
#   shim <old_path> <new_module> <symbols_comma>  -> create shim file at old_path re-exporting symbols
#   delete <path>                     -> remove file or directory (simulated)
#   rewrite_imports <mapping_json> <root> -> run rewrite_imports_libcst.py with mapping (simulated)
#
# Flags:
#   --simulate (default)  -> print commands, create patch in patches/, do not push
#   --apply               -> actually perform changes locally (ONLY run when dry_run=false and with human approval)
#
# Safety:
#   - This script ALWAYS creates a temp branch and never pushes.
#   - When running --simulate it creates a patch file: patches/<timestamp>_<action>.patch
#   - When running --apply, it requires explicit environment variable APPLY_CONFIRM=1 to proceed.
#   - Under dry_run sessions (gptpro_config.json dry_run=true) agents MUST NOT run with --apply.

set -euo pipefail

ARTDIR="release_artifacts/matriz_readiness_v1"
PATCHDIR="$ARTDIR/patches"
TIMESTAMP=$(date -u +"%Y%m%dT%H%M%SZ")
TMPBRANCH="simulate/${TIMESTAMP}"
SIMULATE=true
APPLY=false

# Parse flags
if [[ "${1:-}" == "--simulate" ]]; then
  SIMULATE=true
  shift
elif [[ "${1:-}" == "--apply" ]]; then
  SIMULATE=false
  APPLY=true
  shift
else
  # default to simulate
  SIMULATE=true
fi

if $APPLY ; then
  if [[ "${APPLY_CONFIRM:-}" != "1" ]]; then
    echo "APPLY not confirmed. Set APPLY_CONFIRM=1 in environment to proceed with --apply."
    exit 1
  fi
fi

function usage() {
  cat <<EOF
Usage:
  $0 [--simulate|--apply] <action> [args...]

Actions:
  move OLD_PATH NEW_PATH
  shim OLD_PATH NEW_MODULE SYMBOLS_COMMA   (symbols like: MemoryNode,SomeClass)
  delete PATH
  rewrite_imports MAPPING_JSON PATH_ROOT

Examples:
  $0 --simulate move candidate/old.py MATRIZ/old.py
  $0 --simulate shim candidate/core/foo.py MATRIZ/matriz_foo.py FooClass,Bar
  $0 --simulate delete old/legacy_module
  $0 --simulate rewrite_imports '{"candidate.core.matrix.nodes":"MATRIZ"}' .

Note: --apply requires APPLY_CONFIRM=1 in env and is forbidden while dry_run=true.
EOF
}

if [[ $# -lt 1 ]]; then
  usage
  exit 2
fi

ACTION="$1"; shift

mkdir -p "$PATCHDIR"
git fetch --prune --unshallow >/dev/null 2>&1 || true || true  # best-effort

# Ensure clean tree
if [[ -n $(git status --porcelain) ]]; then
  echo "Worktree not clean. Please commit or stash changes before running simulate_change.sh"
  git status --porcelain
  exit 3
fi

echo "Creating temp branch: $TMPBRANCH"
git checkout -b "$TMPBRANCH"

PATCHFILE="$PATCHDIR/${TIMESTAMP}_${ACTION}.patch"

# helper to create patch and reset branch (simulate)
function finalize_patch() {
  # create patch against origin/main (if available) or against previous commit
  BASE="origin/main"
  # fallback if origin/main doesn't exist
  if ! git rev-parse --verify --quiet "$BASE" >/dev/null; then
    BASE=$(git rev-parse --short HEAD^ || true)
  fi
  echo "Generating patch: $PATCHFILE"
  git diff --no-color "$BASE" > "$PATCHFILE"
  echo "Patch written: $PATCHFILE"
}

case "$ACTION" in

  move)
    OLD="$1"; NEW="$2"
    echo "Action: MOVE"
    echo "Old: $OLD"
    echo "New: $NEW"
    echo "----"
    if $SIMULATE; then
      echo "[SIMULATE] git mv \"$OLD\" \"$NEW\""
      # Create new path with copied content for verification
      mkdir -p "$(dirname "$NEW")"
      cp "$OLD" "$NEW" 2>/dev/null || true
      # If created, format and test compile
      echo "[SIMULATE] python3 -m compileall \"$NEW\""
      git add "$NEW"
      git rm --cached -r "$OLD" 2>/dev/null || true
      git add -A
      git commit -m "simulate(move): $OLD -> $NEW" || true
      finalize_patch
      echo "[SIMULATE] Reverting temp branch"
      git reset --hard HEAD~1 || true
      git checkout -
      git branch -D "$TMPBRANCH" || true
    else
      echo "[APPLY] Performing git mv"
      git mv "$OLD" "$NEW"
      git add -A
      git commit -m "refactor(flatten): move $OLD -> $NEW"
      echo "[APPLY] Done on local branch $TMPBRANCH (not pushed)"
    fi
    ;;

  shim)
    OLD="$1"; NEW_MODULE="$2"; SYMBOLS="$3"
    echo "Action: SHIM"
    echo "Old: $OLD"
    echo "New module: $NEW_MODULE"
    echo "Symbols: $SYMBOLS"
    echo "----"
    IFS=',' read -ra SYMS <<< "$SYMBOLS"
    if $SIMULATE; then
      echo "[SIMULATE] Creating file $NEW_MODULE (copy or create minimal content)"
      mkdir -p "$(dirname "$NEW_MODULE")"
      if [[ -f "$OLD" ]]; then
        cp "$OLD" "$NEW_MODULE" || true
      else
        echo "# autogenerated shim target (simulate) " > "$NEW_MODULE"
      fi
      echo "[SIMULATE] Creating shim at $OLD"
      shim_content="# DEPRECATED shim: moved to $NEW_MODULE\n"
      shim_content+="from ${NEW_MODULE%.*} import ${SYMBOLS}\n"
      shim_content+="__all__ = [${SYMBOLS//,/, }]\n"
      echo -e "$shim_content" > "$OLD"
      git add "$NEW_MODULE" "$OLD"
      git commit -m "simulate(shim): create shim $OLD -> $NEW_MODULE" || true
      finalize_patch
      git reset --hard HEAD~1 || true
      git checkout -
      git branch -D "$TMPBRANCH" || true
    else
      echo "[APPLY] Creating $NEW_MODULE and shim $OLD"
      mkdir -p "$(dirname "$NEW_MODULE")"
      if [[ -f "$OLD" ]]; then cp "$OLD" "$NEW_MODULE" || true; fi
      shim_content="# DEPRECATED shim: moved to $NEW_MODULE\nfrom ${NEW_MODULE%.*} import ${SYMBOLS}\n__all__ = [${SYMBOLS//,/, }]\n"
      echo -e "$shim_content" > "$OLD"
      git add "$NEW_MODULE" "$OLD"
      git commit -m "refactor(flatten): shim $OLD -> $NEW_MODULE"
    fi
    ;;

  delete)
    PATHDEL="$1"
    echo "Action: DELETE (simulated)"
    echo "Target: $PATHDEL"
    echo "----"
    if $SIMULATE; then
      echo "[SIMULATE] rm -rf \"$PATHDEL\""
      # create a minimal commit that removes path
      git rm -r --cached "$PATHDEL" 2>/dev/null || true
      rm -rf "$PATHDEL" || true
      git add -A
      git commit -m "simulate(delete): $PATHDEL" || true
      finalize_patch
      git reset --hard HEAD~1 || true
      git checkout -
      git branch -D "$TMPBRANCH" || true
    else
      echo "[APPLY] Deleting $PATHDEL (local)"
      rm -rf "$PATHDEL"
      git add -A
      git commit -m "chore(cleanup): delete $PATHDEL"
    fi
    ;;

  rewrite_imports)
    MAPPING="$1"
    ROOT="${2:-.}"
    echo "Action: REWRITE_IMPORTS"
    echo "Mapping: $MAPPING"
    echo "Root: $ROOT"
    echo "----"
    if $SIMULATE; then
      echo "[SIMULATE] Running rewrite_imports_libcst.py with mapping: $MAPPING"
      python3 release_artifacts/matriz_readiness_v1/scripts/rewrite_imports_libcst.py --mapping "$MAPPING" --root "$ROOT"
      git add -A
      git commit -m "simulate(rewrite_imports): mapping $MAPPING" || true
      finalize_patch
      git reset --hard HEAD~1 || true
      git checkout -
      git branch -D "$TMPBRANCH" || true
    else
      echo "[APPLY] Rewriting imports in place (local)"
      python3 release_artifacts/matriz_readiness_v1/scripts/rewrite_imports_libcst.py --mapping "$MAPPING" --root "$ROOT"
      git add -A
      git commit -m "refactor(imports): rewrite mapping $MAPPING"
    fi
    ;;

  *)
    echo "Unknown action: $ACTION"
    usage
    exit 4
    ;;
esac

echo "Done."
